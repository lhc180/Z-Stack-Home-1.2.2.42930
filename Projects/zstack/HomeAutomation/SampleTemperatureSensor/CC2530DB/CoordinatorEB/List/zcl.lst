###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                08/Aug/2015  11:42:16
# Copyright 2004-2015 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for 8051, Evaluation version 9.20
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Components\stack\zcl\zcl.c
#    Command line       =  
#        -f
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=10000 -DQUEUED_POLL_RATE=1000 -DRESPONSE_POLL_RATE=1000
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000)
#        -f
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Components\stack\zcl\zcl.c
#        -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D xNV_RESTORE -D
#        xHOLD_AUTO_START -D ZTOOL_P1 -D MT_TASK -D MT_APP_FUNC -D MT_SYS_FUNC
#        -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D
#        ZCL_READ -D ZCL_WRITE -D ZCL_REPORT -D ZCL_EZMODE -D ZCL_BASIC -D
#        ZCL_IDENTIFY -D ZCL_TEMPERATURE_MEASUREMENT -lC
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\CoordinatorEB\List\
#        -lA
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\CoordinatorEB\List\
#        --diag_suppress Pe001,Pa010 -o
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\CoordinatorEB\Obj\
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\Source\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\Source\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\zcl\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes
#    List file          =  
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\CoordinatorEB\List\zcl.lst
#    Object file        =  
#        C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Projects\zstack\HomeAutomation\SampleTemperatureSensor\CC2530DB\CoordinatorEB\Obj\zcl.r51
#
###############################################################################

C:\Users\Sears\Documents\GitHub\Z-Stack-Home-1.2.2.42930\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2014-12-01 07:40:09 -0800 (Mon, 01 Dec 2014) $
      4            Revision:       $Revision: 41277 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "AF.h"
     45          
     46          #include "zcl.h"
     47          #include "zcl_general.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52          
     53          /*********************************************************************
     54           * MACROS
     55           */
     56          /*** Frame Control ***/
     57          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     58          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     59          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     60          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     61          
     62          /*** Attribute Access Control ***/
     63          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     64          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     65          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     66          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     67          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     68          
     69          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     70          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     71          
     72          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     73                                                  (zclHdr).fc.manuSpecific == 0          && \
     74                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     75          
     76          // Commands that have corresponding responses
     77          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \
     78                                                  (cmd) == ZCL_CMD_WRITE                  || \
     79                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \
     80                                                  (cmd) == ZCL_CMD_CONFIG_REPORT          || \
     81                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG        || \
     82                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \
     83                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \
     84                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \
     85                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \
     86                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     87           
     88          /*********************************************************************
     89           * CONSTANTS
     90           */
     91          
     92          /*********************************************************************
     93           * TYPEDEFS
     94           */
     95          typedef struct zclLibPlugin
     96          {
     97            struct zclLibPlugin *next;
     98            uint16              startClusterID;    // starting cluster ID
     99            uint16              endClusterID;      // ending cluster ID
    100            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    101          } zclLibPlugin_t;
    102          
    103          // Command record list
    104          typedef struct zclCmdRecsList
    105          {
    106            struct zclCmdRecsList *pNext;
    107            uint8                 endpoint;
    108            uint8                 numCommands;
    109            CONST zclCommandRec_t *pCmdRecs;
    110          } zclCmdRecsList_t;
    111          
    112          // Attribute record list item
    113          typedef struct zclAttrRecsList
    114          {
    115            struct zclAttrRecsList *next;
    116            uint8                  endpoint;      // Used to link it into the endpoint descriptor
    117            zclReadWriteCB_t       pfnReadWriteCB;// Read or Write attribute value callback function
    118            zclAuthorizeCB_t       pfnAuthorizeCB;// Authorize Read or Write operation
    119            uint8                  numAttributes; // Number of the following records
    120            CONST zclAttrRec_t     *attrs;        // attribute records
    121          } zclAttrRecsList;
    122          
    123          // Cluster option list item
    124          typedef struct zclClusterOptionList
    125          {
    126            struct zclClusterOptionList *next;
    127            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    128            uint8                       numOptions; // Number of the following records
    129            zclOptionRec_t              *options;   // option records
    130          } zclClusterOptionList;
    131          
    132          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    133          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    134          
    135          typedef struct
    136          {
    137            zclParseInProfileCmd_t   pfnParseInProfile;
    138            zclProcessInProfileCmd_t pfnProcessInProfile;
    139          } zclCmdItems_t;
    140          
    141          
    142          // List record for external handler for unhandled ZCL Foundation commands/rsps
    143          typedef struct zclExternalFoundationHandlerList
    144          {
    145              struct zclExternalFoundationHandlerList *next;
    146              uint8 zcl_ExternalTaskID;
    147              uint8 zcl_ExternalEndPoint;
    148          } zclExternalFoundationHandlerList;
    149          
    150          
    151          /*********************************************************************
    152           * GLOBAL VARIABLES
    153           */
    154          
    155          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    156            uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    157          #endif
    158          
    159          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    160          zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    161          
    162          // ZCL Sequence number

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    163          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    164          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    165          uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    166          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    167          static uint8 savedZCLTransSeqNum = 0;
   \                     savedZCLTransSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    168          
    169          /*********************************************************************
    170           * EXTERNAL VARIABLES
    171           */
    172          
    173          /*********************************************************************
    174           * EXTERNAL FUNCTIONS
    175           */
    176          
    177          /*********************************************************************
    178           * LOCAL VARIABLES
    179           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    180          static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    181          
    182          #if defined ( ZCL_DISCOVER )
    183            static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
    184          #endif
    185          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    186          static zclAttrRecsList *attrList = (zclAttrRecsList *)NULL;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    187          static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    188          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    189          static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
   \                     rawAFMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    190          
    191          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    192          static zclExternalFoundationHandlerList *externalEndPointHandlerList = (zclExternalFoundationHandlerList *)NULL;
   \                     externalEndPointHandlerList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    193          #endif
    194          
    195          /*********************************************************************
    196           * LOCAL FUNCTIONS
    197           */
    198          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    199          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    200          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    201          
    202          #if !defined ( ZCL_STANDALONE )
    203          static uint8 zcl_addExternalFoundationHandler( uint8 taskId, uint8 endPointId );
    204          static uint8 zcl_getExternalFoundationHandler( afIncomingMSGPacket_t *pInMsg );
    205          #endif // !defined ( ZCL_STANDALONE )
    206          
    207          #if defined ( ZCL_DISCOVER )
    208            static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
    209          #endif
    210          
    211          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    212          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    213          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    214          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    215          
    216          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    217          
    218          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    219          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    220          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    221          #endif // ZCL_READ || ZCL_WRITE
    222          
    223          #ifdef ZCL_READ
    224          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen );
    225          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    226          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    227                                                   uint8 *pAttrData, uint16 *pDataLen );
    228          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    229          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    230          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    231          #endif // ZCL_READ
    232          
    233          #ifdef ZCL_WRITE
    234          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
    235                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    236          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
    237                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    238          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    239          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    240          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    241          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    242          #endif // ZCL_WRITE
    243          
    244          #ifdef ZCL_REPORT
    245          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    246          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    247          #endif // ZCL_REPORT
    248          
    249          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    250          
    251          #ifdef ZCL_DISCOVER
    252          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
    253          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
    254          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
    255          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
    256          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
    257          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    258          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
    259          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    260          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    261          #endif // ZCL_DISCOVER
    262          
    263          /*********************************************************************
    264           * Parse Profile Command Function Table
    265           */
    266          

   \                                 In  segment CODE_C, align 1
    267          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ....         DW `??zclParseInReadCmd::?relay`
   \   000002   ....         DW `??zclProcessInReadCmd::?relay`
   \   000004   ....         DW `??zclParseInReadRspCmd::?relay`
   \   000006   ....         DW `??zcl_HandleExternal::?relay`
   \   000008   ....         DW `??zclParseInWriteCmd::?relay`
   \   00000A   ....         DW `??zclProcessInWriteCmd::?relay`
   \   00000C   ....         DW `??zclParseInWriteCmd::?relay`
   \   00000E   ....         DW `??zclProcessInWriteUndividedCmd::?relay`
   \   000010   ....         DW `??zclParseInWriteRspCmd::?relay`
   \   000012   ....         DW `??zcl_HandleExternal::?relay`
   \   000014   ....         DW `??zclParseInWriteCmd::?relay`
   \   000016   ....         DW `??zclProcessInWriteCmd::?relay`
   \   000018   ....         DW `??zclParseInConfigReportCmd::?relay`
   \   00001A   ....         DW `??zcl_HandleExternal::?relay`
   \   00001C   ....         DW `??zclParseInConfigReportRspCmd::?relay`
   \   00001E   ....         DW `??zcl_HandleExternal::?relay`
   \   000020   ....         DW `??zclParseInReadReportCfgCmd::?relay`
   \   000022   ....         DW `??zcl_HandleExternal::?relay`
   \   000024   ....         DW `??zclParseInReadReportCfgRspCmd::?relay`
   \   000026   ....         DW `??zcl_HandleExternal::?relay`
   \   000028   ....         DW `??zclParseInReportCmd::?relay`
   \   00002A   ....         DW `??zcl_HandleExternal::?relay`
   \   00002C   ....         DW `??zclParseInDefaultRspCmd::?relay`
   \   00002E   ....         DW `??zcl_HandleExternal::?relay`
   \   000030   0000         DW 0H
   \   000032   0000         DW 0H
   \   000034   0000         DW 0H
   \   000036   0000         DW 0H
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   0000         DW 0H
   \   00003E   0000         DW 0H
   \   000040   0000         DW 0H
   \   000042   0000         DW 0H
   \   000044   0000         DW 0H
   \   000046   0000         DW 0H
   \   000048   0000         DW 0H
   \   00004A   0000         DW 0H
   \   00004C   0000         DW 0H
   \   00004E   0000         DW 0H
   \   000050   0000         DW 0H
   \   000052   0000         DW 0H
   \   000054   0000         DW 0H
   \   000056   0000         DW 0H
   \   000058   0000         DW 0H
   \   00005A   0000         DW 0H
    268          {
    269          #ifdef ZCL_READ
    270            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    271            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
    272          #else
    273            /* ZCL_CMD_READ */                { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    274            /* ZCL_CMD_READ_RSP */            { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    275          #endif // ZCL_READ
    276          
    277          #ifdef ZCL_WRITE
    278            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    279            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    280            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
    281            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    282          #else
    283            /* ZCL_CMD_WRITE */               { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    284            /* ZCL_CMD_WRITE_UNDIVIDED */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    285            /* ZCL_CMD_WRITE_RSP */           { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    286            /* ZCL_CMD_WRITE_NO_RSP */        { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    287          #endif // ZCL_WRITE
    288          
    289          #ifdef ZCL_REPORT
    290            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
    291            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
    292            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
    293            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
    294            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
    295          #else
    296            /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    297            /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    298            /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    299            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    300            /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    301          #endif // ZCL_REPORT
    302          
    303            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
    304          
    305          #ifdef ZCL_DISCOVER
    306            /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    307            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
    308            /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    309            /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    310            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    311            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    312            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    313            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    314            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    315            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    316            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
    317          #else
    318            /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
    319            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    320            /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    321            /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    322            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    323            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    324            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    325            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    326            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    327            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    328            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    329          #endif // ZCL_DISCOVER
    330          };
    331          
    332          /*********************************************************************
    333           * PUBLIC FUNCTIONS
    334           *********************************************************************/
    335          
    336          #if !defined ( ZCL_STANDALONE )
    337          /*********************************************************************
    338           * @fn          zcl_Init
    339           *
    340           * @brief       Initialization function for the zcl layer.
    341           *
    342           * @param       task_id - ZCL task id
    343           *
    344           * @return      none
    345           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    346          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    347          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    348            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    349          }
   \   000009   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    350          #endif
    351          
    352          #if !defined ( ZCL_STANDALONE )
    353          /*********************************************************************
    354           * @fn          zcl_event_loop
    355           *
    356           * @brief       Event Loop Processor for zcl.
    357           *
    358           * @param       task_id - task id
    359           * @param       events - event bitmap
    360           *
    361           * @return      unprocessed events
    362           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    363          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    364          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
    365            uint8 *msgPtr;
    366          
    367            (void)task_id;  // Intentionally unreferenced parameter
    368          
    369            if ( events & SYS_EVENT_MSG )
   \   000009   EB           MOV     A,R3
   \   00000A   5480         ANL     A,#0x80
   \   00000C   604D         JZ      ??zcl_event_loop_0
    370            {
    371              msgPtr = osal_msg_receive( zcl_TaskID );
   \   00000E                ; Setup parameters for call to function osal_msg_receive
   \   00000E   800E         SJMP    ??zcl_event_loop_1
    372              while ( msgPtr != NULL )
    373              {
    374                uint8 dealloc = TRUE;
    375          
    376                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    377                {
    378                  zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_2:
   \   000010                ; Setup parameters for call to function zcl_ProcessMessageMSG
   \   000010   EE           MOV     A,R6
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   `??zcl_ProcessMessageMSG::?relay`; Banked call to: zcl_ProcessMessageMSG
    379                }
    380                else 
    381                {
    382                  uint8 taskID;
    383                  taskID = zcl_getExternalFoundationHandler( (afIncomingMSGPacket_t *)msgPtr );
    384                    
    385                  if ( taskID != TASK_NO_TASK )
    386                  {
    387                    // send it to another task to process.
    388                    osal_msg_send( taskID, msgPtr );
    389                    dealloc = FALSE;
    390                  }
    391                }
    392          
    393                // Release the memory
    394                if ( dealloc )
    395                {
    396                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_3:
   \   000017                ; Setup parameters for call to function osal_msg_deallocate
   \   000017   EE           MOV     A,R6
   \   000018   FA           MOV     R2,A
   \   000019   EF           MOV     A,R7
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
    397                }
    398          
    399                // Next
    400                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_1:
   \   00001E                ; Setup parameters for call to function osal_msg_receive
   \   00001E   90....       MOV     DPTR,#zcl_TaskID
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   `??osal_msg_receive::?relay`; Banked call to: osal_msg_receive
   \   000026   8A..         MOV     ?V2,R2
   \   000028   8B..         MOV     ?V3,R3
   \   00002A   AE..         MOV     R6,?V2
   \   00002C   AF..         MOV     R7,?V3
   \   00002E   EE           MOV     A,R6
   \   00002F   4F           ORL     A,R7
   \   000030   6020         JZ      ??zcl_event_loop_4
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   641A         XRL     A,#0x1a
   \   000039   60D5         JZ      ??zcl_event_loop_2
   \   00003B                ; Setup parameters for call to function zcl_getExternalFoundationHandler
   \   00003B   EE           MOV     A,R6
   \   00003C   FA           MOV     R2,A
   \   00003D   EF           MOV     A,R7
   \   00003E   FB           MOV     R3,A
   \   00003F   12....       LCALL   `??zcl_getExternalFoundationHandler::?relay`; Banked call to: zcl_getExternalFoundationHandler
   \   000042   E9           MOV     A,R1
   \   000043   F9           MOV     R1,A
   \   000044   74FF         MOV     A,#-0x1
   \   000046   69           XRL     A,R1
   \   000047   60CE         JZ      ??zcl_event_loop_3
   \   000049                ; Setup parameters for call to function osal_msg_send
   \   000049   EE           MOV     A,R6
   \   00004A   FA           MOV     R2,A
   \   00004B   EF           MOV     A,R7
   \   00004C   FB           MOV     R3,A
   \   00004D   12....       LCALL   `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   000050   80CC         SJMP    ??zcl_event_loop_1
    401              }
    402          
    403              // return unprocessed events
    404              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   000052   AA..         MOV     R2,?V0
   \   000054   E5..         MOV     A,?V1
   \   000056   6480         XRL     A,#0x80
   \   000058   FB           MOV     R3,A
   \   000059   8004         SJMP    ??zcl_event_loop_5
    405            }
    406          
    407            // Discard unknown events
    408            return 0;
   \                     ??zcl_event_loop_0:
   \   00005B   7A00         MOV     R2,#0x0
   \   00005D   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_5:
   \   00005F   02....       LJMP    ?Subroutine1 & 0xFFFF
    409          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    410          #endif
    411          
    412          #if !defined ( ZCL_STANDALONE )
    413          /*********************************************************************
    414           * @fn      zcl_registerForMsg
    415           *
    416           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    417           *          messages that aren't processed to one task (if a task is
    418           *          registered).
    419           *
    420           * @param   taskId - task Id of the Application where commands will be sent to
    421           *
    422           * @return  TRUE if task registeration successful, FALSE otherwise
    423           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    424          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    425          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    426            return zcl_addExternalFoundationHandler( taskId, AF_BROADCAST_ENDPOINT );  
   \   000005                ; Setup parameters for call to function zcl_addExternalFoundationHandler
   \   000005   7AFF         MOV     R2,#-0x1
   \   000007   02....       LJMP    ?Subroutine2 & 0xFFFF
    427          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   `??zcl_addExternalFoundationHandler::?relay`; Banked call to: zcl_addExternalFoundationHandler
   \   000003                REQUIRE ??Subroutine193_0
   \   000003                ; // Fall through to label ??Subroutine193_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine193_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    428          
    429          /*********************************************************************
    430           * @fn      zcl_registerForMsgExt
    431           *
    432           * @brief   This function enables a Task to register to recieve all 
    433           *          incoming Foundation Command/Response messages, for a particular 
    434           *          End Point, that aren't processed by ZCL.
    435           *
    436           *          NOTE: Any Task registered for a unique end point will take
    437           *          priority over any Task registered with the AF_BROADCAST_ENDPOINT
    438           *          value.  ie. If task A registers for End Point 1, task B registers
    439           *          for AF_BROADCAST_ENDPOINT,  commands addressed to End Point 1 will be
    440           *          sent to Task A and NOT Task B.
    441           *
    442           * @param   taskId - task Id of the Application where commands will be sent to
    443           * @param   endPointId - end point Id of interest
    444           *
    445           * @return  TRUE if task registeration successful, FALSE otherwise
    446           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    447          uint8 zcl_registerForMsgExt( uint8 taskId, uint8 endPointId  )
   \                     zcl_registerForMsgExt:
    448          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    449            return ( zcl_addExternalFoundationHandler( taskId, endPointId  ) );
   \   000005                ; Setup parameters for call to function zcl_addExternalFoundationHandler
   \   000005   02....       LJMP    ?Subroutine2 & 0xFFFF
    450          }
    451          
    452          /*********************************************************************
    453           * @fn      zcl_addExternalFoundationHandler
    454           *
    455           * @brief   This function adds a record to the internal list of external
    456           *          handlers of unhandled incoming Foundation Command/Response messages.
    457           *
    458           * @param   taskId - task Id of the Application where commands will be sent to
    459           * @param   endPointId - end point Id of interest
    460           *
    461           * @return  TRUE if task registeration successful, FALSE otherwise
    462           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    463          uint8 zcl_addExternalFoundationHandler( uint8 taskId, uint8 endPointId  )
   \                     zcl_addExternalFoundationHandler:
    464          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FF           MOV     R7,A
    465            zclExternalFoundationHandlerList *pNewItem;
    466            zclExternalFoundationHandlerList *pLoop;
    467            zclExternalFoundationHandlerList *pLoopPrev;
    468            
    469            // Fill in the new endpoint registrant list
    470            pNewItem = zcl_mem_alloc( sizeof( zclExternalFoundationHandlerList ) );
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   7A04         MOV     R2,#0x4
   \   00000B   7B00         MOV     R3,#0x0
   \   00000D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000010   8A..         MOV     ?V0,R2
   \   000012   8B..         MOV     ?V1,R3
   \   000014   A8..         MOV     R0,?V0
   \   000016   A9..         MOV     R1,?V1
    471            if ( pNewItem == NULL )
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   6031         JZ      ??zcl_addExternalFoundationHandler_0
    472            {
    473              return ( false );
    474            }
    475              
    476            pNewItem->zcl_ExternalEndPoint = endPointId;
   \   00001C   EF           MOV     A,R7
   \   00001D   8882         MOV     DPL,R0
   \   00001F   8983         MOV     DPH,R1
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   F0           MOVX    @DPTR,A
    477            pNewItem->zcl_ExternalTaskID = taskId;
   \   000025   EE           MOV     A,R6
   \   000026   8882         MOV     DPL,R0
   \   000028   8983         MOV     DPH,R1
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   12....       LCALL   ?Subroutine35 & 0xFFFF
    478            pNewItem->next = NULL;
    479            
    480            // Add to the list
    481            if ( externalEndPointHandlerList == NULL )
   \                     ??CrossCallReturnLabel_36:
   \   00002F   90....       MOV     DPTR,#externalEndPointHandlerList
   \   000032   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   000035   7009         JNZ     ??zcl_addExternalFoundationHandler_1
    482            {
    483              externalEndPointHandlerList = pNewItem;
   \   000037   90....       MOV     DPTR,#externalEndPointHandlerList
   \   00003A   E8           MOV     A,R0
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   E9           MOV     A,R1
   \   00003E   803F         SJMP    ??zcl_addExternalFoundationHandler_2
    484            }
    485            else
    486            {
    487              // make sure no one else tried to register for this endpoint
    488              pLoop = externalEndPointHandlerList;
   \                     ??zcl_addExternalFoundationHandler_1:
   \   000040   E0           MOVX    A,@DPTR
   \   000041   FB           MOV     R3,A
    489              pLoopPrev = externalEndPointHandlerList;
    490              
    491              while ( pLoop != NULL )
    492              {
    493                if ( ( pLoop->zcl_ExternalEndPoint ) == endPointId )
   \                     ??zcl_addExternalFoundationHandler_3:
   \   000042   8A82         MOV     DPL,R2
   \   000044   8B83         MOV     DPH,R3
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   6F           XRL     A,R7
   \   00004B   7004         JNZ     ??zcl_addExternalFoundationHandler_4
    494                {
    495                  return ( false );
   \                     ??zcl_addExternalFoundationHandler_0:
   \   00004D   7900         MOV     R1,#0x0
   \   00004F   8031         SJMP    ??zcl_addExternalFoundationHandler_5
    496                }
    497                pLoopPrev = pLoop;
   \                     ??zcl_addExternalFoundationHandler_4:
   \   000051   EA           MOV     A,R2
   \   000052   FC           MOV     R4,A
   \   000053   EB           MOV     A,R3
   \   000054   FD           MOV     R5,A
    498                pLoop = pLoop->next;
   \   000055   8A82         MOV     DPL,R2
   \   000057   8B83         MOV     DPH,R3
   \   000059   12....       LCALL   ??Subroutine176_0 & 0xFFFF
    499              }
   \                     ??CrossCallReturnLabel_305:
   \   00005C   70E4         JNZ     ??zcl_addExternalFoundationHandler_3
    500          
    501              if ( endPointId == AF_BROADCAST_ENDPOINT )
   \   00005E   74FF         MOV     A,#-0x1
   \   000060   6F           XRL     A,R7
   \   000061   700C         JNZ     ??zcl_addExternalFoundationHandler_6
    502              {
    503                // put new registration at the end of the list
    504                pLoopPrev->next = pNewItem;
   \   000063   8C82         MOV     DPL,R4
   \   000065   8D83         MOV     DPH,R5
   \   000067   12....       LCALL   ?Subroutine43 & 0xFFFF
    505                pNewItem->next = NULL;
    506              }
   \                     ??CrossCallReturnLabel_55:
   \   00006A   E4           CLR     A
   \   00006B   F0           MOVX    @DPTR,A
   \   00006C   A3           INC     DPTR
   \   00006D   8010         SJMP    ??zcl_addExternalFoundationHandler_2
    507              else 
    508              {
    509                // put new registration at the front of the list
    510                zclExternalFoundationHandlerList *temp = externalEndPointHandlerList;
   \                     ??zcl_addExternalFoundationHandler_6:
   \   00006F   90....       MOV     DPTR,#externalEndPointHandlerList
   \   000072   12....       LCALL   ??Subroutine198_0 & 0xFFFF
    511                externalEndPointHandlerList = pNewItem;
   \                     ??CrossCallReturnLabel_384:
   \   000075   90....       MOV     DPTR,#externalEndPointHandlerList
   \   000078   12....       LCALL   ?Subroutine43 & 0xFFFF
    512                pNewItem->next = temp;
    513              }
    514            }
   \                     ??CrossCallReturnLabel_56:
   \   00007B   EA           MOV     A,R2
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   A3           INC     DPTR
   \   00007E   EB           MOV     A,R3
   \                     ??zcl_addExternalFoundationHandler_2:
   \   00007F   F0           MOVX    @DPTR,A
    515          
    516            return ( true );
   \   000080   7901         MOV     R1,#0x1
   \                     ??zcl_addExternalFoundationHandler_5:
   \   000082   02....       LJMP    ?Subroutine3 & 0xFFFF
    517                  
    518          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine138:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   000003   E4           CLR     A
   \   000004   F0           MOVX    @DPTR,A
   \   000005   A3           INC     DPTR
   \   000006   F0           MOVX    @DPTR,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine176_0:
   \   000000   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_406:
   \   000003   EA           MOV     A,R2
   \   000004   4B           ORL     A,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine198_0:
   \   000000   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_407:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine155:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    519          
    520          /*********************************************************************
    521           * @fn      zcl_getExternalFoundationHandler
    522           *
    523           * @brief   This function retrieves the Task ID of the task registered
    524           *          to received unhandled incoming Foundation Command/Response messages
    525           *          for a particular End Point ID.
    526           *
    527           * @param   pInMsg - recevied ZCL command
    528           *
    529           * @return  TASK ID of registered task.  If no task is reigistered, it returns
    530           *          TASK_NO_TASK.
    531           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    532          static uint8 zcl_getExternalFoundationHandler( afIncomingMSGPacket_t *pInMsg )
   \                     zcl_getExternalFoundationHandler:
    533          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    534            zclExternalFoundationHandlerList *pLoop;
    535            uint8 addressedEndPointId = pInMsg->endPoint;
   \   000004   EA           MOV     A,R2
   \   000005   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   000008   3B           ADDC    A,R3
   \   000009   F583         MOV     DPH,A
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   FA           MOV     R2,A
    536            
    537            // make sure no one else tried to register for this endpoint
    538            pLoop = externalEndPointHandlerList;
   \   00000D   90....       MOV     DPTR,#externalEndPointHandlerList
   \   000010   8004         SJMP    ??zcl_getExternalFoundationHandler_0
    539            
    540            while ( pLoop != NULL )
    541            {
    542              if ( ( ( pLoop->zcl_ExternalEndPoint ) == addressedEndPointId ) ||
    543                   ( ( pLoop->zcl_ExternalEndPoint ) == AF_BROADCAST_ENDPOINT ) )
    544              {
    545                return ( pLoop->zcl_ExternalTaskID );
    546              }
    547              pLoop = pLoop->next;
   \                     ??zcl_getExternalFoundationHandler_1:
   \   000012   8882         MOV     DPL,R0
   \   000014   8983         MOV     DPH,R1
   \                     ??zcl_getExternalFoundationHandler_0:
   \   000016   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_368:
   \   000019   601C         JZ      ??zcl_getExternalFoundationHandler_2
   \   00001B   8882         MOV     DPL,R0
   \   00001D   8983         MOV     DPH,R1
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   FB           MOV     R3,A
   \   000024   EA           MOV     A,R2
   \   000025   6B           XRL     A,R3
   \   000026   6005         JZ      ??zcl_getExternalFoundationHandler_3
   \   000028   74FF         MOV     A,#-0x1
   \   00002A   6B           XRL     A,R3
   \   00002B   70E5         JNZ     ??zcl_getExternalFoundationHandler_1
   \                     ??zcl_getExternalFoundationHandler_3:
   \   00002D   8882         MOV     DPL,R0
   \   00002F   8983         MOV     DPH,R1
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F9           MOV     R1,A
   \   000035   8002         SJMP    ??zcl_getExternalFoundationHandler_4
    548            }    
    549            
    550            return ( TASK_NO_TASK );         
   \                     ??zcl_getExternalFoundationHandler_2:
   \   000037   79FF         MOV     R1,#-0x1
   \                     ??zcl_getExternalFoundationHandler_4:
   \   000039   02....       LJMP    ?Subroutine0 & 0xFFFF
    551          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine195_0:
   \   000000   12....       LCALL   ?Subroutine157 & 0xFFFF
   \                     ??CrossCallReturnLabel_381:
   \   000003   49           ORL     A,R1
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine172:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine157:
   \   000000   12....       LCALL   ?Subroutine172 & 0xFFFF
   \                     ??CrossCallReturnLabel_515:
   \   000003   F9           MOV     R1,A
   \   000004   E8           MOV     A,R0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine116:
   \   000000   12....       LCALL   ?Subroutine166 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine166:
   \   000000   2414         ADD     A,#0x14
   \   000002   F582         MOV     DPL,A
   \   000004   E4           CLR     A
   \   000005   22           RET
    552          #endif
    553          
    554          #if !defined ( ZCL_STANDALONE )
    555          /*********************************************************************
    556           * @fn      zcl_HandleExternal
    557           *
    558           * @brief
    559           *
    560           * @param   pInMsg - incoming message to process
    561           *
    562           * @return  TRUE
    563           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    564          uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
   \                     zcl_HandleExternal:
    565          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    566            zclIncomingMsg_t *pCmd;
    567            uint8 taskID;
    568            
    569            taskID = zcl_getExternalFoundationHandler( pInMsg->msg );
   \   000009                ; Setup parameters for call to function zcl_getExternalFoundationHandler
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_385:
   \   000010   12....       LCALL   `??zcl_getExternalFoundationHandler::?relay`; Banked call to: zcl_getExternalFoundationHandler
   \   000013   E9           MOV     A,R1
   \   000014   F5..         MOV     ?V0,A
    570            
    571            if ( taskID == TASK_NO_TASK )
   \   000016   74FF         MOV     A,#-0x1
   \   000018   65..         XRL     A,?V0
   \   00001A   7003         JNZ     $+5
   \   00001C   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    572            {
    573              return ( TRUE );
    574            }
    575          
    576            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   00001F                ; Setup parameters for call to function osal_msg_allocate
   \   00001F   7A19         MOV     R2,#0x19
   \   000021   7B00         MOV     R3,#0x0
   \   000023   12....       LCALL   `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
    577            if ( pCmd != NULL )
   \   000026   EA           MOV     A,R2
   \   000027   4B           ORL     A,R3
   \   000028   7003         JNZ     $+5
   \   00002A   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    578            {
    579              // fill in the message
    580              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   00002D   8A82         MOV     DPL,R2
   \   00002F   8B83         MOV     DPH,R3
   \   000031   7434         MOV     A,#0x34
   \   000033   12....       LCALL   ?Subroutine38 & 0xFFFF
    581              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_44:
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   EA           MOV     A,R2
   \   000039   2402         ADD     A,#0x2
   \   00003B   FC           MOV     R4,A
   \   00003C   E4           CLR     A
   \   00003D   3B           ADDC    A,R3
   \   00003E   FD           MOV     R5,A
   \   00003F   7406         MOV     A,#0x6
   \   000041   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    582              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000044   8E82         MOV     DPL,R6
   \   000046   8F83         MOV     DPH,R7
   \   000048   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   00004B   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_489:
   \   00004E   8A82         MOV     DPL,R2
   \   000050   8B83         MOV     DPH,R3
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   EC           MOV     A,R4
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   \   00005D   ED           MOV     A,R5
   \   00005E   12....       LCALL   ?Subroutine31 & 0xFFFF
    583              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_26:
   \   000061   A3           INC     DPTR
   \   000062   EA           MOV     A,R2
   \   000063   240A         ADD     A,#0xa
   \   000065   FC           MOV     R4,A
   \   000066   E4           CLR     A
   \   000067   3B           ADDC    A,R3
   \   000068   FD           MOV     R5,A
   \   000069   740C         MOV     A,#0xc
   \   00006B   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    584              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   00006E   8E82         MOV     DPL,R6
   \   000070   8F83         MOV     DPH,R7
   \   000072   12....       LCALL   ?Subroutine172 & 0xFFFF
   \                     ??CrossCallReturnLabel_510:
   \   000075   C8           XCH     A,R0
   \   000076   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   000079   38           ADDC    A,R0
   \   00007A   F583         MOV     DPH,A
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   C0E0         PUSH    A
   \   00007F   EA           MOV     A,R2
   \   000080   2416         ADD     A,#0x16
   \   000082   F582         MOV     DPL,A
   \   000084   E4           CLR     A
   \   000085   3B           ADDC    A,R3
   \   000086   F583         MOV     DPH,A
   \   000088   D0E0         POP     A
   \   00008A   F0           MOVX    @DPTR,A
    585              pCmd->attrCmd   = pInMsg->attrCmd;
   \   00008B   EE           MOV     A,R6
   \   00008C   240C         ADD     A,#0xc
   \   00008E   F8           MOV     R0,A
   \   00008F   E4           CLR     A
   \   000090   3F           ADDC    A,R7
   \   000091   F9           MOV     R1,A
   \   000092   8882         MOV     DPL,R0
   \   000094   8983         MOV     DPH,R1
   \   000096   12....       LCALL   ??Subroutine213_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_482:
   \   000099   EA           MOV     A,R2
   \   00009A   2417         ADD     A,#0x17
   \   00009C   F582         MOV     DPL,A
   \   00009E   E4           CLR     A
   \   00009F   3B           ADDC    A,R3
   \   0000A0   F583         MOV     DPH,A
   \   0000A2   EC           MOV     A,R4
   \   0000A3   F0           MOVX    @DPTR,A
   \   0000A4   A3           INC     DPTR
   \   0000A5   ED           MOV     A,R5
   \   0000A6   12....       LCALL   ?Subroutine35 & 0xFFFF
    586          
    587              // Application will free the attrCmd buffer
    588              pInMsg->attrCmd = NULL;
    589          
    590              /* send message through task message */
    591              osal_msg_send( taskID, (uint8 *)pCmd );
   \                     ??CrossCallReturnLabel_37:
   \   0000A9                ; Setup parameters for call to function osal_msg_send
   \   0000A9   A9..         MOV     R1,?V0
   \   0000AB   12....       LCALL   `??osal_msg_send::?relay`; Banked call to: osal_msg_send
    592            }
    593          
    594            return ( TRUE );
   \                     ??zcl_HandleExternal_0:
   \   0000AE   7901         MOV     R1,#0x1
   \   0000B0   02....       LJMP    ?Subroutine1 & 0xFFFF
    595          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine170:
   \   000000   12....       LCALL   ?Subroutine173 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL   ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine134:
   \   000000   12....       LCALL   ?Subroutine170 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine173:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   12....       LCALL   ?Subroutine156 & 0xFFFF
   \                     ??CrossCallReturnLabel_349:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine156:
   \   000000   12....       LCALL   ?Subroutine172 & 0xFFFF
   \                     ??CrossCallReturnLabel_514:
   \   000003   F9           MOV     R1,A
   \   000004   8882         MOV     DPL,R0
   \   000006   8983         MOV     DPH,R1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   12....       LCALL   ?Subroutine169 & 0xFFFF
   \                     ??CrossCallReturnLabel_459:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine169:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine212_0
   \   000002                ; // Fall through to label ??Subroutine212_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine212_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine213_0
   \   000002                ; // Fall through to label ??Subroutine213_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine213_0:
   \   000000   12....       LCALL   ??Subroutine221_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_535:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine221_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET
    596          #endif
    597          
    598          
    599          /*********************************************************************
    600           * @fn          zcl_getRawAFMsg
    601           *
    602           * @brief       Call to get original unprocessed AF message
    603           *              (not parsed by ZCL).
    604           *
    605           *   NOTE:  This function can only be called during a ZCL callback function
    606           *          and the calling function must NOT change any data in the message.
    607           *
    608           * @param       none
    609           *
    610           * @return      pointer to original AF message, NULL if not processing
    611           *              AF message.
    612           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    613          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    614          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    615            return ( rawAFMsg );
   \   000004   90....       MOV     DPTR,#rawAFMsg
   \   000007   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_386:
   \   00000A   80..         SJMP    ?Subroutine0
    616          }
    617          
    618          /*********************************************************************
    619           * @fn          zcl_getParsedTransSeqNum
    620           *
    621           * @brief       Call to the get the transaction sequence number from 
    622           *              the incoming message.
    623           *
    624           *   NOTE:  This function can only be called during a ZCL callback function
    625           *          and the calling function must NOT change any data in the message.
    626           *
    627           * @param       none
    628           *
    629           * @return      transaction sequence number.
    630           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    631          uint8 zcl_getParsedTransSeqNum( void )
   \                     zcl_getParsedTransSeqNum:
    632          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    633            return ( savedZCLTransSeqNum );
   \   000004   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009                REQUIRE ?Subroutine0
   \   000009                ; // Fall through to label ?Subroutine0
    634          }
    635          
    636          /*********************************************************************
    637           * @fn          zcl_registerPlugin
    638           *
    639           * @brief       Add a Cluster Library handler
    640           *
    641           * @param       startClusterID - starting cluster ID
    642           * @param       endClusterID - ending cluster ID
    643           * @param       pfnHdlr - function pointer to incoming message handler
    644           *
    645           * @return      ZSuccess if OK
    646           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    647          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    648                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    649          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    650            zclLibPlugin_t *pNewItem;
    651            zclLibPlugin_t *pLoop;
    652          
    653            // Fill in the new profile list
    654            pNewItem = zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A08         MOV     R2,#0x8
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    655            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerPlugin_0
    656            {
    657              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8040         SJMP    ??CrossCallReturnLabel_38
    658            }
    659          
    660            // Fill in the plugin record.
    661            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_0:
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   12....       LCALL   ?Subroutine32 & 0xFFFF
    662            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_28:
   \   00002E   A3           INC     DPTR
   \   00002F   E5..         MOV     A,?V0
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   12....       LCALL   ?Subroutine25 & 0xFFFF
    663            pNewItem->endClusterID = endClusterID;
    664            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \                     ??CrossCallReturnLabel_18:
   \   000036   740C         MOV     A,#0xc
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   12....       LCALL   ?Subroutine46 & 0xFFFF
    665          
    666            // Find spot in list
    667            if (  plugins == NULL )
   \                     ??CrossCallReturnLabel_540:
   \   000045   90....       MOV     DPTR,#plugins
   \   000048   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   00004B   90....       MOV     DPTR,#plugins
   \   00004E   6011         JZ      ??zcl_registerPlugin_1
    668            {
    669              plugins = pNewItem;
    670            }
    671            else
    672            {
    673              // Look for end of list
    674              pLoop = plugins;
   \   000050   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   000053   8003         SJMP    ??zcl_registerPlugin_2
    675              while ( pLoop->next != NULL )
    676              {
    677                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_3:
   \   000055   EA           MOV     A,R2
   \   000056   FC           MOV     R4,A
   \   000057   EB           MOV     A,R3
    678              }
   \                     ??zcl_registerPlugin_2:
   \   000058   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   00005B   70F8         JNZ     ??zcl_registerPlugin_3
    679          
    680              // Put new item at end of list
    681              pLoop->next = pNewItem;
   \   00005D   8C82         MOV     DPL,R4
   \   00005F   8D83         MOV     DPH,R5
    682            }
   \                     ??zcl_registerPlugin_1:
   \   000061   12....       LCALL   ?Subroutine36 & 0xFFFF
    683          
    684            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_38:
   \   000064   02....       LJMP    ?Subroutine1 & 0xFFFF
    685          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   E5..         MOV     A,?V1
   \   000002   12....       LCALL   ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   000005   A3           INC     DPTR
   \   000006   EE           MOV     A,R6
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   EF           MOV     A,R7
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine137:
   \   000000   12....       LCALL   ?Subroutine170 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   FD           MOV     R5,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005                REQUIRE ??Subroutine176_0
   \   000005                ; // Fall through to label ??Subroutine176_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_252:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine161:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   12....       LCALL   ?Subroutine154 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine154:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine222_0
   \   000002                ; // Fall through to label ??Subroutine222_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine222_0:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    686          
    687          #ifdef ZCL_DISCOVER
    688          /*********************************************************************
    689           * @fn          zcl_registerCmdList
    690           *
    691           * @brief       Register a Command List with ZCL Foundation
    692           *
    693           * @param       endpoint - endpoint the attribute list belongs to
    694           * @param       newCmdList - array of command records
    695           *
    696           * @return      ZSuccess if OK
    697           */
    698          ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 cmdListSize, CONST zclCommandRec_t newCmdList[] )
    699          {
    700            zclCmdRecsList_t *pNewItem;
    701            zclCmdRecsList_t *pLoop;
    702          
    703            // Fill in the new profile list
    704            pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
    705            if ( pNewItem == NULL )
    706            {
    707              return (ZMemError);
    708            }
    709          
    710            pNewItem->pNext = (zclCmdRecsList_t *)NULL;
    711            pNewItem->endpoint = endpoint;
    712            pNewItem->numCommands = cmdListSize;
    713            pNewItem->pCmdRecs = newCmdList;
    714          
    715            // Find spot in list
    716            if ( gpCmdList == NULL )
    717            {
    718              gpCmdList = pNewItem;
    719            }
    720            else
    721            {
    722              // Look for end of list
    723              pLoop = gpCmdList;
    724              while ( pLoop->pNext != NULL )
    725              {
    726                pLoop = pLoop->pNext;
    727              }
    728          
    729              // Put new item at end of list
    730              pLoop->pNext = pNewItem;
    731            }
    732          
    733            return ( ZSuccess );
    734          }
    735          #endif  // ZCL_DISCOVER
    736          
    737          /*********************************************************************
    738           * @fn          zcl_registerAttrList
    739           *
    740           * @brief       Register an Attribute List with ZCL Foundation
    741           *
    742           * @param       endpoint - endpoint the attribute list belongs to
    743           * @param       numAttr - number of attributes in list
    744           * @param       newAttrList - array of Attribute records.
    745           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    746           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    747           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    748           *
    749           * @return      ZSuccess if OK
    750           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    751          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    752          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    753            zclAttrRecsList *pNewItem;
    754            zclAttrRecsList *pLoop;
    755          
    756            // Fill in the new profile list
    757            pNewItem = zcl_mem_alloc( sizeof( zclAttrRecsList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A0A         MOV     R2,#0xa
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    758            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerAttrList_0
    759            {
    760              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8033         SJMP    ??CrossCallReturnLabel_39
    761            }
    762          
    763            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_0:
   \   000024   12....       LCALL   ?Subroutine16 & 0xFFFF
    764            pNewItem->endpoint = endpoint;
    765            pNewItem->pfnReadWriteCB = NULL;
   \                     ??CrossCallReturnLabel_4:
   \   000027   E4           CLR     A
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   12....       LCALL   ?Subroutine28 & 0xFFFF
    766            pNewItem->numAttributes = numAttr;
   \                     ??CrossCallReturnLabel_20:
   \   00002D   E5..         MOV     A,?V1
   \   00002F   12....       LCALL   ?Subroutine28 & 0xFFFF
    767            pNewItem->attrs = newAttrList;
   \                     ??CrossCallReturnLabel_21:
   \   000032   A3           INC     DPTR
   \   000033   EE           MOV     A,R6
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   EF           MOV     A,R7
   \   000037   F0           MOVX    @DPTR,A
    768          
    769            // Find spot in list
    770            if ( attrList == NULL )
   \   000038   90....       MOV     DPTR,#attrList
   \   00003B   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   00003E   90....       MOV     DPTR,#attrList
   \   000041   6011         JZ      ??zcl_registerAttrList_1
    771            {
    772              attrList = pNewItem;
    773            }
    774            else
    775            {
    776              // Look for end of list
    777              pLoop = attrList;
   \   000043   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   000046   8003         SJMP    ??zcl_registerAttrList_2
    778              while ( pLoop->next != NULL )
    779              {
    780                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_3:
   \   000048   EA           MOV     A,R2
   \   000049   FC           MOV     R4,A
   \   00004A   EB           MOV     A,R3
    781              }
   \                     ??zcl_registerAttrList_2:
   \   00004B   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   00004E   70F8         JNZ     ??zcl_registerAttrList_3
    782          
    783              // Put new item at end of list
    784              pLoop->next = pNewItem;
   \   000050   8C82         MOV     DPL,R4
   \   000052   8D83         MOV     DPH,R5
    785            }
   \                     ??zcl_registerAttrList_1:
   \   000054   12....       LCALL   ?Subroutine36 & 0xFFFF
    786          
    787            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_39:
   \   000057   80..         SJMP    ?Subroutine1
    788          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL   ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_251:
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E5..         MOV     A,?V0
   \   00000E   12....       LCALL   ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_248:
   \   000011   22           RET
    789          
    790          /*********************************************************************
    791           * @fn          zcl_registerClusterOptionList
    792           *
    793           * @brief       Register a Cluster Option List with ZCL Foundation
    794           *
    795           * @param       endpoint - endpoint the option list belongs to
    796           * @param       numOption - number of options in list
    797           * @param       optionList - array of cluster option records.
    798           *
    799           *              NOTE: This API should be called to enable 'Application
    800           *                    Link Key' security and/or 'APS ACK' for a specific
    801           *                    Cluster. The 'Application Link Key' is discarded
    802           *                    if security isn't enabled on the device.
    803           *                    The default behavior is 'Network Key' when security
    804           *                    is enabled and no 'APS ACK' for the ZCL messages.
    805           *
    806           * @return      ZSuccess if OK
    807           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    808          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    809          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    810            zclClusterOptionList *pNewItem;
    811            zclClusterOptionList *pLoop;
    812          
    813            // Fill in the new profile list
    814            pNewItem = zcl_mem_alloc( sizeof( zclClusterOptionList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV     R2,#0x6
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    815            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerClusterOptionList_0
    816            {
    817              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8025         SJMP    ??CrossCallReturnLabel_40
    818            }
    819          
    820            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_0:
   \   000024   12....       LCALL   ?Subroutine16 & 0xFFFF
    821            pNewItem->endpoint = endpoint;
    822            pNewItem->numOptions = numOption;
   \                     ??CrossCallReturnLabel_5:
   \   000027   12....       LCALL   ?Subroutine25 & 0xFFFF
    823            pNewItem->options = optionList;
    824          
    825            // Find spot in list
    826            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_19:
   \   00002A   90....       MOV     DPTR,#clusterOptionList
   \   00002D   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   000030   90....       MOV     DPTR,#clusterOptionList
   \   000033   6011         JZ      ??zcl_registerClusterOptionList_1
    827            {
    828              clusterOptionList = pNewItem;
    829            }
    830            else
    831            {
    832              // Look for end of list
    833              pLoop = clusterOptionList;
   \   000035   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000038   8003         SJMP    ??zcl_registerClusterOptionList_2
    834              while ( pLoop->next != NULL )
    835              {
    836                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_3:
   \   00003A   EA           MOV     A,R2
   \   00003B   FC           MOV     R4,A
   \   00003C   EB           MOV     A,R3
    837              }
   \                     ??zcl_registerClusterOptionList_2:
   \   00003D   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   000040   70F8         JNZ     ??zcl_registerClusterOptionList_3
    838          
    839              // Put new item at end of list
    840              pLoop->next = pNewItem;
   \   000042   8C82         MOV     DPL,R4
   \   000044   8D83         MOV     DPH,R5
    841            }
   \                     ??zcl_registerClusterOptionList_1:
   \   000046   12....       LCALL   ?Subroutine36 & 0xFFFF
    842          
    843            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_40:
   \   000049                REQUIRE ?Subroutine1
   \   000049                ; // Fall through to label ?Subroutine1
    844          }
    845          
    846          /*********************************************************************
    847           * @fn          zcl_registerValidateAttrData
    848           *
    849           * @brief       Add a validation function for attribute data
    850           *
    851           * @param       pfnValidateAttrData - function pointer to validate routine
    852           *
    853           * @return      ZSuccess if OK
    854           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    855          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    856          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    857            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   12....       LCALL   ??Subroutine222_0 & 0xFFFF
    858          
    859            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_536:
   \   00000A   7900         MOV     R1,#0x0
   \   00000C   02....       LJMP    ?Subroutine0 & 0xFFFF
    860          }
    861          
    862          /*********************************************************************
    863           * @fn          zcl_registerReadWriteCB
    864           *
    865           * @brief       Register the application's callback function to read/write
    866           *              attribute data, and authorize read/write operation.
    867           *
    868           *              Note: The pfnReadWriteCB callback function is only required
    869           *                    when the attribute data format is unknown to ZCL. The
    870           *                    callback function gets called when the pointer 'dataPtr'
    871           *                    to the attribute value is NULL in the attribute database
    872           *                    registered with the ZCL.
    873           *
    874           *              Note: The pfnAuthorizeCB callback function is only required
    875           *                    when the Read/Write operation on an attribute requires
    876           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
    877           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
    878           *
    879           * @param       endpoint - application's endpoint
    880           * @param       pfnReadWriteCB - function pointer to read/write routine
    881           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
    882           *
    883           * @return      ZSuccess if successful. ZFailure, otherwise.
    884           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    885          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
    886                                             zclAuthorizeCB_t pfnAuthorizeCB )
    887          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
    888            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000010   8A..         MOV     ?V4,R2
   \   000012   8B..         MOV     ?V5,R3
   \   000014   A8..         MOV     R0,?V4
   \   000016   A9..         MOV     R1,?V5
    889          
    890            if ( pRec != NULL )
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   6019         JZ      ??zcl_registerReadWriteCB_0
    891            {
    892              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   12....       LCALL   ?Subroutine31 & 0xFFFF
    893              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \                     ??CrossCallReturnLabel_27:
   \   00002A   E5..         MOV     A,?V0
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   E5..         MOV     A,?V1
   \   000030   F0           MOVX    @DPTR,A
    894          
    895              return ( ZSuccess );
   \   000031   7900         MOV     R1,#0x0
   \   000033   8002         SJMP    ??zcl_registerReadWriteCB_1
    896            }
    897          
    898            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000035   7901         MOV     R1,#0x1
   \                     ??zcl_registerReadWriteCB_1:
   \   000037   02....       LJMP    ?Subroutine4 & 0xFFFF
    899          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    900          
    901          /*********************************************************************
    902           * @fn      zcl_DeviceOperational
    903           *
    904           * @brief   Used to see whether or not the device can send or respond
    905           *          to application level commands.
    906           *
    907           * @param   srcEP - source endpoint
    908           * @param   clusterID - cluster ID
    909           * @param   frameType - command type
    910           * @param   cmd - command ID
    911           *
    912           * @return  TRUE if device is operational, FALSE otherwise
    913           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    914          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
    915                                              uint8 frameType, uint8 cmd, uint16 profileID )
    916          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   EC           MOV     A,R4
   \   00000D   FF           MOV     R7,A
    917            zclAttrRec_t attrRec;
    918            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7401         MOV     A,#0x1
   \   000016   F0           MOVX    @DPTR,A
    919          
    920            (void)profileID;  // Intentionally unreferenced parameter
    921          
    922            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
    923            // cannot send or respond to application level commands, other than commands
    924            // to read or write attributes. Note that the Identify cluster cannot be
    925            // disabled, and remains functional regardless of this setting.
    926            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000017   EF           MOV     A,R7
   \   000018   7006         JNZ     ??zcl_DeviceOperational_0
   \   00001A   ED           MOV     A,R5
   \   00001B   C3           CLR     C
   \   00001C   9406         SUBB    A,#0x6
   \   00001E   4050         JC      ??zcl_DeviceOperational_1
    927            {
    928              return ( TRUE );
    929            }
    930          
    931            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   000020   7403         MOV     A,#0x3
   \   000022   6A           XRL     A,R2
   \   000023   4B           ORL     A,R3
   \   000024   604A         JZ      ??zcl_DeviceOperational_1
    932            {
    933              return ( TRUE );
    934            }
    935          
    936            // Is device enabled?
    937            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
    938                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000026                ; Setup parameters for call to function zclFindAttrRec
   \   000026   7401         MOV     A,#0x1
   \   000028   12....       LCALL   ?XSTACK_DISP100_8
   \   00002B   88..         MOV     ?V2,R0
   \   00002D   89..         MOV     ?V3,R1
   \   00002F   78..         MOV     R0,#?V2
   \   000031   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000034   7C12         MOV     R4,#0x12
   \   000036   7D00         MOV     R5,#0x0
   \   000038   7A00         MOV     R2,#0x0
   \   00003A   7B00         MOV     R3,#0x0
   \   00003C   EE           MOV     A,R6
   \   00003D   F9           MOV     R1,A
   \   00003E   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000041   7402         MOV     A,#0x2
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   \   000046   E9           MOV     A,R1
   \   000047   601C         JZ      ??zcl_DeviceOperational_2
    939            {
    940          #ifdef ZCL_READ
    941              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   000049                ; Setup parameters for call to function zclReadAttrData
   \   000049   E4           CLR     A
   \   00004A   F5..         MOV     ?V2,A
   \   00004C   F5..         MOV     ?V3,A
   \   00004E   78..         MOV     R0,#?V2
   \   000050   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000053   7403         MOV     A,#0x3
   \   000055   12....       LCALL   ?XSTACK_DISP102_8
   \   000058   7402         MOV     A,#0x2
   \   00005A   12....       LCALL   ?XSTACK_DISP101_8
   \   00005D   12....       LCALL   `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   000060   7402         MOV     A,#0x2
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
    942          #endif
    943            }
    944          
    945            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_2:
   \   000065   85..82       MOV     DPL,?XSP + 0
   \   000068   85..83       MOV     DPH,?XSP + 1
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   6401         XRL     A,#0x1
   \   00006E   7004         JNZ     ??zcl_DeviceOperational_3
   \                     ??zcl_DeviceOperational_1:
   \   000070   7901         MOV     R1,#0x1
   \   000072   8002         SJMP    ??zcl_DeviceOperational_4
   \                     ??zcl_DeviceOperational_3:
   \   000074   7900         MOV     R1,#0x0
   \                     ??zcl_DeviceOperational_4:
   \   000076   7409         MOV     A,#0x9
   \   000078   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007B   02....       LJMP    ?Subroutine1 & 0xFFFF
    946          }
    947          
    948          /*********************************************************************
    949           * @fn      zcl_SendCommand
    950           *
    951           * @brief   Used to send Profile and Cluster Specific Command messages.
    952           *
    953           *          NOTE: The calling application is responsible for incrementing
    954           *                the Sequence Number.
    955           *
    956           * @param   srcEp - source endpoint
    957           * @param   destAddr - destination address
    958           * @param   clusterID - cluster ID
    959           * @param   cmd - command ID
    960           * @param   specific - whether the command is Cluster Specific
    961           * @param   direction - client/server direction of the command
    962           * @param   disableDefaultRsp - disable Default Response command
    963           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    964           * @param   seqNumber - identification number for the transaction
    965           * @param   cmdFormatLen - length of the command to be sent
    966           * @param   cmdFormat - command to be sent
    967           *
    968           * @return  ZSuccess if OK
    969           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    970          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    971                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    972                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    973                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    974          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V10,R1
   \   00000C   8A..         MOV     ?V14,R2
   \   00000E   8B..         MOV     ?V15,R3
   \   000010   8C..         MOV     ?V0,R4
   \   000012   8D..         MOV     ?V1,R5
    975            endPointDesc_t *epDesc;
    976            zclFrameHdr_t hdr;
    977            uint8 *msgBuf;
    978            uint16 msgLen;
    979            uint8 *pBuf;
    980            uint8 options;
    981            ZStatus_t status;
    982          
    983            epDesc = afFindEndPointDesc( srcEP );
   \   000014                ; Setup parameters for call to function afFindEndPointDesc
   \   000014   12....       LCALL   `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   \   000017   8A..         MOV     ?V12,R2
   \   000019   8B..         MOV     ?V13,R3
    984            if ( epDesc == NULL )
   \   00001B   EA           MOV     A,R2
   \   00001C   45..         ORL     A,?V13
   \   00001E   7005         JNZ     ??zcl_SendCommand_0
    985            {
    986              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   000020   7902         MOV     R1,#0x2
   \   000022   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    987            }
    988          
    989          #if defined ( INTER_PAN )
    990            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
    991            {
    992              options = AF_TX_OPTIONS_NONE;
    993            }
    994            else
    995          #endif
    996            {
    997              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_0:
   \   000025                ; Setup parameters for call to function zclGetClusterOption
   \   000025   AA..         MOV     R2,?V0
   \   000027   AB..         MOV     R3,?V1
   \   000029   A9..         MOV     R1,?V10
   \   00002B   12....       LCALL   `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   00002E   E9           MOV     A,R1
   \   00002F   F5..         MOV     ?V7,A
    998          
    999              // The cluster might not have been defined to use security but if this message
   1000              // is in response to another message that was using APS security this message
   1001              // will be sent with APS security
   1002              if ( !( options & AF_EN_SECURITY ) )
   \   000031   A2E6         MOV     C,0xE0 /* A   */.6
   \   000033   401C         JC      ??zcl_SendCommand_2
   1003              {
   1004                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   000035   90....       MOV     DPTR,#rawAFMsg
   \   000038   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   1005          
   1006                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) )
   \                     ??CrossCallReturnLabel_369:
   \   00003B   6014         JZ      ??zcl_SendCommand_2
   \   00003D   E8           MOV     A,R0
   \   00003E   2419         ADD     A,#0x19
   \   000040   F582         MOV     DPL,A
   \   000042   E4           CLR     A
   \   000043   39           ADDC    A,R1
   \   000044   F583         MOV     DPH,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   6401         XRL     A,#0x1
   \   000049   7006         JNZ     ??zcl_SendCommand_2
   1007                {
   1008                  options |= AF_EN_SECURITY;
   \   00004B   E5..         MOV     A,?V7
   \   00004D   D2E6         SETB    0xE0 /* A   */.6
   \   00004F   F5..         MOV     ?V7,A
   1009                }
   1010              }
   1011            }
   1012          
   1013            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_2:
   \   000051                ; Setup parameters for call to function osal_memset
   \   000051   7C06         MOV     R4,#0x6
   \   000053   7D00         MOV     R5,#0x0
   \   000055   7900         MOV     R1,#0x0
   \   000057   AA..         MOV     R2,?XSP + 0
   \   000059   AB..         MOV     R3,?XSP + 1
   \   00005B   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   1014          
   1015            // Not Profile wide command (like READ, WRITE)
   1016            if ( specific )
   \   00005E   741F         MOV     A,#0x1f
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000066   6009         JZ      ??zcl_SendCommand_3
   1017            {
   1018              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   000068   E0           MOVX    A,@DPTR
   \   000069   54FC         ANL     A,#0xfc
   \   00006B   F0           MOVX    @DPTR,A
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   4401         ORL     A,#0x1
   \   00006F   8003         SJMP    ??zcl_SendCommand_4
   1019            }
   1020            else
   1021            {
   1022              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_3:
   \   000071   E0           MOVX    A,@DPTR
   \   000072   54FC         ANL     A,#0xfc
   1023            }
   \                     ??zcl_SendCommand_4:
   \   000074   12....       LCALL   ?Subroutine34 & 0xFFFF
   1024          
   1025            if ( ( epDesc->simpleDesc == NULL ) ||
   1026                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
   1027                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??CrossCallReturnLabel_34:
   \   000077   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_371:
   \   00007A   602B         JZ      ??zcl_SendCommand_5
   \   00007C   741E         MOV     A,#0x1e
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   E0           MOVX    A,@DPTR
   \   000082   FE           MOV     R6,A
   \   000083                ; Setup parameters for call to function zcl_DeviceOperational
   \   000083   8882         MOV     DPL,R0
   \   000085   8983         MOV     DPH,R1
   \   000087   A3           INC     DPTR
   \   000088   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00008B   EE           MOV     A,R6
   \   00008C   FD           MOV     R5,A
   \   00008D   7402         MOV     A,#0x2
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   E0           MOVX    A,@DPTR
   \   000093   5403         ANL     A,#0x3
   \   000095   FC           MOV     R4,A
   \   000096   AA..         MOV     R2,?V0
   \   000098   AB..         MOV     R3,?V1
   \   00009A   A9..         MOV     R1,?V10
   \   00009C   12....       LCALL   `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   00009F   7402         MOV     A,#0x2
   \   0000A1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A4   E9           MOV     A,R1
   \   0000A5   7005         JNZ     ??zcl_SendCommand_6
   1028            {
   1029              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_5:
   \   0000A7   7901         MOV     R1,#0x1
   \   0000A9   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
   1030            }
   \                     ??zcl_SendCommand_6:
   \   0000AC   7422         MOV     A,#0x22
   \   0000AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B1   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   1031          
   1032            // Fill in the Maufacturer Code
   1033            if ( manuCode != 0 )
   \                     ??CrossCallReturnLabel_370:
   \   0000B4   6012         JZ      ??CrossCallReturnLabel_462
   1034            {
   1035              hdr.fc.manuSpecific = 1;
   \   0000B6   85..82       MOV     DPL,?XSP + 0
   \   0000B9   85..83       MOV     DPH,?XSP + 1
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   4404         ORL     A,#0x4
   \   0000BF   F0           MOVX    @DPTR,A
   1036              hdr.manuCode = manuCode;
   \   0000C0   7402         MOV     A,#0x2
   \   0000C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C5   12....       LCALL   ??Subroutine209_0 & 0xFFFF
   1037            }
   1038          
   1039            // Set the Command Direction
   1040            if ( direction )
   \                     ??CrossCallReturnLabel_462:
   \   0000C8   7420         MOV     A,#0x20
   \   0000CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CD   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   0000D0   6005         JZ      ??zcl_SendCommand_7
   1041            {
   1042              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   4408         ORL     A,#0x8
   \   0000D5   8003         SJMP    ??zcl_SendCommand_8
   1043            }
   1044            else
   1045            {
   1046              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_7:
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   54F7         ANL     A,#0xf7
   \                     ??zcl_SendCommand_8:
   \   0000DA   F0           MOVX    @DPTR,A
   1047            }
   1048          
   1049            // Set the Disable Default Response field
   1050            if ( disableDefaultRsp )
   \   0000DB   7421         MOV     A,#0x21
   \   0000DD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E0   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   0000E3   6005         JZ      ??zcl_SendCommand_9
   1051            {
   1052              hdr.fc.disableDefaultRsp = 1;
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   4410         ORL     A,#0x10
   \   0000E8   8003         SJMP    ??zcl_SendCommand_10
   1053            }
   1054            else
   1055            {
   1056              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_9:
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   54EF         ANL     A,#0xef
   \                     ??zcl_SendCommand_10:
   \   0000ED   F0           MOVX    @DPTR,A
   1057            }
   1058          
   1059            // Fill in the Transaction Sequence Number
   1060            hdr.transSeqNum = seqNum;
   \   0000EE   7424         MOV     A,#0x24
   \   0000F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   C0E0         PUSH    A
   \   0000F6   7404         MOV     A,#0x4
   \   0000F8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FB   D0E0         POP     A
   \   0000FD   F0           MOVX    @DPTR,A
   1061          
   1062            // Fill in the command
   1063            hdr.commandID = cmd;
   \   0000FE   7405         MOV     A,#0x5
   \   000100   12....       LCALL   ?XSTACK_DISP0_8
   \   000103   EE           MOV     A,R6
   \   000104   F0           MOVX    @DPTR,A
   1064          
   1065            // calculate the needed buffer size
   1066            msgLen = zclCalcHdrSize( &hdr );
   \   000105   7803         MOV     R0,#0x3
   \   000107   85..82       MOV     DPL,?XSP + 0
   \   00010A   85..83       MOV     DPH,?XSP + 1
   \   00010D   E0           MOVX    A,@DPTR
   \   00010E   5404         ANL     A,#0x4
   \   000110   6002         JZ      ??zcl_SendCommand_11
   \   000112   7805         MOV     R0,#0x5
   \                     ??zcl_SendCommand_11:
   \   000114   7425         MOV     A,#0x25
   \   000116   12....       LCALL   ?XSTACK_DISP0_8
   \   000119   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   1067            msgLen += cmdFormatLen;
   \                     ??CrossCallReturnLabel_336:
   \   00011C   E8           MOV     A,R0
   \   00011D   25..         ADD     A,?V8
   \   00011F   FE           MOV     R6,A
   \   000120   E4           CLR     A
   \   000121   35..         ADDC    A,?V9
   \   000123   FF           MOV     R7,A
   1068          
   1069            // Allocate the buffer needed
   1070            msgBuf = zcl_mem_alloc( msgLen );
   \   000124                ; Setup parameters for call to function osal_mem_alloc
   \   000124   EE           MOV     A,R6
   \   000125   FA           MOV     R2,A
   \   000126   EF           MOV     A,R7
   \   000127   FB           MOV     R3,A
   \   000128   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00012B   8A..         MOV     ?V2,R2
   \   00012D   8B..         MOV     ?V3,R3
   1071            if ( msgBuf != NULL )
   \   00012F   EA           MOV     A,R2
   \   000130   45..         ORL     A,?V3
   \   000132   6065         JZ      ??zcl_SendCommand_12
   1072            {
   1073              // Fill in the ZCL Header
   1074              pBuf = zclBuildHdr( &hdr, msgBuf );
   \   000134                ; Setup parameters for call to function zclBuildHdr
   \   000134   AC..         MOV     R4,?V2
   \   000136   AD..         MOV     R5,?V3
   \   000138   AA..         MOV     R2,?XSP + 0
   \   00013A   AB..         MOV     R3,?XSP + 1
   \   00013C   12....       LCALL   `??zclBuildHdr::?relay`; Banked call to: zclBuildHdr
   1075          
   1076              // Fill in the command frame
   1077              zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   00013F                ; Setup parameters for call to function osal_memcpy
   \   00013F   7427         MOV     A,#0x27
   \   000141   12....       LCALL   ?XSTACK_DISP0_8
   \   000144   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000147   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00014A   AC..         MOV     R4,?V8
   \   00014C   AD..         MOV     R5,?V9
   \   00014E   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000151   7403         MOV     A,#0x3
   \   000153   12....       LCALL   ?DEALLOC_XSTACK8
   1078          
   1079              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
   1080                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   000156                ; Setup parameters for call to function AF_DataRequest
   \   000156   75..1E       MOV     ?V4,#0x1e
   \   000159   78..         MOV     R0,#?V4
   \   00015B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00015E   75....       MOV     ?V4,#zcl_TransID & 0xff
   \   000161   75....       MOV     ?V5,#(zcl_TransID >> 8) & 0xff
   \   000164   78..         MOV     R0,#?V4
   \   000166   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000169   78..         MOV     R0,#?V2
   \   00016B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016E   8E..         MOV     ?V4,R6
   \   000170   8F..         MOV     ?V5,R7
   \   000172   78..         MOV     R0,#?V4
   \   000174   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000177   78..         MOV     R0,#?V0
   \   000179   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00017C   A9..         MOV     R1,?V7
   \   00017E   AC..         MOV     R4,?V12
   \   000180   AD..         MOV     R5,?V13
   \   000182   AA..         MOV     R2,?V14
   \   000184   AB..         MOV     R3,?V15
   \   000186   12....       LCALL   `??AF_DataRequest::?relay`; Banked call to: AF_DataRequest
   \   000189   7409         MOV     A,#0x9
   \   00018B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00018E   E9           MOV     A,R1
   \   00018F   FE           MOV     R6,A
   1081              zcl_mem_free ( msgBuf );
   \   000190                ; Setup parameters for call to function osal_mem_free
   \   000190   AA..         MOV     R2,?V2
   \   000192   AB..         MOV     R3,?V3
   \   000194   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000197   8002         SJMP    ??zcl_SendCommand_13
   1082            }
   1083            else
   1084            {
   1085              status = ZMemError;
   \                     ??zcl_SendCommand_12:
   \   000199   7E10         MOV     R6,#0x10
   1086            }
   1087          
   1088            return ( status );
   \                     ??zcl_SendCommand_13:
   \   00019B   EE           MOV     A,R6
   \   00019C   F9           MOV     R1,A
   \                     ??zcl_SendCommand_1:
   \   00019D   7406         MOV     A,#0x6
   \   00019F   80..         SJMP    ??Subroutine174_0
   1089          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine174_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F10         MOV     R7,#0x10
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine171:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   12....       LCALL   ?Subroutine171 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   000003   75..00       MOV     ?V6,#0x0
   \   000006   78..         MOV     R0,#?V4
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine209_0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_254:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine139:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V12
   \   000004   85..83       MOV     DPH,?V13
   \   000007   A3           INC     DPTR
   \   000008   22           RET
   1090          
   1091          #ifdef ZCL_READ
   1092          /*********************************************************************
   1093           * @fn      zcl_SendRead
   1094           *
   1095           * @brief   Send a Read command
   1096           *
   1097           * @param   srcEP - Application's endpoint
   1098           * @param   dstAddr - destination address
   1099           * @param   clusterID - cluster ID
   1100           * @param   readCmd - read command to be sent
   1101           * @param   direction - direction of the command
   1102           * @param   seqNum - transaction sequence number
   1103           *
   1104           * @return  ZSuccess if OK
   1105           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1106          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
   1107                                  uint16 clusterID, zclReadCmd_t *readCmd,
   1108                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
   1109          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine80 & 0xFFFF
   1110            uint16 dataLen;
   1111            uint8 *buf;
   1112            uint8 *pBuf;
   1113            ZStatus_t status;
   1114          
   1115            dataLen = readCmd->numAttr * 2; // Attribute ID
   \                     ??CrossCallReturnLabel_135:
   \   000017   25E0         ADD     A,0xE0 /* A   */
   \   000019   FE           MOV     R6,A
   \   00001A   E4           CLR     A
   \   00001B   33           RLC     A
   \   00001C   FF           MOV     R7,A
   1116          
   1117            buf = zcl_mem_alloc( dataLen );
   \   00001D                ; Setup parameters for call to function osal_mem_alloc
   \   00001D   EE           MOV     A,R6
   \   00001E   FA           MOV     R2,A
   \   00001F   EF           MOV     A,R7
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000024   8A..         MOV     ?V0,R2
   \   000026   8B..         MOV     ?V1,R3
   1118            if ( buf != NULL )
   \   000028   EA           MOV     A,R2
   \   000029   45..         ORL     A,?V1
   \   00002B   7003         JNZ     $+5
   \   00002D   02....       LJMP    ??zcl_SendRead_0 & 0xFFFF
   1119            {
   1120              uint8 i;
   1121          
   1122              // Load the buffer - serially
   1123              pBuf = buf;
   1124              for (i = 0; i < readCmd->numAttr; i++)
   \   000030   7C00         MOV     R4,#0x0
   \   000032   8019         SJMP    ??zcl_SendRead_1
   1125              {
   1126                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_2:
   \   000034   EC           MOV     A,R4
   \   000035   25E0         ADD     A,0xE0 /* A   */
   \   000037   F8           MOV     R0,A
   \   000038   E4           CLR     A
   \   000039   33           RLC     A
   \   00003A   F9           MOV     R1,A
   \   00003B   12....       LCALL   ?Subroutine163 & 0xFFFF
   1127                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   1128              }
   \                     ??CrossCallReturnLabel_300:
   \   00003E   12....       LCALL   ??Subroutine199_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_408:
   \   000041   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000044   F0           MOVX    @DPTR,A
   \   000045   EA           MOV     A,R2
   \   000046   2402         ADD     A,#0x2
   \   000048   FA           MOV     R2,A
   \   000049   5001         JNC     ??zcl_SendRead_3
   \   00004B   0B           INC     R3
   \                     ??zcl_SendRead_3:
   \   00004C   0C           INC     R4
   \                     ??zcl_SendRead_1:
   \   00004D   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_315:
   \   000050   40E2         JC      ??zcl_SendRead_2
   1129          
   1130              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
   1131                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000052                ; Setup parameters for call to function zcl_SendCommand
   \   000052   78..         MOV     R0,#?V0
   \   000054   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000057   8E..         MOV     ?V4,R6
   \   000059   8F..         MOV     ?V5,R7
   \   00005B   78..         MOV     R0,#?V4
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000060   741C         MOV     A,#0x1c
   \   000062   12....       LCALL   ?XSTACK_DISP0_8
   \   000065   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000068   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006B   E4           CLR     A
   \   00006C   F5..         MOV     ?V4,A
   \   00006E   F5..         MOV     ?V5,A
   \   000070   78..         MOV     R0,#?V4
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000075   741E         MOV     A,#0x1e
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   00007D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000080   741E         MOV     A,#0x1e
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000088   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008B   75..00       MOV     ?V3,#0x0
   \   00008E   78..         MOV     R0,#?V3
   \   000090   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000093   78..         MOV     R0,#?V3
   \   000095   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000098   AC..         MOV     R4,?V6
   \   00009A   AD..         MOV     R5,?V7
   \   00009C   AA..         MOV     R2,?V8
   \   00009E   AB..         MOV     R3,?V9
   \   0000A0   A9..         MOV     R1,?V2
   \   0000A2   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000A5   740B         MOV     A,#0xb
   \   0000A7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AA   E9           MOV     A,R1
   \   0000AB   FE           MOV     R6,A
   1132              zcl_mem_free( buf );
   \   0000AC                ; Setup parameters for call to function osal_mem_free
   \   0000AC   AA..         MOV     R2,?V0
   \   0000AE   AB..         MOV     R3,?V1
   \   0000B0   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000B3   8002         SJMP    ??zcl_SendRead_4
   1133            }
   1134            else
   1135            {
   1136              status = ZMemError;
   \                     ??zcl_SendRead_0:
   \   0000B5   7E10         MOV     R6,#0x10
   1137            }
   1138          
   1139            return ( status );
   \                     ??zcl_SendRead_4:
   \   0000B7   02....       LJMP    ?Subroutine10 & 0xFFFF
   1140          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine163:
   \   000000   E5..         MOV     A,?V4
   \   000002   28           ADD     A,R0
   \   000003   F582         MOV     DPL,A
   \   000005   E5..         MOV     A,?V5
   \   000007                REQUIRE ??Subroutine175_0
   \   000007                ; // Fall through to label ??Subroutine175_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine175_0:
   \   000000   39           ADDC    A,R1
   \   000001   F583         MOV     DPH,A
   \   000003   A3           INC     DPTR
   \   000004   A882         MOV     R0,DPL
   \   000006   A983         MOV     R1,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine178_0
   \   000006                ; // Fall through to label ??Subroutine178_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine178_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   EC           MOV     A,R4
   \   000003   C3           CLR     C
   \   000004   98           SUBB    A,R0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine179_0:
   \   000000   7F0C         MOV     R7,#0xc
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ??Subroutine179_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   12....       LCALL   ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_261:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine145:
   \   000000   12....       LCALL   ?Subroutine171 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   000003   85..82       MOV     DPL,?V4
   \   000006   F583         MOV     DPH,A
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V3,A
   \   000003   78..         MOV     R0,#?V3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine133:
   \   000000   12....       LCALL   ?Subroutine173 & 0xFFFF
   \                     ??CrossCallReturnLabel_297:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine199_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   22           RET
   1141          
   1142          /*********************************************************************
   1143           * @fn      zcl_SendReadRsp
   1144           *
   1145           * @brief   Send a Read Response command.
   1146           *
   1147           * @param   srcEP - Application's endpoint
   1148           * @param   dstAddr - destination address
   1149           * @param   clusterID - cluster ID
   1150           * @param   readRspCmd - read response command to be sent
   1151           * @param   direction - direction of the command
   1152           * @param   seqNum - transaction sequence number
   1153           *
   1154           * @return  ZSuccess if OK
   1155           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1156          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
   1157                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
   1158                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1159          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V3,R1
   \   00000C   8A..         MOV     ?V12,R2
   \   00000E   8B..         MOV     ?V13,R3
   \   000010   8C..         MOV     ?V6,R4
   \   000012   8D..         MOV     ?V7,R5
   1160            uint8 *buf;
   1161            uint16 len = 0;
   \   000014   7E00         MOV     R6,#0x0
   \   000016   7F00         MOV     R7,#0x0
   1162            ZStatus_t status;
   1163            uint8 i;
   1164          
   1165            // calculate the size of the command
   1166            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000018   75..00       MOV     ?V2,#0x0
   \   00001B   7418         MOV     A,#0x18
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_337:
   \   000023   8011         SJMP    ??zcl_SendReadRsp_0
   1167            {
   1168              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1169          
   1170              len += 2 + 1; // Attribute ID + Status
   1171          
   1172              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1173              {
   1174                len++; // Attribute Data Type length
   1175          
   1176                // Attribute Data length
   1177                if ( statusRec->data != NULL )
   1178                {
   1179                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   1180                }
   1181                else
   1182                {
   1183                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   \                     ??zcl_SendReadRsp_1:
   \   000025                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000025   12....       LCALL   ?Subroutine87 & 0xFFFF
   1184                }
   \                     ??CrossCallReturnLabel_149:
   \   000028   12....       LCALL   `??zclGetAttrDataLengthUsingCB::?relay`; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zcl_SendReadRsp_2:
   \   00002B   8B..         MOV     ?V1,R3
   \   00002D   EE           MOV     A,R6
   \   00002E   2A           ADD     A,R2
   \   00002F   FE           MOV     R6,A
   \   000030   EF           MOV     A,R7
   \   000031   35..         ADDC    A,?V1
   \   000033   FF           MOV     R7,A
   \                     ??zcl_SendReadRsp_3:
   \   000034   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_0:
   \   000036   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_447:
   \   000039   5033         JNC     ??zcl_SendReadRsp_4
   \   00003B   E5..         MOV     A,?V2
   \   00003D   75F006       MOV     B,#0x6
   \   000040   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000043   2403         ADD     A,#0x3
   \   000045   FE           MOV     R6,A
   \   000046   E4           CLR     A
   \   000047   3F           ADDC    A,R7
   \   000048   FF           MOV     R7,A
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   70E6         JNZ     ??zcl_SendReadRsp_3
   \   00004E   0E           INC     R6
   \   00004F   EE           MOV     A,R6
   \   000050   7001         JNZ     ??zcl_SendReadRsp_5
   \   000052   0F           INC     R7
   \                     ??zcl_SendReadRsp_5:
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   00005E   8882         MOV     DPL,R0
   \   000060   8983         MOV     DPH,R1
   \   000062   60C1         JZ      ??zcl_SendReadRsp_1
   \   000064                ; Setup parameters for call to function zclGetAttrDataLength
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   F9           MOV     R1,A
   \   000069   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   00006C   80BD         SJMP    ??zcl_SendReadRsp_2
   1185              }
   1186            }
   1187          
   1188            buf = zcl_mem_alloc( len );
   \                     ??zcl_SendReadRsp_4:
   \   00006E                ; Setup parameters for call to function osal_mem_alloc
   \   00006E   EE           MOV     A,R6
   \   00006F   FA           MOV     R2,A
   \   000070   EF           MOV     A,R7
   \   000071   FB           MOV     R3,A
   \   000072   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000075   8A..         MOV     ?V0,R2
   \   000077   8B..         MOV     ?V1,R3
   \   000079   8A..         MOV     ?V4,R2
   \   00007B   8B..         MOV     ?V5,R3
   1189            if ( buf != NULL )
   \   00007D   EA           MOV     A,R2
   \   00007E   45..         ORL     A,?V5
   \   000080   7003         JNZ     $+5
   \   000082   02....       LJMP    ??zcl_SendReadRsp_6 & 0xFFFF
   1190            {
   1191              // Load the buffer - serially
   1192              uint8 *pBuf = buf;
   1193          
   1194              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000085   75..00       MOV     ?V2,#0x0
   \   000088   8030         SJMP    ??zcl_SendReadRsp_7
   1195              {
   1196                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1197          
   1198                *pBuf++ = LO_UINT16( statusRec->attrID );
   1199                *pBuf++ = HI_UINT16( statusRec->attrID );
   1200                *pBuf++ = statusRec->status;
   1201          
   1202                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1203                {
   1204                  *pBuf++ = statusRec->dataType;
   1205          
   1206                  if ( statusRec->data != NULL )
   1207                  {
   1208                    // Copy attribute data to the buffer to be sent out
   1209                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   1210                  }
   1211                  else
   1212                  {
   1213                    uint16 dataLen;
   1214          
   1215                    // Read attribute data directly into the buffer to be sent out
   1216                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   \                     ??zcl_SendReadRsp_8:
   \   00008A                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   00008A   A8..         MOV     R0,?XSP + 0
   \   00008C   A9..         MOV     R1,?XSP + 1
   \   00008E   88..         MOV     ?V10,R0
   \   000090   89..         MOV     ?V11,R1
   \   000092   78..         MOV     R0,#?V10
   \   000094   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000097   78..         MOV     R0,#?V0
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   8A82         MOV     DPL,R2
   \   00009E   8B83         MOV     DPH,R3
   \   0000A0   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   0000A3   12....       LCALL   `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   0000A6   7404         MOV     A,#0x4
   \   0000A8   12....       LCALL   ?DEALLOC_XSTACK8
   1217                    pBuf += dataLen;
   \   0000AB   12....       LCALL   ?Subroutine101 & 0xFFFF
   1218                  }
   \                     ??CrossCallReturnLabel_504:
   \   0000AE   E5..         MOV     A,?V0
   \   0000B0   28           ADD     A,R0
   \   0000B1   F5..         MOV     ?V0,A
   \   0000B3   E5..         MOV     A,?V1
   \   0000B5   39           ADDC    A,R1
   \   0000B6   F5..         MOV     ?V1,A
   \                     ??zcl_SendReadRsp_9:
   \   0000B8   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_7:
   \   0000BA   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_448:
   \   0000BD   5073         JNC     ??zcl_SendReadRsp_10
   \   0000BF   E5..         MOV     A,?V2
   \   0000C1   75F006       MOV     B,#0x6
   \   0000C4   A4           MUL     AB
   \   0000C5   F8           MOV     R0,A
   \   0000C6   A9F0         MOV     R1,B
   \   0000C8   E5..         MOV     A,?V8
   \   0000CA   28           ADD     A,R0
   \   0000CB   F582         MOV     DPL,A
   \   0000CD   E5..         MOV     A,?V9
   \   0000CF   12....       LCALL   ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   0000D2   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   0000D5   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   0000D8   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   0000DB   A3           INC     DPTR
   \   0000DC   F0           MOVX    @DPTR,A
   \   0000DD   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_359:
   \   0000E0   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_180:
   \   0000E3   F0           MOVX    @DPTR,A
   \   0000E4   E5..         MOV     A,?V0
   \   0000E6   2403         ADD     A,#0x3
   \   0000E8   F5..         MOV     ?V0,A
   \   0000EA   5002         JNC     ??zcl_SendReadRsp_11
   \   0000EC   05..         INC     ?V1
   \                     ??zcl_SendReadRsp_11:
   \   0000EE   8882         MOV     DPL,R0
   \   0000F0   8983         MOV     DPH,R1
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   70C3         JNZ     ??zcl_SendReadRsp_9
   \   0000F5   EA           MOV     A,R2
   \   0000F6   2403         ADD     A,#0x3
   \   0000F8   08           INC     R0
   \   0000F9   12....       LCALL   ??Subroutine190_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_358:
   \   0000FC   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   0000FF   F0           MOVX    @DPTR,A
   \   000100   A3           INC     DPTR
   \   000101   8582..       MOV     ?V0,DPL
   \   000104   8583..       MOV     ?V1,DPH
   \   000107   8A82         MOV     DPL,R2
   \   000109   8B83         MOV     DPH,R3
   \   00010B   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_490:
   \   00010E   8C82         MOV     DPL,R4
   \   000110   8D83         MOV     DPH,R5
   \   000112   E582         MOV     A,DPL
   \   000114   4583         ORL     A,DPH
   \   000116   7003         JNZ     $+5
   \   000118   02....       LJMP    ??zcl_SendReadRsp_8 & 0xFFFF
   \   00011B                ; Setup parameters for call to function zclSerializeData
   \   00011B   AC..         MOV     R4,?V0
   \   00011D   AD..         MOV     R5,?V1
   \   00011F   AA82         MOV     R2,DPL
   \   000121   AB83         MOV     R3,DPH
   \   000123   8882         MOV     DPL,R0
   \   000125   8983         MOV     DPH,R1
   \   000127   E0           MOVX    A,@DPTR
   \   000128   F9           MOV     R1,A
   \   000129   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   00012C   8A..         MOV     ?V0,R2
   \   00012E   8B..         MOV     ?V1,R3
   \   000130   8086         SJMP    ??zcl_SendReadRsp_9
   1219                }
   1220              } // for loop
   1221          
   1222              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
   1223                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zcl_SendReadRsp_10:
   \   000132                ; Setup parameters for call to function zcl_SendCommand
   \   000132   78..         MOV     R0,#?V4
   \   000134   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000137   8E..         MOV     ?V0,R6
   \   000139   8F..         MOV     ?V1,R7
   \   00013B   78..         MOV     R0,#?V0
   \   00013D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000140   7420         MOV     A,#0x20
   \   000142   12....       LCALL   ?XSTACK_DISP0_8
   \   000145   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000148   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00014B   E4           CLR     A
   \   00014C   F5..         MOV     ?V0,A
   \   00014E   F5..         MOV     ?V1,A
   \   000150   78..         MOV     R0,#?V0
   \   000152   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000155   7422         MOV     A,#0x22
   \   000157   12....       LCALL   ?XSTACK_DISP0_8
   \   00015A   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00015D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000160   7422         MOV     A,#0x22
   \   000162   12....       LCALL   ?XSTACK_DISP0_8
   \   000165   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000168   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00016B   75..00       MOV     ?V0,#0x0
   \   00016E   78..         MOV     R0,#?V0
   \   000170   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000173   75..01       MOV     ?V0,#0x1
   \   000176   78..         MOV     R0,#?V0
   \   000178   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00017B   AC..         MOV     R4,?V6
   \   00017D   AD..         MOV     R5,?V7
   \   00017F   AA..         MOV     R2,?V12
   \   000181   AB..         MOV     R3,?V13
   \   000183   A9..         MOV     R1,?V3
   \   000185   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000188   740B         MOV     A,#0xb
   \   00018A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00018D   E9           MOV     A,R1
   \   00018E   FE           MOV     R6,A
   1224              zcl_mem_free( buf );
   \   00018F                ; Setup parameters for call to function osal_mem_free
   \   00018F   AA..         MOV     R2,?V4
   \   000191   AB..         MOV     R3,?V5
   \   000193   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000196   8002         SJMP    ??zcl_SendReadRsp_12
   1225            }
   1226            else
   1227            {
   1228              status = ZMemError;
   \                     ??zcl_SendReadRsp_6:
   \   000198   7E10         MOV     R6,#0x10
   1229            }
   1230          
   1231            return ( status );
   \                     ??zcl_SendReadRsp_12:
   \   00019A   EE           MOV     A,R6
   \   00019B   F9           MOV     R1,A
   \   00019C   7402         MOV     A,#0x2
   \   00019E                REQUIRE ?Subroutine11
   \   00019E                ; // Fall through to label ?Subroutine11
   1232          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   80..         SJMP    ??Subroutine177_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0
   \   000004   85..83       MOV     DPH,?V1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   12....       LCALL   ??Subroutine221_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_532:
   \   000003   AA..         MOV     R2,?V6
   \   000005   AB..         MOV     R3,?V7
   \   000007   A9..         MOV     R1,?V3
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine177_0:
   \   000000   7F0E         MOV     R7,#0xe
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine122:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V8
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V9
   \   00000B   12....       LCALL   ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   00000E   EE           MOV     A,R6
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   78..         MOV     R0,#?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine183_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V8,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V9,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0
   \   000004   85..83       MOV     DPH,?V1
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine117:
   \   000000   EA           MOV     A,R2
   \   000001   2402         ADD     A,#0x2
   \   000003   F8           MOV     R0,A
   \   000004                REQUIRE ??Subroutine190_0
   \   000004                ; // Fall through to label ??Subroutine190_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine190_0:
   \   000000   E4           CLR     A
   \   000001   3B           ADDC    A,R3
   \   000002   F9           MOV     R1,A
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006                REQUIRE ??Subroutine206_0
   \   000006                ; // Fall through to label ??Subroutine206_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine206_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V2
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine123:
   \   000000   12....       LCALL   ??Subroutine210_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_474:
   \   000003   AA82         MOV     R2,DPL
   \   000005   AB83         MOV     R3,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine210_0:
   \   000000   39           ADDC    A,R1
   \   000001   F583         MOV     DPH,A
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine216_0
   \   000006                ; // Fall through to label ??Subroutine216_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine216_0:
   \   000000   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_509:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine158:
   \   000000   12....       LCALL   ?Subroutine172 & 0xFFFF
   \                     ??CrossCallReturnLabel_516:
   \   000003   F9           MOV     R1,A
   \   000004   22           RET
   1233          #endif // ZCL_READ
   1234          
   1235          #ifdef ZCL_WRITE
   1236          /*********************************************************************
   1237           * @fn      sendWriteRequest
   1238           *
   1239           * @brief   Send a Write command
   1240           *
   1241           * @param   dstAddr - destination address
   1242           * @param   clusterID - cluster ID
   1243           * @param   writeCmd - write command to be sent
   1244           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
   1245           * @param   direction - direction of the command
   1246           * @param   seqNum - transaction sequence number
   1247           *
   1248           * @return  ZSuccess if OK
   1249           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1250          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
   1251                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
   1252                                          uint8 disableDefaultRsp, uint8 seqNum )
   1253          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   1254            uint8 *buf;
   1255            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1256            ZStatus_t status;
   1257            uint8 i;
   1258          
   1259            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000013   75..00       MOV     ?V2,#0x0
   \   000016   7416         MOV     A,#0x16
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   00001E   8009         SJMP    ??CrossCallReturnLabel_228
   1260            {
   1261              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_0:
   \   000020   12....       LCALL   ?Subroutine77 & 0xFFFF
   1262          
   1263              dataLen += 2 + 1; // Attribute ID + Attribute Type
   1264          
   1265              // Attribute Data
   1266              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   1267            }
   \                     ??CrossCallReturnLabel_129:
   \   000023   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000026   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000029   85..82       MOV     DPL,?V4
   \   00002C   85..83       MOV     DPH,?V5
   \   00002F   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_442:
   \   000032   40EC         JC      ??zcl_SendWriteRequest_0
   1268          
   1269            buf = zcl_mem_alloc( dataLen );
   \   000034                ; Setup parameters for call to function osal_mem_alloc
   \   000034   EE           MOV     A,R6
   \   000035   FA           MOV     R2,A
   \   000036   EF           MOV     A,R7
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003B   8A..         MOV     ?V0,R2
   \   00003D   8B..         MOV     ?V1,R3
   1270            if ( buf != NULL )
   \   00003F   EA           MOV     A,R2
   \   000040   45..         ORL     A,?V1
   \   000042   7003         JNZ     $+5
   \   000044   02....       LJMP    ??zcl_SendWriteRequest_1 & 0xFFFF
   1271            {
   1272              // Load the buffer - serially
   1273              uint8 *pBuf = buf;
   \   000047   A8..         MOV     R0,?V0
   \   000049   A9..         MOV     R1,?V1
   1274              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   00004B   75..00       MOV     ?V2,#0x0
   \   00004E   8010         SJMP    ??zcl_SendWriteRequest_2
   1275              {
   1276                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_3:
   \   000050   12....       LCALL   ?Subroutine13 & 0xFFFF
   1277          
   1278                *pBuf++ = LO_UINT16( statusRec->attrID );
   1279                *pBuf++ = HI_UINT16( statusRec->attrID );
   1280                *pBuf++ = statusRec->dataType;
   1281          
   1282                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   1283              }
   \                     ??CrossCallReturnLabel_0:
   \   000053   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   000056   8A..         MOV     ?V10,R2
   \   000058   8B..         MOV     ?V11,R3
   \   00005A   A8..         MOV     R0,?V10
   \   00005C   A9..         MOV     R1,?V11
   \   00005E   05..         INC     ?V2
   \                     ??zcl_SendWriteRequest_2:
   \   000060   85..82       MOV     DPL,?V4
   \   000063   85..83       MOV     DPH,?V5
   \   000066   E0           MOVX    A,@DPTR
   \   000067   FA           MOV     R2,A
   \   000068   E5..         MOV     A,?V2
   \   00006A   C3           CLR     C
   \   00006B   9A           SUBB    A,R2
   \   00006C   40E2         JC      ??zcl_SendWriteRequest_3
   1284          
   1285              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
   1286                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00006E                ; Setup parameters for call to function zcl_SendCommand
   \   00006E   78..         MOV     R0,#?V0
   \   000070   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000073   8E..         MOV     ?V4,R6
   \   000075   8F..         MOV     ?V5,R7
   \   000077   78..         MOV     R0,#?V4
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007C   741F         MOV     A,#0x1f
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000087   E4           CLR     A
   \   000088   F5..         MOV     ?V4,A
   \   00008A   F5..         MOV     ?V5,A
   \   00008C   78..         MOV     R0,#?V4
   \   00008E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000091   7421         MOV     A,#0x21
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009C   7421         MOV     A,#0x21
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A7   75..00       MOV     ?V2,#0x0
   \   0000AA   78..         MOV     R0,#?V2
   \   0000AC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AF   7422         MOV     A,#0x22
   \   0000B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B4   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   0000B7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BA   AC..         MOV     R4,?V6
   \   0000BC   AD..         MOV     R5,?V7
   \   0000BE   AA..         MOV     R2,?V8
   \   0000C0   AB..         MOV     R3,?V9
   \   0000C2   A9..         MOV     R1,?V3
   \   0000C4   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000C7   740B         MOV     A,#0xb
   \   0000C9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CC   E9           MOV     A,R1
   \   0000CD   FE           MOV     R6,A
   1287              zcl_mem_free( buf );
   \   0000CE                ; Setup parameters for call to function osal_mem_free
   \   0000CE   AA..         MOV     R2,?V0
   \   0000D0   AB..         MOV     R3,?V1
   \   0000D2   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000D5   8002         SJMP    ??zcl_SendWriteRequest_4
   1288            }
   1289            else
   1290            {
   1291              status = ZMemError;
   \                     ??zcl_SendWriteRequest_1:
   \   0000D7   7E10         MOV     R6,#0x10
   1292            }
   1293          
   1294            return ( status);
   \                     ??zcl_SendWriteRequest_4:
   \   0000D9                REQUIRE ?Subroutine12
   \   0000D9                ; // Fall through to label ?Subroutine12
   1295          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ??Subroutine177_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine126:
   \   000000   8B..         MOV     ?V1,R3
   \   000002   EA           MOV     A,R2
   \   000003   2403         ADD     A,#0x3
   \   000005   F8           MOV     R0,A
   \   000006   E4           CLR     A
   \   000007   35..         ADDC    A,?V1
   \   000009   F9           MOV     R1,A
   \   00000A   EE           MOV     A,R6
   \   00000B   28           ADD     A,R0
   \   00000C   FE           MOV     R6,A
   \   00000D   EF           MOV     A,R7
   \   00000E   39           ADDC    A,R1
   \   00000F   FF           MOV     R7,A
   \   000010   05..         INC     ?V2
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   E5..         MOV     A,?V2
   \   000002   75F005       MOV     B,#0x5
   \   000005   A4           MUL     AB
   \   000006   F8           MOV     R0,A
   \   000007   A9F0         MOV     R1,B
   \   000009   12....       LCALL   ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   00000C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   12....       LCALL   ?Subroutine154 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V2,A
   \   000003   78..         MOV     R0,#?V2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E5..         MOV     A,?V2
   \   000002   75F005       MOV     B,#0x5
   \   000005   A4           MUL     AB
   \   000006   FA           MOV     R2,A
   \   000007   ABF0         MOV     R3,B
   \   000009   E5..         MOV     A,?V4
   \   00000B   2A           ADD     A,R2
   \   00000C   F582         MOV     DPL,A
   \   00000E   E5..         MOV     A,?V5
   \   000010   3B           ADDC    A,R3
   \   000011   F583         MOV     DPH,A
   \   000013   A3           INC     DPTR
   \   000014   8582..       MOV     ?V12,DPL
   \   000017   8583..       MOV     ?V13,DPH
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   8882         MOV     DPL,R0
   \   00001D   8983         MOV     DPH,R1
   \   00001F   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000022   12....       LCALL   ?Subroutine159 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   000025   F0           MOVX    @DPTR,A
   \   000026   E5..         MOV     A,?V12
   \   000028   2402         ADD     A,#0x2
   \   00002A   FA           MOV     R2,A
   \   00002B   E4           CLR     A
   \   00002C   35..         ADDC    A,?V13
   \   00002E   FB           MOV     R3,A
   \   00002F   8A..         MOV     ?V10,R2
   \   000031   8B..         MOV     ?V11,R3
   \   000033   8A82         MOV     DPL,R2
   \   000035   F583         MOV     DPH,A
   \   000037   12....       LCALL   ?Subroutine159 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   00003A   A3           INC     DPTR
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C                ; Setup parameters for call to function zclSerializeData
   \   00003C                ; Setup parameters for call to function zclSerializeData
   \   00003C   E8           MOV     A,R0
   \   00003D   2403         ADD     A,#0x3
   \   00003F   FC           MOV     R4,A
   \   000040   E4           CLR     A
   \   000041   39           ADDC    A,R1
   \   000042   FD           MOV     R5,A
   \   000043   85..82       MOV     DPL,?V12
   \   000046   85..83       MOV     DPH,?V13
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   12....       LCALL   ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   00004F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine144:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   85..82       MOV     DPL,?V10
   \   000008   85..83       MOV     DPH,?V11
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   12....       LCALL   ?Subroutine171 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine159:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   22           RET
   1296          
   1297          /*********************************************************************
   1298           * @fn      zcl_SendWriteRsp
   1299           *
   1300           * @brief   Send a Write Response command
   1301           *
   1302           * @param   dstAddr - destination address
   1303           * @param   clusterID - cluster ID
   1304           * @param   wrtieRspCmd - write response command to be sent
   1305           * @param   direction - direction of the command
   1306           * @param   seqNum - transaction sequence number
   1307           *
   1308           * @return  ZSuccess if OK
   1309           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1310          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
   1311                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
   1312                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1313          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine53 & 0xFFFF
   1314            uint16 dataLen;
   1315            uint8 *buf;
   1316            ZStatus_t status;
   1317          
   1318            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   1319          
   1320            buf = zcl_mem_alloc( dataLen );
   \                     ??CrossCallReturnLabel_76:
   \   000017   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00001A   8A..         MOV     ?V0,R2
   \   00001C   8B..         MOV     ?V1,R3
   1321            if ( buf != NULL )
   \   00001E   EA           MOV     A,R2
   \   00001F   45..         ORL     A,?V1
   \   000021   7003         JNZ     $+5
   \   000023   02....       LJMP    ??zcl_SendWriteRsp_0 & 0xFFFF
   1322            {
   1323              // Load the buffer - serially
   1324              uint8 i;
   1325              uint8 *pBuf = buf;
   1326              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   000026   7C00         MOV     R4,#0x0
   \   000028   800D         SJMP    ??zcl_SendWriteRsp_1
   1327              {
   1328                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_2:
   \   00002A   12....       LCALL   ?Subroutine94 & 0xFFFF
   1329                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   1330                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   1331              }
   \                     ??CrossCallReturnLabel_161:
   \   00002D   5001         JNC     ??zcl_SendWriteRsp_3
   \   00002F   09           INC     R1
   \                     ??zcl_SendWriteRsp_3:
   \   000030   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000033   5001         JNC     ??zcl_SendWriteRsp_4
   \   000035   0B           INC     R3
   \                     ??zcl_SendWriteRsp_4:
   \   000036   0C           INC     R4
   \                     ??zcl_SendWriteRsp_1:
   \   000037   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   00003A   40EE         JC      ??zcl_SendWriteRsp_2
   1332          
   1333              // If there's only a single status record and its status field is set to
   1334              // SUCCESS then omit the attribute ID field.
   1335              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   00003C   7401         MOV     A,#0x1
   \   00003E   68           XRL     A,R0
   \   00003F   700A         JNZ     ??zcl_SendWriteRsp_5
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   7006         JNZ     ??zcl_SendWriteRsp_5
   1336              {
   1337                dataLen = 1;
   \   000045   75..01       MOV     ?V6,#0x1
   \   000048   75..00       MOV     ?V7,#0x0
   1338              }
   1339          
   1340              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1341                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_5:
   \   00004B                ; Setup parameters for call to function zcl_SendCommand
   \   00004B   78..         MOV     R0,#?V0
   \   00004D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000050   78..         MOV     R0,#?V6
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000055   741C         MOV     A,#0x1c
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000060   E4           CLR     A
   \   000061   F5..         MOV     ?V4,A
   \   000063   F5..         MOV     ?V5,A
   \   000065   78..         MOV     R0,#?V4
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006A   741E         MOV     A,#0x1e
   \   00006C   12....       LCALL   ?XSTACK_DISP0_8
   \   00006F   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000075   741E         MOV     A,#0x1e
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   00007D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000080   75..00       MOV     ?V3,#0x0
   \   000083   78..         MOV     R0,#?V3
   \   000085   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000088   75..04       MOV     ?V3,#0x4
   \   00008B   78..         MOV     R0,#?V3
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000090   EE           MOV     A,R6
   \   000091   FC           MOV     R4,A
   \   000092   EF           MOV     A,R7
   \   000093   FD           MOV     R5,A
   \   000094   AA..         MOV     R2,?V8
   \   000096   AB..         MOV     R3,?V9
   \   000098   A9..         MOV     R1,?V2
   \   00009A   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00009D   740B         MOV     A,#0xb
   \   00009F   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A2   E9           MOV     A,R1
   \   0000A3   FE           MOV     R6,A
   1342              zcl_mem_free( buf );
   \   0000A4                ; Setup parameters for call to function osal_mem_free
   \   0000A4   AA..         MOV     R2,?V0
   \   0000A6   AB..         MOV     R3,?V1
   \   0000A8   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000AB   8002         SJMP    ??zcl_SendWriteRsp_6
   1343            }
   1344            else
   1345            {
   1346              status = ZMemError;
   \                     ??zcl_SendWriteRsp_0:
   \   0000AD   7E10         MOV     R6,#0x10
   1347            }
   1348          
   1349            return ( status );
   \                     ??zcl_SendWriteRsp_6:
   \   0000AF   02....       LJMP    ?Subroutine10 & 0xFFFF
   1350          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   EC           MOV     A,R4
   \   000001   75F003       MOV     B,#0x3
   \   000004   A4           MUL     AB
   \   000005   F8           MOV     R0,A
   \   000006   A9F0         MOV     R1,B
   \   000008   E5..         MOV     A,?V4
   \   00000A   28           ADD     A,R0
   \   00000B   F8           MOV     R0,A
   \   00000C   E5..         MOV     A,?V5
   \   00000E   39           ADDC    A,R1
   \   00000F   12....       LCALL   ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_415:
   \   000012   F0           MOVX    @DPTR,A
   \   000013   E8           MOV     A,R0
   \   000014   2402         ADD     A,#0x2
   \   000016   F8           MOV     R0,A
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   12....       LCALL   ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_262:
   \   000003   75F003       MOV     B,#0x3
   \   000006   A4           MUL     AB
   \   000007   F5..         MOV     ?V6,A
   \   000009   E5F0         MOV     A,B
   \   00000B   F5..         MOV     ?V7,A
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   AA..         MOV     R2,?V6
   \   00000F   FB           MOV     R3,A
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   12....       LCALL   ??Subroutine199_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_411:
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   EA           MOV     A,R2
   \   00000E   2403         ADD     A,#0x3
   \   000010   FA           MOV     R2,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine141:
   \   000000   F9           MOV     R1,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine199_0
   \   000006                ; // Fall through to label ??Subroutine199_0
   1351          #endif // ZCL_WRITE
   1352          
   1353          #ifdef ZCL_REPORT
   1354          /*********************************************************************
   1355           * @fn      zcl_SendConfigReportCmd
   1356           *
   1357           * @brief   Send a Configure Reporting command
   1358           *
   1359           * @param   dstAddr - destination address
   1360           * @param   clusterID - cluster ID
   1361           * @param   cfgReportCmd - configure reporting command to be sent
   1362           * @param   direction - direction of the command
   1363           * @param   seqNum - transaction sequence number
   1364           *
   1365           * @return  ZSuccess if OK
   1366           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   7402         MOV     A,#0x2
   \   000004                REQUIRE ??Subroutine174_0
   \   000004                ; // Fall through to label ??Subroutine174_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1367          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportCmd:
   1368                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1369                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1370          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine17 & 0xFFFF
   1371            uint8 *buf;
   1372            uint16 dataLen = 0;
   1373            ZStatus_t status;
   1374            uint8 i;
   1375          
   1376            // Find out the data length
   1377            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_6:
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_338:
   \   000013   8009         SJMP    ??zcl_SendConfigReportCmd_0
   1378            {
   1379              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1380          
   1381              dataLen += 1 + 2; // Direction + Attribute ID
   1382          
   1383              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1384              {
   1385                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1386          
   1387                // Find out the size of the Reportable Change field (for Analog data types)
   1388                if ( zclAnalogDataType( reportRec->dataType ) )
   1389                {
   1390                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1391                }
   1392              }
   1393              else
   1394              {
   1395                dataLen += 2; // Timeout Period
   \                     ??zcl_SendConfigReportCmd_1:
   \   000015   EE           MOV     A,R6
   \   000016   2402         ADD     A,#0x2
   \                     ??zcl_SendConfigReportCmd_2:
   \   000018   FE           MOV     R6,A
   \   000019   E4           CLR     A
   \   00001A   3F           ADDC    A,R7
   \   00001B   FF           MOV     R7,A
   1396              }
   \                     ??zcl_SendConfigReportCmd_3:
   \   00001C   05..         INC     ?V0
   \                     ??zcl_SendConfigReportCmd_0:
   \   00001E   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_327:
   \   000021   5040         JNC     ??zcl_SendConfigReportCmd_4
   \   000023   E5..         MOV     A,?V0
   \   000025   75F00C       MOV     B,#0xc
   \   000028   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_475:
   \   00002B   EE           MOV     A,R6
   \   00002C   2403         ADD     A,#0x3
   \   00002E   FE           MOV     R6,A
   \   00002F   E4           CLR     A
   \   000030   3F           ADDC    A,R7
   \   000031   FF           MOV     R7,A
   \   000032   E0           MOVX    A,@DPTR
   \   000033   70E0         JNZ     ??zcl_SendConfigReportCmd_1
   \   000035   EE           MOV     A,R6
   \   000036   2405         ADD     A,#0x5
   \   000038   FE           MOV     R6,A
   \   000039   E4           CLR     A
   \   00003A   3F           ADDC    A,R7
   \   00003B   FF           MOV     R7,A
   \   00003C   E582         MOV     A,DPL
   \   00003E   2403         ADD     A,#0x3
   \   000040   F5..         MOV     ?V2,A
   \   000042   E4           CLR     A
   \   000043   3583         ADDC    A,DPH
   \   000045   F5..         MOV     ?V3,A
   \   000047                ; Setup parameters for call to function zclAnalogDataType
   \   000047   85..82       MOV     DPL,?V2
   \   00004A   F583         MOV     DPH,A
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   000051   E9           MOV     A,R1
   \   000052   60C8         JZ      ??zcl_SendConfigReportCmd_3
   \   000054                ; Setup parameters for call to function zclGetDataTypeLength
   \   000054   85..82       MOV     DPL,?V2
   \   000057   85..83       MOV     DPH,?V3
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F9           MOV     R1,A
   \   00005C   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   00005F   EE           MOV     A,R6
   \   000060   29           ADD     A,R1
   \   000061   80B5         SJMP    ??zcl_SendConfigReportCmd_2
   1397            }
   1398          
   1399            buf = zcl_mem_alloc( dataLen );
   \                     ??zcl_SendConfigReportCmd_4:
   \   000063                ; Setup parameters for call to function osal_mem_alloc
   \   000063   EE           MOV     A,R6
   \   000064   FA           MOV     R2,A
   \   000065   EF           MOV     A,R7
   \   000066   FB           MOV     R3,A
   \   000067   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00006A   8A..         MOV     ?V2,R2
   \   00006C   8B..         MOV     ?V3,R3
   1400            if ( buf != NULL )
   \   00006E   EA           MOV     A,R2
   \   00006F   45..         ORL     A,?V3
   \   000071   7003         JNZ     $+5
   \   000073   02....       LJMP    ??zcl_SendConfigReportCmd_5 & 0xFFFF
   1401            {
   1402              // Load the buffer - serially
   1403              uint8 *pBuf = buf;
   \   000076   8A..         MOV     ?V6,R2
   \   000078   8B..         MOV     ?V7,R3
   1404          
   1405              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \   00007A   75..00       MOV     ?V0,#0x0
   \   00007D   801E         SJMP    ??zcl_SendConfigReportCmd_6
   1406              {
   1407                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1408          
   1409                *pBuf++ = reportRec->direction;
   1410                *pBuf++ = LO_UINT16( reportRec->attrID );
   1411                *pBuf++ = HI_UINT16( reportRec->attrID );
   1412          
   1413                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1414                {
   1415                  *pBuf++ = reportRec->dataType;
   1416                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1417                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1418                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1419                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1420          
   1421                  if ( zclAnalogDataType( reportRec->dataType ) )
   1422                  {
   1423                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1424                  }
   1425                }
   1426                else
   1427                {
   1428                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   \                     ??zcl_SendConfigReportCmd_7:
   \   00007F   E5..         MOV     A,?V4
   \   000081   2408         ADD     A,#0x8
   \   000083   F5..         MOV     ?V4,A
   \   000085   5002         JNC     ??zcl_SendConfigReportCmd_8
   \   000087   05..         INC     ?V5
   \                     ??zcl_SendConfigReportCmd_8:
   \   000089   F582         MOV     DPL,A
   \   00008B   85..83       MOV     DPH,?V5
   \   00008E   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   1429                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1430                }
   \                     ??CrossCallReturnLabel_331:
   \   000091   12....       LCALL   ??Subroutine184_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_345:
   \   000094   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   000097   8C..         MOV     ?V6,R4
   \   000099   8D..         MOV     ?V7,R5
   \                     ??zcl_SendConfigReportCmd_9:
   \   00009B   05..         INC     ?V0
   \                     ??zcl_SendConfigReportCmd_6:
   \   00009D   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_328:
   \   0000A0   4003         JC      $+5
   \   0000A2   02....       LJMP    ??zcl_SendConfigReportCmd_10 & 0xFFFF
   \   0000A5   E5..         MOV     A,?V0
   \   0000A7   75F00C       MOV     B,#0xc
   \   0000AA   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_343:
   \   0000AD   A882         MOV     R0,DPL
   \   0000AF   A983         MOV     R1,DPH
   \   0000B1   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   0000B4   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   0000B7   F0           MOVX    @DPTR,A
   \   0000B8   E5..         MOV     A,?V6
   \   0000BA   2405         ADD     A,#0x5
   \   0000BC   FC           MOV     R4,A
   \   0000BD   E4           CLR     A
   \   0000BE   35..         ADDC    A,?V7
   \   0000C0   FD           MOV     R5,A
   \   0000C1   E5..         MOV     A,?V6
   \   0000C3   2404         ADD     A,#0x4
   \   0000C5   FA           MOV     R2,A
   \   0000C6   E4           CLR     A
   \   0000C7   35..         ADDC    A,?V7
   \   0000C9   FB           MOV     R3,A
   \   0000CA   E5..         MOV     A,?V6
   \   0000CC   2403         ADD     A,#0x3
   \   0000CE   F8           MOV     R0,A
   \   0000CF   E4           CLR     A
   \   0000D0   35..         ADDC    A,?V7
   \   0000D2   F9           MOV     R1,A
   \   0000D3   85..82       MOV     DPL,?V4
   \   0000D6   85..83       MOV     DPH,?V5
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   70A3         JNZ     ??zcl_SendConfigReportCmd_7
   \   0000DC   E5..         MOV     A,?V4
   \   0000DE   2403         ADD     A,#0x3
   \   0000E0   F5..         MOV     ?V10,A
   \   0000E2   E4           CLR     A
   \   0000E3   35..         ADDC    A,?V5
   \   0000E5   F5..         MOV     ?V11,A
   \   0000E7   85..82       MOV     DPL,?V10
   \   0000EA   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_334:
   \   0000ED   F0           MOVX    @DPTR,A
   \   0000EE   E5..         MOV     A,?V4
   \   0000F0   2404         ADD     A,#0x4
   \   0000F2   F5..         MOV     ?V14,A
   \   0000F4   E4           CLR     A
   \   0000F5   35..         ADDC    A,?V5
   \   0000F7   F5..         MOV     ?V15,A
   \   0000F9   85..82       MOV     DPL,?V14
   \   0000FC   F583         MOV     DPH,A
   \   0000FE   12....       LCALL   ??Subroutine199_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_409:
   \   000101   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000104   2406         ADD     A,#0x6
   \   000106   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   000109   A3           INC     DPTR
   \   00010A   A3           INC     DPTR
   \   00010B   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   00010E   A3           INC     DPTR
   \   00010F   A3           INC     DPTR
   \   000110   A3           INC     DPTR
   \   000111   F0           MOVX    @DPTR,A
   \   000112   E5..         MOV     A,?V6
   \   000114   2408         ADD     A,#0x8
   \   000116   F5..         MOV     ?V6,A
   \   000118   5002         JNC     ??zcl_SendConfigReportCmd_11
   \   00011A   05..         INC     ?V7
   \                     ??zcl_SendConfigReportCmd_11:
   \   00011C                ; Setup parameters for call to function zclAnalogDataType
   \   00011C   85..82       MOV     DPL,?V10
   \   00011F   85..83       MOV     DPH,?V11
   \   000122   E0           MOVX    A,@DPTR
   \   000123   F9           MOV     R1,A
   \   000124   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   000127   E9           MOV     A,R1
   \   000128   7003         JNZ     $+5
   \   00012A   02....       LJMP    ??zcl_SendConfigReportCmd_9 & 0xFFFF
   \   00012D                ; Setup parameters for call to function zclSerializeData
   \   00012D   AC..         MOV     R4,?V6
   \   00012F   AD..         MOV     R5,?V7
   \   000131   85..82       MOV     DPL,?V4
   \   000134   85..83       MOV     DPH,?V5
   \   000137   A3           INC     DPTR
   \   000138   A3           INC     DPTR
   \   000139   A3           INC     DPTR
   \   00013A   A3           INC     DPTR
   \   00013B   A3           INC     DPTR
   \   00013C   A3           INC     DPTR
   \   00013D   A3           INC     DPTR
   \   00013E   A3           INC     DPTR
   \   00013F   A3           INC     DPTR
   \   000140   A3           INC     DPTR
   \   000141   12....       LCALL   ?Subroutine78 & 0xFFFF
   1431              } // for loop
   \                     ??CrossCallReturnLabel_131:
   \   000144   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   000147   8A..         MOV     ?V6,R2
   \   000149   8B..         MOV     ?V7,R3
   \   00014B   02....       LJMP    ??zcl_SendConfigReportCmd_9 & 0xFFFF
   1432          
   1433              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1434                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportCmd_10:
   \   00014E                ; Setup parameters for call to function zcl_SendCommand
   \   00014E   78..         MOV     R0,#?V2
   \   000150   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000153   8E..         MOV     ?V4,R6
   \   000155   8F..         MOV     ?V5,R7
   \   000157   78..         MOV     R0,#?V4
   \   000159   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015C   7422         MOV     A,#0x22
   \   00015E   12....       LCALL   ?XSTACK_DISP0_8
   \   000161   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000164   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000167   E4           CLR     A
   \   000168   F5..         MOV     ?V4,A
   \   00016A   F5..         MOV     ?V5,A
   \   00016C   78..         MOV     R0,#?V4
   \   00016E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000171   7424         MOV     A,#0x24
   \   000173   12....       LCALL   ?XSTACK_DISP0_8
   \   000176   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000179   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00017C   7424         MOV     A,#0x24
   \   00017E   12....       LCALL   ?XSTACK_DISP0_8
   \   000181   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000184   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000187   75..00       MOV     ?V0,#0x0
   \   00018A   78..         MOV     R0,#?V0
   \   00018C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00018F   75..06       MOV     ?V0,#0x6
   \   000192   78..         MOV     R0,#?V0
   \   000194   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000197   AC..         MOV     R4,?V12
   \   000199   AD..         MOV     R5,?V13
   \   00019B   740B         MOV     A,#0xb
   \   00019D   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A0   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_387:
   \   0001A3   A9..         MOV     R1,?V1
   \   0001A5   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0001A8   740B         MOV     A,#0xb
   \   0001AA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001AD   E9           MOV     A,R1
   \   0001AE   FE           MOV     R6,A
   1435              zcl_mem_free( buf );
   \   0001AF                ; Setup parameters for call to function osal_mem_free
   \   0001AF   AA..         MOV     R2,?V2
   \   0001B1   AB..         MOV     R3,?V3
   \   0001B3   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001B6   8002         SJMP    ??zcl_SendConfigReportCmd_12
   1436            }
   1437            else
   1438            {
   1439              status = ZMemError;
   \                     ??zcl_SendConfigReportCmd_5:
   \   0001B8   7E10         MOV     R6,#0x10
   1440            }
   1441          
   1442            return ( status );
   \                     ??zcl_SendConfigReportCmd_12:
   \   0001BA   02....       LJMP    ?Subroutine5 & 0xFFFF
   1443          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   F8           MOV     R0,A
   \   000001   E4           CLR     A
   \   000002   35..         ADDC    A,?V5
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009                REQUIRE ??Subroutine180_0
   \   000009                ; // Fall through to label ??Subroutine180_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine180_0:
   \   000000   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006                REQUIRE ??Subroutine181_0
   \   000006                ; // Fall through to label ??Subroutine181_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine181_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V0
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   F583         MOV     DPH,A
   \   000002                REQUIRE ??Subroutine182_0
   \   000002                ; // Fall through to label ??Subroutine182_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine182_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_323:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine149:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V6
   \   000004   85..83       MOV     DPH,?V7
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   12....       LCALL   ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_476:
   \   000003   8582..       MOV     ?V4,DPL
   \   000006   8583..       MOV     ?V5,DPH
   \   000009   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_322:
   \   00000C                REQUIRE ??Subroutine184_0
   \   00000C                ; // Fall through to label ??Subroutine184_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine184_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V4
   \   000004   85..83       MOV     DPH,?V5
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine132:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine173 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   000004   E0           MOVX    A,@DPTR
   \   000005   85..82       MOV     DPL,?V6
   \   000008   85..83       MOV     DPH,?V7
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V14
   \   000004   85..83       MOV     DPH,?V15
   \   000007   12....       LCALL   ?Subroutine160 & 0xFFFF
   \                     ??CrossCallReturnLabel_364:
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   E5..         MOV     A,?V4
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   EA           MOV     A,R2
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   EB           MOV     A,R3
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   89..         MOV     ?V1,R1
   \   00000D   8C..         MOV     ?V12,R4
   \   00000F   8D..         MOV     ?V13,R5
   \   000011   7E00         MOV     R6,#0x0
   \   000013   7F00         MOV     R7,#0x0
   \   000015   75..00       MOV     ?V0,#0x0
   \   000018   741A         MOV     A,#0x1a
   \   00001A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine160:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine191_0
   \   000001                ; // Fall through to label ??Subroutine191_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine191_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   12....       LCALL   ??Subroutine199_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_412:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine165:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V8
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V9
   \   00000B                REQUIRE ??Subroutine210_0
   \   00000B                ; // Fall through to label ??Subroutine210_0
   1444          
   1445          /*********************************************************************
   1446           * @fn      zcl_SendConfigReportRspCmd
   1447           *
   1448           * @brief   Send a Configure Reporting Response command
   1449           *
   1450           * @param   dstAddr - destination address
   1451           * @param   clusterID - cluster ID
   1452           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1453           * @param   direction - direction of the command
   1454           * @param   seqNum - transaction sequence number
   1455           *
   1456           * @return  ZSuccess if OK
   1457           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1458          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportRspCmd:
   1459                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1460                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1461          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine80 & 0xFFFF
   1462            uint16 dataLen;
   1463            uint8 *buf;
   1464            ZStatus_t status;
   1465          
   1466            // Atrribute list (Status, Direction and Attribute ID)
   1467            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   \                     ??CrossCallReturnLabel_136:
   \   000017   F5..         MOV     ?V0,A
   \   000019   75..00       MOV     ?V1,#0x0
   \   00001C   7402         MOV     A,#0x2
   \   00001E   78..         MOV     R0,#?V0
   \   000020   12....       LCALL   ?S_SHL
   \   000023   85....       MOV     ?V6,?V0
   \   000026   85....       MOV     ?V7,?V1
   1468          
   1469            buf = zcl_mem_alloc( dataLen );
   \   000029                ; Setup parameters for call to function osal_mem_alloc
   \   000029   AA..         MOV     R2,?V6
   \   00002B   AB..         MOV     R3,?V7
   \   00002D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000030   8A..         MOV     ?V0,R2
   \   000032   8B..         MOV     ?V1,R3
   1470            if ( buf != NULL )
   \   000034   EA           MOV     A,R2
   \   000035   45..         ORL     A,?V1
   \   000037   7003         JNZ     $+5
   \   000039   02....       LJMP    ??zcl_SendConfigReportRspCmd_0 & 0xFFFF
   1471            {
   1472              // Load the buffer - serially
   1473              uint8 *pBuf = buf;
   1474              uint8 i;
   1475          
   1476              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   00003C   7C00         MOV     R4,#0x0
   \   00003E   803D         SJMP    ??zcl_SendConfigReportRspCmd_1
   1477              {
   1478                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   \                     ??zcl_SendConfigReportRspCmd_2:
   \   000040   8C..         MOV     ?V10,R4
   \   000042   75..00       MOV     ?V11,#0x0
   \   000045   7402         MOV     A,#0x2
   \   000047   78..         MOV     R0,#?V10
   \   000049   12....       LCALL   ?S_SHL
   \   00004C   E5..         MOV     A,?V4
   \   00004E   25..         ADD     A,?V10
   \   000050   F8           MOV     R0,A
   \   000051   E5..         MOV     A,?V5
   \   000053   35..         ADDC    A,?V11
   \   000055   12....       LCALL   ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_414:
   \   000058   12....       LCALL   ?Subroutine32 & 0xFFFF
   1479                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   \                     ??CrossCallReturnLabel_29:
   \   00005B   A3           INC     DPTR
   \   00005C   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   00005F   F0           MOVX    @DPTR,A
   1480                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \   000060   E8           MOV     A,R0
   \   000061   2403         ADD     A,#0x3
   \   000063   F8           MOV     R0,A
   \   000064   5001         JNC     ??zcl_SendConfigReportRspCmd_3
   \   000066   09           INC     R1
   \                     ??zcl_SendConfigReportRspCmd_3:
   \   000067   8882         MOV     DPL,R0
   \   000069   8983         MOV     DPH,R1
   \   00006B   12....       LCALL   ?Subroutine103 & 0xFFFF
   1481                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1482              }
   \                     ??CrossCallReturnLabel_178:
   \   00006E   A3           INC     DPTR
   \   00006F   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   F0           MOVX    @DPTR,A
   \   000075   EA           MOV     A,R2
   \   000076   2404         ADD     A,#0x4
   \   000078   FA           MOV     R2,A
   \   000079   5001         JNC     ??zcl_SendConfigReportRspCmd_4
   \   00007B   0B           INC     R3
   \                     ??zcl_SendConfigReportRspCmd_4:
   \   00007C   0C           INC     R4
   \                     ??zcl_SendConfigReportRspCmd_1:
   \   00007D   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   000080   40BE         JC      ??zcl_SendConfigReportRspCmd_2
   1483          
   1484              // If there's only a single status record and its status field is set to
   1485              // SUCCESS then omit the attribute ID field.
   1486              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000082   7401         MOV     A,#0x1
   \   000084   68           XRL     A,R0
   \   000085   700A         JNZ     ??zcl_SendConfigReportRspCmd_5
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   7006         JNZ     ??zcl_SendConfigReportRspCmd_5
   1487              {
   1488                dataLen = 1;
   \   00008B   75..01       MOV     ?V6,#0x1
   \   00008E   75..00       MOV     ?V7,#0x0
   1489              }
   1490          
   1491              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1492                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1493                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportRspCmd_5:
   \   000091                ; Setup parameters for call to function zcl_SendCommand
   \   000091   78..         MOV     R0,#?V0
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000096   78..         MOV     R0,#?V6
   \   000098   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009B   741C         MOV     A,#0x1c
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   0000A3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A6   E4           CLR     A
   \   0000A7   F5..         MOV     ?V4,A
   \   0000A9   F5..         MOV     ?V5,A
   \   0000AB   78..         MOV     R0,#?V4
   \   0000AD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B0   741E         MOV     A,#0x1e
   \   0000B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B5   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   0000B8   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BB   741E         MOV     A,#0x1e
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   0000C3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C6   75..00       MOV     ?V3,#0x0
   \   0000C9   78..         MOV     R0,#?V3
   \   0000CB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CE   75..07       MOV     ?V3,#0x7
   \   0000D1   78..         MOV     R0,#?V3
   \   0000D3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D6   EE           MOV     A,R6
   \   0000D7   FC           MOV     R4,A
   \   0000D8   EF           MOV     A,R7
   \   0000D9   FD           MOV     R5,A
   \   0000DA   AA..         MOV     R2,?V8
   \   0000DC   AB..         MOV     R3,?V9
   \   0000DE   A9..         MOV     R1,?V2
   \   0000E0   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000E3   740B         MOV     A,#0xb
   \   0000E5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E8   E9           MOV     A,R1
   \   0000E9   FE           MOV     R6,A
   1494              zcl_mem_free( buf );
   \   0000EA                ; Setup parameters for call to function osal_mem_free
   \   0000EA   AA..         MOV     R2,?V0
   \   0000EC   AB..         MOV     R3,?V1
   \   0000EE   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000F1   8002         SJMP    ??zcl_SendConfigReportRspCmd_6
   1495            }
   1496            else
   1497            {
   1498              status = ZMemError;
   \                     ??zcl_SendConfigReportRspCmd_0:
   \   0000F3   7E10         MOV     R6,#0x10
   1499            }
   1500          
   1501            return ( status );
   \                     ??zcl_SendConfigReportRspCmd_6:
   \   0000F5                REQUIRE ?Subroutine10
   \   0000F5                ; // Fall through to label ?Subroutine10
   1502          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   12....       LCALL   ??Subroutine199_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_413:
   \   000003   A3           INC     DPTR
   \   000004   22           RET
   1503          
   1504          /*********************************************************************
   1505           * @fn      zcl_SendReadReportCfgCmd
   1506           *
   1507           * @brief   Send a Read Reporting Configuration command
   1508           *
   1509           * @param   dstAddr - destination address
   1510           * @param   clusterID - cluster ID
   1511           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1512           * @param   direction - direction of the command
   1513           * @param   seqNum - transaction sequence number
   1514           *
   1515           * @return  ZSuccess if OK
   1516           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1517          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgCmd:
   1518                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1519                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1520          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine53 & 0xFFFF
   1521            uint16 dataLen;
   1522            uint8 *buf;
   1523            ZStatus_t status;
   1524          
   1525            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1526          
   1527            buf = zcl_mem_alloc( dataLen );
   \                     ??CrossCallReturnLabel_77:
   \   000017   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00001A   8A..         MOV     ?V0,R2
   \   00001C   8B..         MOV     ?V1,R3
   1528            if ( buf != NULL )
   \   00001E   EA           MOV     A,R2
   \   00001F   45..         ORL     A,?V1
   \   000021   6078         JZ      ??zcl_SendReadReportCfgCmd_0
   1529            {
   1530              // Load the buffer - serially
   1531              uint8 *pBuf = buf;
   1532              uint8 i;
   1533          
   1534              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   \   000023   7C00         MOV     R4,#0x0
   \   000025   800D         SJMP    ??zcl_SendReadReportCfgCmd_1
   1535              {
   1536                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   \                     ??zcl_SendReadReportCfgCmd_2:
   \   000027   12....       LCALL   ?Subroutine94 & 0xFFFF
   1537                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1538                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1539              }
   \                     ??CrossCallReturnLabel_162:
   \   00002A   5001         JNC     ??zcl_SendReadReportCfgCmd_3
   \   00002C   09           INC     R1
   \                     ??zcl_SendReadReportCfgCmd_3:
   \   00002D   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000030   5001         JNC     ??zcl_SendReadReportCfgCmd_4
   \   000032   0B           INC     R3
   \                     ??zcl_SendReadReportCfgCmd_4:
   \   000033   0C           INC     R4
   \                     ??zcl_SendReadReportCfgCmd_1:
   \   000034   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   000037   40EE         JC      ??zcl_SendReadReportCfgCmd_2
   1540          
   1541              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1542                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000039                ; Setup parameters for call to function zcl_SendCommand
   \   000039   78..         MOV     R0,#?V0
   \   00003B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003E   78..         MOV     R0,#?V6
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   741C         MOV     A,#0x1c
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004E   E4           CLR     A
   \   00004F   F5..         MOV     ?V4,A
   \   000051   F5..         MOV     ?V5,A
   \   000053   78..         MOV     R0,#?V4
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   741E         MOV     A,#0x1e
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000063   741E         MOV     A,#0x1e
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006E   75..00       MOV     ?V3,#0x0
   \   000071   78..         MOV     R0,#?V3
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000076   75..08       MOV     ?V3,#0x8
   \   000079   78..         MOV     R0,#?V3
   \   00007B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007E   EE           MOV     A,R6
   \   00007F   FC           MOV     R4,A
   \   000080   EF           MOV     A,R7
   \   000081   FD           MOV     R5,A
   \   000082   AA..         MOV     R2,?V8
   \   000084   AB..         MOV     R3,?V9
   \   000086   A9..         MOV     R1,?V2
   \   000088   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00008B   740B         MOV     A,#0xb
   \   00008D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000090   E9           MOV     A,R1
   \   000091   FE           MOV     R6,A
   1543              zcl_mem_free( buf );
   \   000092                ; Setup parameters for call to function osal_mem_free
   \   000092   AA..         MOV     R2,?V0
   \   000094   AB..         MOV     R3,?V1
   \   000096   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000099   8002         SJMP    ??zcl_SendReadReportCfgCmd_5
   1544            }
   1545            else
   1546            {
   1547              status = ZMemError;
   \                     ??zcl_SendReadReportCfgCmd_0:
   \   00009B   7E10         MOV     R6,#0x10
   1548            }
   1549          
   1550            return ( status );
   \                     ??zcl_SendReadReportCfgCmd_5:
   \   00009D   02....       LJMP    ?Subroutine10 & 0xFFFF
   1551          }
   1552          
   1553          /*********************************************************************
   1554           * @fn      zcl_SendReadReportCfgRspCmd
   1555           *
   1556           * @brief   Send a Read Reporting Configuration Response command
   1557           *
   1558           * @param   dstAddr - destination address
   1559           * @param   clusterID - cluster ID
   1560           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1561           * @param   direction - direction of the command
   1562           * @param   seqNum - transaction sequence number
   1563           *
   1564           * @return  ZSuccess if OK
   1565           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1566          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgRspCmd:
   1567                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1568                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1569          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine17 & 0xFFFF
   1570            uint8 *buf;
   1571            uint16 dataLen = 0;
   1572            ZStatus_t status;
   1573            uint8 i;
   1574          
   1575            // Find out the data length
   1576            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_7:
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_339:
   \   000013   8009         SJMP    ??zcl_SendReadReportCfgRspCmd_0
   1577            {
   1578              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1579          
   1580              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1581          
   1582              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1583              {
   1584                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1585                {
   1586                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1587          
   1588                  // Find out the size of the Reportable Change field (for Analog data types)
   1589                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1590                  {
   1591                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1592                  }
   1593                }
   1594                else
   1595                {
   1596                  dataLen += 2; // Timeout Period
   \                     ??zcl_SendReadReportCfgRspCmd_1:
   \   000015   EE           MOV     A,R6
   \   000016   2402         ADD     A,#0x2
   \                     ??zcl_SendReadReportCfgRspCmd_2:
   \   000018   FE           MOV     R6,A
   \   000019   E4           CLR     A
   \   00001A   3F           ADDC    A,R7
   \   00001B   FF           MOV     R7,A
   1597                }
   \                     ??zcl_SendReadReportCfgRspCmd_3:
   \   00001C   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_0:
   \   00001E   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_329:
   \   000021   5041         JNC     ??zcl_SendReadReportCfgRspCmd_4
   \   000023   E5..         MOV     A,?V0
   \   000025   75F00D       MOV     B,#0xd
   \   000028   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   00002B   2404         ADD     A,#0x4
   \   00002D   FE           MOV     R6,A
   \   00002E   E4           CLR     A
   \   00002F   3F           ADDC    A,R7
   \   000030   FF           MOV     R7,A
   \   000031   E0           MOVX    A,@DPTR
   \   000032   70E8         JNZ     ??zcl_SendReadReportCfgRspCmd_3
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   70DD         JNZ     ??zcl_SendReadReportCfgRspCmd_1
   \   000038   EE           MOV     A,R6
   \   000039   2405         ADD     A,#0x5
   \   00003B   FE           MOV     R6,A
   \   00003C   E4           CLR     A
   \   00003D   3F           ADDC    A,R7
   \   00003E   FF           MOV     R7,A
   \   00003F   E8           MOV     A,R0
   \   000040   2404         ADD     A,#0x4
   \   000042   F5..         MOV     ?V2,A
   \   000044   E4           CLR     A
   \   000045   39           ADDC    A,R1
   \   000046   F5..         MOV     ?V3,A
   \   000048                ; Setup parameters for call to function zclAnalogDataType
   \   000048   85..82       MOV     DPL,?V2
   \   00004B   F583         MOV     DPH,A
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   F9           MOV     R1,A
   \   00004F   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   000052   E9           MOV     A,R1
   \   000053   60C7         JZ      ??zcl_SendReadReportCfgRspCmd_3
   \   000055                ; Setup parameters for call to function zclGetDataTypeLength
   \   000055   85..82       MOV     DPL,?V2
   \   000058   85..83       MOV     DPH,?V3
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F9           MOV     R1,A
   \   00005D   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000060   EE           MOV     A,R6
   \   000061   29           ADD     A,R1
   \   000062   80B4         SJMP    ??zcl_SendReadReportCfgRspCmd_2
   1598              }
   1599            }
   1600          
   1601            buf = zcl_mem_alloc( dataLen );
   \                     ??zcl_SendReadReportCfgRspCmd_4:
   \   000064                ; Setup parameters for call to function osal_mem_alloc
   \   000064   EE           MOV     A,R6
   \   000065   FA           MOV     R2,A
   \   000066   EF           MOV     A,R7
   \   000067   FB           MOV     R3,A
   \   000068   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00006B   8A..         MOV     ?V2,R2
   \   00006D   8B..         MOV     ?V3,R3
   1602            if ( buf != NULL )
   \   00006F   EA           MOV     A,R2
   \   000070   45..         ORL     A,?V3
   \   000072   7003         JNZ     $+5
   \   000074   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_5 & 0xFFFF
   1603            {
   1604              // Load the buffer - serially
   1605              uint8 *pBuf = buf;
   \   000077   8A..         MOV     ?V6,R2
   \   000079   8B..         MOV     ?V7,R3
   1606          
   1607              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   00007B   75..00       MOV     ?V0,#0x0
   \   00007E   801D         SJMP    ??zcl_SendReadReportCfgRspCmd_6
   1608              {
   1609                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1610          
   1611                *pBuf++ = reportRspRec->status;
   1612                *pBuf++ = reportRspRec->direction;
   1613                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1614                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1615          
   1616                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1617                {
   1618                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1619                  {
   1620                    *pBuf++ = reportRspRec->dataType;
   1621                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1622                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1623                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1624                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1625          
   1626                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1627                    {
   1628                      pBuf = zclSerializeData( reportRspRec->dataType,
   1629                                               reportRspRec->reportableChange, pBuf );
   1630                    }
   1631                  }
   1632                  else
   1633                  {
   1634                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   \                     ??zcl_SendReadReportCfgRspCmd_7:
   \   000080   E5..         MOV     A,?V4
   \   000082   2409         ADD     A,#0x9
   \   000084   FA           MOV     R2,A
   \   000085   E4           CLR     A
   \   000086   35..         ADDC    A,?V5
   \   000088   FB           MOV     R3,A
   \   000089   8A82         MOV     DPL,R2
   \   00008B   8B83         MOV     DPH,R3
   \   00008D   12....       LCALL   ?Subroutine83 & 0xFFFF
   1635                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1636                  }
   \                     ??CrossCallReturnLabel_142:
   \   000090   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000093   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_332:
   \   000096   F0           MOVX    @DPTR,A
   \   000097   8C..         MOV     ?V6,R4
   \   000099   8D..         MOV     ?V7,R5
   \                     ??zcl_SendReadReportCfgRspCmd_8:
   \   00009B   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_6:
   \   00009D   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   0000A0   4003         JC      $+5
   \   0000A2   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_9 & 0xFFFF
   \   0000A5   E5..         MOV     A,?V0
   \   0000A7   75F00D       MOV     B,#0xd
   \   0000AA   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_344:
   \   0000AD   AA82         MOV     R2,DPL
   \   0000AF   AB83         MOV     R3,DPH
   \   0000B1   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_319:
   \   0000B4   F0           MOVX    @DPTR,A
   \   0000B5   E5..         MOV     A,?V4
   \   0000B7   2402         ADD     A,#0x2
   \   0000B9   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   0000BC   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000BF   A3           INC     DPTR
   \   0000C0   F0           MOVX    @DPTR,A
   \   0000C1   E5..         MOV     A,?V6
   \   0000C3   2404         ADD     A,#0x4
   \   0000C5   F5..         MOV     ?V6,A
   \   0000C7   5002         JNC     ??zcl_SendReadReportCfgRspCmd_10
   \   0000C9   05..         INC     ?V7
   \                     ??zcl_SendReadReportCfgRspCmd_10:
   \   0000CB   85..82       MOV     DPL,?V4
   \   0000CE   85..83       MOV     DPH,?V5
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   70C7         JNZ     ??zcl_SendReadReportCfgRspCmd_8
   \   0000D4   E5..         MOV     A,?V6
   \   0000D6   2402         ADD     A,#0x2
   \   0000D8   FC           MOV     R4,A
   \   0000D9   E4           CLR     A
   \   0000DA   35..         ADDC    A,?V7
   \   0000DC   FD           MOV     R5,A
   \   0000DD   85..82       MOV     DPL,?V6
   \   0000E0   85..83       MOV     DPH,?V7
   \   0000E3   A3           INC     DPTR
   \   0000E4   A882         MOV     R0,DPL
   \   0000E6   A983         MOV     R1,DPH
   \   0000E8   8A82         MOV     DPL,R2
   \   0000EA   8B83         MOV     DPH,R3
   \   0000EC   E0           MOVX    A,@DPTR
   \   0000ED   7091         JNZ     ??zcl_SendReadReportCfgRspCmd_7
   \   0000EF   E5..         MOV     A,?V4
   \   0000F1   2404         ADD     A,#0x4
   \   0000F3   F5..         MOV     ?V10,A
   \   0000F5   E4           CLR     A
   \   0000F6   35..         ADDC    A,?V5
   \   0000F8   F5..         MOV     ?V11,A
   \   0000FA   85..82       MOV     DPL,?V10
   \   0000FD   F583         MOV     DPH,A
   \   0000FF   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   000102   F0           MOVX    @DPTR,A
   \   000103   E5..         MOV     A,?V4
   \   000105   2405         ADD     A,#0x5
   \   000107   F5..         MOV     ?V14,A
   \   000109   E4           CLR     A
   \   00010A   35..         ADDC    A,?V5
   \   00010C   F5..         MOV     ?V15,A
   \   00010E   85..82       MOV     DPL,?V14
   \   000111   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_335:
   \   000114   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000117   2407         ADD     A,#0x7
   \   000119   F8           MOV     R0,A
   \   00011A   E4           CLR     A
   \   00011B   35..         ADDC    A,?V5
   \   00011D   F9           MOV     R1,A
   \   00011E   8882         MOV     DPL,R0
   \   000120   8983         MOV     DPH,R1
   \   000122   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000125   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000128   F0           MOVX    @DPTR,A
   \   000129   E5..         MOV     A,?V6
   \   00012B   2405         ADD     A,#0x5
   \   00012D   F5..         MOV     ?V6,A
   \   00012F   5002         JNC     ??zcl_SendReadReportCfgRspCmd_11
   \   000131   05..         INC     ?V7
   \                     ??zcl_SendReadReportCfgRspCmd_11:
   \   000133                ; Setup parameters for call to function zclAnalogDataType
   \   000133   85..82       MOV     DPL,?V10
   \   000136   85..83       MOV     DPH,?V11
   \   000139   E0           MOVX    A,@DPTR
   \   00013A   F9           MOV     R1,A
   \   00013B   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   00013E   E9           MOV     A,R1
   \   00013F   7003         JNZ     $+5
   \   000141   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_8 & 0xFFFF
   \   000144                ; Setup parameters for call to function zclSerializeData
   \   000144   AC..         MOV     R4,?V6
   \   000146   AD..         MOV     R5,?V7
   \   000148   E5..         MOV     A,?V4
   \   00014A   240B         ADD     A,#0xb
   \   00014C   F582         MOV     DPL,A
   \   00014E   E4           CLR     A
   \   00014F   35..         ADDC    A,?V5
   \   000151   F583         MOV     DPH,A
   \   000153   12....       LCALL   ?Subroutine78 & 0xFFFF
   1637                }
   1638              }
   \                     ??CrossCallReturnLabel_132:
   \   000156   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   000159   8A..         MOV     ?V6,R2
   \   00015B   8B..         MOV     ?V7,R3
   \   00015D   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_8 & 0xFFFF
   1639          
   1640              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1641                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1642                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendReadReportCfgRspCmd_9:
   \   000160                ; Setup parameters for call to function zcl_SendCommand
   \   000160   78..         MOV     R0,#?V2
   \   000162   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000165   8E..         MOV     ?V4,R6
   \   000167   8F..         MOV     ?V5,R7
   \   000169   78..         MOV     R0,#?V4
   \   00016B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016E   7422         MOV     A,#0x22
   \   000170   12....       LCALL   ?XSTACK_DISP0_8
   \   000173   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000176   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000179   E4           CLR     A
   \   00017A   F5..         MOV     ?V4,A
   \   00017C   F5..         MOV     ?V5,A
   \   00017E   78..         MOV     R0,#?V4
   \   000180   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000183   7424         MOV     A,#0x24
   \   000185   12....       LCALL   ?XSTACK_DISP0_8
   \   000188   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   00018B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00018E   7424         MOV     A,#0x24
   \   000190   12....       LCALL   ?XSTACK_DISP0_8
   \   000193   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000196   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000199   75..00       MOV     ?V0,#0x0
   \   00019C   78..         MOV     R0,#?V0
   \   00019E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001A1   75..09       MOV     ?V0,#0x9
   \   0001A4   78..         MOV     R0,#?V0
   \   0001A6   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001A9   AC..         MOV     R4,?V12
   \   0001AB   AD..         MOV     R5,?V13
   \   0001AD   740B         MOV     A,#0xb
   \   0001AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B2   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_388:
   \   0001B5   A9..         MOV     R1,?V1
   \   0001B7   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0001BA   740B         MOV     A,#0xb
   \   0001BC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001BF   E9           MOV     A,R1
   \   0001C0   FE           MOV     R6,A
   1643              zcl_mem_free( buf );
   \   0001C1                ; Setup parameters for call to function osal_mem_free
   \   0001C1   AA..         MOV     R2,?V2
   \   0001C3   AB..         MOV     R3,?V3
   \   0001C5   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001C8   8002         SJMP    ??zcl_SendReadReportCfgRspCmd_12
   1644            }
   1645            else
   1646            {
   1647              status = ZMemError;
   \                     ??zcl_SendReadReportCfgRspCmd_5:
   \   0001CA   7E10         MOV     R6,#0x10
   1648            }
   1649          
   1650            return ( status );
   \                     ??zcl_SendReadReportCfgRspCmd_12:
   \   0001CC   02....       LJMP    ?Subroutine5 & 0xFFFF
   1651          }
   1652          
   1653          /*********************************************************************
   1654           * @fn      zcl_SendReportCmd
   1655           *
   1656           * @brief   Send a Report command
   1657           *
   1658           * @param   dstAddr - destination address
   1659           * @param   clusterID - cluster ID
   1660           * @param   reportCmd - report command to be sent
   1661           * @param   direction - direction of the command
   1662           * @param   seqNum - transaction sequence number
   1663           *
   1664           * @return  ZSuccess if OK
   1665           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1666          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReportCmd:
   1667                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1668                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1669          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   1670            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1671            uint8 *buf;
   1672            ZStatus_t status;
   1673            uint8 i;
   1674          
   1675            // calculate the size of the command
   1676            for ( i = 0; i < reportCmd->numAttr; i++ )
   \   000013   75..00       MOV     ?V2,#0x0
   \   000016   7416         MOV     A,#0x16
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   00001E   8009         SJMP    ??CrossCallReturnLabel_229
   1677            {
   1678              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_0:
   \   000020   12....       LCALL   ?Subroutine77 & 0xFFFF
   1679          
   1680              dataLen += 2 + 1; // Attribute ID + data type
   1681          
   1682              // Attribute Data
   1683              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1684            }
   \                     ??CrossCallReturnLabel_130:
   \   000023   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000026   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000029   85..82       MOV     DPL,?V4
   \   00002C   85..83       MOV     DPH,?V5
   \   00002F   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_443:
   \   000032   40EC         JC      ??zcl_SendReportCmd_0
   1685          
   1686            buf = zcl_mem_alloc( dataLen );
   \   000034                ; Setup parameters for call to function osal_mem_alloc
   \   000034   EE           MOV     A,R6
   \   000035   FA           MOV     R2,A
   \   000036   EF           MOV     A,R7
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003B   8A..         MOV     ?V0,R2
   \   00003D   8B..         MOV     ?V1,R3
   1687            if ( buf != NULL )
   \   00003F   EA           MOV     A,R2
   \   000040   45..         ORL     A,?V1
   \   000042   7003         JNZ     $+5
   \   000044   02....       LJMP    ??zcl_SendReportCmd_1 & 0xFFFF
   1688            {
   1689              // Load the buffer - serially
   1690              uint8 *pBuf = buf;
   \   000047   A8..         MOV     R0,?V0
   \   000049   A9..         MOV     R1,?V1
   1691          
   1692              for ( i = 0; i < reportCmd->numAttr; i++ )
   \   00004B   75..00       MOV     ?V2,#0x0
   \   00004E   8010         SJMP    ??zcl_SendReportCmd_2
   1693              {
   1694                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_3:
   \   000050   12....       LCALL   ?Subroutine13 & 0xFFFF
   1695          
   1696                *pBuf++ = LO_UINT16( reportRec->attrID );
   1697                *pBuf++ = HI_UINT16( reportRec->attrID );
   1698                *pBuf++ = reportRec->dataType;
   1699          
   1700                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1701              }
   \                     ??CrossCallReturnLabel_1:
   \   000053   12....       LCALL   `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   000056   8A..         MOV     ?V10,R2
   \   000058   8B..         MOV     ?V11,R3
   \   00005A   A8..         MOV     R0,?V10
   \   00005C   A9..         MOV     R1,?V11
   \   00005E   05..         INC     ?V2
   \                     ??zcl_SendReportCmd_2:
   \   000060   85..82       MOV     DPL,?V4
   \   000063   85..83       MOV     DPH,?V5
   \   000066   E0           MOVX    A,@DPTR
   \   000067   FA           MOV     R2,A
   \   000068   E5..         MOV     A,?V2
   \   00006A   C3           CLR     C
   \   00006B   9A           SUBB    A,R2
   \   00006C   40E2         JC      ??zcl_SendReportCmd_3
   1702          
   1703              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1704                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00006E                ; Setup parameters for call to function zcl_SendCommand
   \   00006E   78..         MOV     R0,#?V0
   \   000070   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000073   8E..         MOV     ?V4,R6
   \   000075   8F..         MOV     ?V5,R7
   \   000077   78..         MOV     R0,#?V4
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007C   741E         MOV     A,#0x1e
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000087   E4           CLR     A
   \   000088   F5..         MOV     ?V4,A
   \   00008A   F5..         MOV     ?V5,A
   \   00008C   78..         MOV     R0,#?V4
   \   00008E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000091   7420         MOV     A,#0x20
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009C   7420         MOV     A,#0x20
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A7   75..00       MOV     ?V2,#0x0
   \   0000AA   78..         MOV     R0,#?V2
   \   0000AC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AF   75..0A       MOV     ?V2,#0xa
   \   0000B2   78..         MOV     R0,#?V2
   \   0000B4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B7   AC..         MOV     R4,?V6
   \   0000B9   AD..         MOV     R5,?V7
   \   0000BB   AA..         MOV     R2,?V8
   \   0000BD   AB..         MOV     R3,?V9
   \   0000BF   A9..         MOV     R1,?V3
   \   0000C1   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000C4   740B         MOV     A,#0xb
   \   0000C6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C9   E9           MOV     A,R1
   \   0000CA   FE           MOV     R6,A
   1705              zcl_mem_free( buf );
   \   0000CB                ; Setup parameters for call to function osal_mem_free
   \   0000CB   AA..         MOV     R2,?V0
   \   0000CD   AB..         MOV     R3,?V1
   \   0000CF   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000D2   8002         SJMP    ??zcl_SendReportCmd_4
   1706            }
   1707            else
   1708            {
   1709              status = ZMemError;
   \                     ??zcl_SendReportCmd_1:
   \   0000D4   7E10         MOV     R6,#0x10
   1710            }
   1711          
   1712            return ( status );
   \                     ??zcl_SendReportCmd_4:
   \   0000D6   02....       LJMP    ?Subroutine12 & 0xFFFF
   1713          }
   1714          #endif // ZCL_REPORT
   1715          
   1716          /*********************************************************************
   1717           * @fn      zcl_SendDefaultRspCmd
   1718           *
   1719           * @brief   Send a Default Response command
   1720           *
   1721           *          Note: The manufacturer code field should be set if this
   1722           *          command is being sent in response to a manufacturer specific
   1723           *          command.
   1724           *
   1725           * @param   dstAddr - destination address
   1726           * @param   clusterID - cluster ID
   1727           * @param   defaultRspCmd - default response command to be sent
   1728           * @param   direction - direction of the command
   1729           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1730           * @param   seqNum - transaction sequence number
   1731           *
   1732           * @return  ZSuccess if OK
   1733           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1734          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1735                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1736                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1737          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   740C         MOV     A,#0xc
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   12....       LCALL   ?Subroutine98 & 0xFFFF
   1738            uint8 buf[2]; // Command ID and Status;
   1739          
   1740            // Load the buffer - serially
   1741            buf[0] = defaultRspCmd->commandID;
   \                     ??CrossCallReturnLabel_167:
   \   000014   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000017   12....       LCALL   ?Subroutine32 & 0xFFFF
   1742            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_30:
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   C0E0         PUSH    A
   \   00001D   7401         MOV     A,#0x1
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   D0E0         POP     A
   \   000024   F0           MOVX    @DPTR,A
   1743          
   1744            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1745                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   000025                ; Setup parameters for call to function zcl_SendCommand
   \   000025   A8..         MOV     R0,?XSP + 0
   \   000027   A9..         MOV     R1,?XSP + 1
   \   000029   88..         MOV     ?V0,R0
   \   00002B   89..         MOV     ?V1,R1
   \   00002D   78..         MOV     R0,#?V0
   \   00002F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000032   75..02       MOV     ?V0,#0x2
   \   000035   75..00       MOV     ?V1,#0x0
   \   000038   78..         MOV     R0,#?V0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   7416         MOV     A,#0x16
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000045   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000048   7415         MOV     A,#0x15
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000050   7416         MOV     A,#0x16
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00005B   7416         MOV     A,#0x16
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000066   75..00       MOV     ?V0,#0x0
   \   000069   78..         MOV     R0,#?V0
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006E   75..0B       MOV     ?V0,#0xb
   \   000071   78..         MOV     R0,#?V0
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000076   EE           MOV     A,R6
   \   000077   F9           MOV     R1,A
   \   000078   12....       LCALL   `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00007B   740B         MOV     A,#0xb
   \   00007D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000080   7402         MOV     A,#0x2
   \   000082   12....       LCALL   ?DEALLOC_XSTACK8
   \   000085   02....       LJMP    ?Subroutine3 & 0xFFFF
   1746          }
   1747          
   1748          #ifdef ZCL_DISCOVER
   1749          /*********************************************************************
   1750           * @fn      zcl_SendDiscoverCmdsCmd
   1751           *
   1752           * @brief   Send a Discover Commands command
   1753           *
   1754           * @param   dstAddr - destination address
   1755           * @param   clusterID - cluster ID
   1756           * @param   cmdType - requesting command ID
   1757           * @param   pDiscoverCmd - discover command to be sent
   1758           * @param   direction - direction of the command
   1759           * @param   seqNum - transaction sequence number
   1760           *
   1761           * @return  ZSuccess if OK
   1762           */
   1763          ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   1764                                            uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
   1765                                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1766          {
   1767            uint8 payload[2]; // size of startCmdID and maxCmdID
   1768            ZStatus_t status;
   1769          
   1770            payload[0] = pDiscoverCmd->startCmdID;
   1771            payload[1] = pDiscoverCmd->maxCmdID;
   1772          
   1773            // Send message for either commands received or generated
   1774            if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1775            {
   1776              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
   1777                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1778            }
   1779            else  // generated
   1780            {
   1781              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
   1782                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1783            }
   1784          
   1785            return ( status );
   1786          }
   1787          
   1788          /*********************************************************************
   1789           * @fn      zcl_SendDiscoverCmdsRspCmd
   1790           *
   1791           * @brief   Send a Discover Commands Response command
   1792           *
   1793           * @param   dstAddr - destination address
   1794           * @param   clusterID - cluster ID
   1795           * @param   pDiscoverRspCmd - response command to be sent
   1796           * @param   direction - direction of the command
   1797           * @param   seqNum - transaction sequence number
   1798           *
   1799           * @return  ZSuccess if OK
   1800           */
   1801          ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1802                                                uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
   1803                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1804          {
   1805            uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
   1806            uint8 *pCmdBuf;
   1807            uint8 i;
   1808            ZStatus_t status = ZSuccess;
   1809          
   1810            // allocate memory
   1811            pCmdBuf = zcl_mem_alloc( payloadSize );
   1812            if ( pCmdBuf != NULL )
   1813            {
   1814              uint8 *pBuf = pCmdBuf;
   1815          
   1816              // Load the buffer - serially
   1817              *pBuf++ = pDiscoverRspCmd->discComplete;
   1818              for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
   1819              {
   1820                *pBuf++ = pDiscoverRspCmd->pCmdID[i];
   1821              }
   1822          
   1823              // Send response message for either commands received or generated
   1824              if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1825              {
   1826                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
   1827                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1828              }
   1829              else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
   1830              {
   1831                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
   1832                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1833              }
   1834          
   1835              zcl_mem_free( pCmdBuf );
   1836            }
   1837            else
   1838            {
   1839              status = ZMemError;
   1840            }
   1841          
   1842            return ( status );
   1843          }
   1844          
   1845          /*********************************************************************
   1846           * @fn      zcl_SendDiscoverAttrsCmd
   1847           *
   1848           * @brief   Send a Discover Attributes command
   1849           *
   1850           * @param   dstAddr - destination address
   1851           * @param   clusterID - cluster ID
   1852           * @param   pDiscoverCmd - discover command to be sent
   1853           * @param   direction - direction of the command
   1854           * @param   seqNum - transaction sequence number
   1855           *
   1856           * @return  ZSuccess if OK
   1857           */
   1858          ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1859                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
   1860                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1861          {
   1862            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1863            uint8 *buf;
   1864            ZStatus_t status;
   1865          
   1866            buf = zcl_mem_alloc( dataLen );
   1867            if ( buf != NULL )
   1868            {
   1869              // Load the buffer - serially
   1870              uint8 *pBuf = buf;
   1871              *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
   1872              *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
   1873              *pBuf++ = pDiscoverCmd->maxAttrIDs;
   1874          
   1875              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
   1876                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1877              zcl_mem_free( buf );
   1878            }
   1879            else
   1880            {
   1881              status = ZMemError;
   1882            }
   1883          
   1884            return ( status );
   1885          }
   1886          
   1887          /*********************************************************************
   1888           * @fn      zcl_SendDiscoverAttrsRspCmd
   1889           *
   1890           * @brief   Send a Discover Attributes Response command
   1891           *
   1892           * @param   dstAddr - destination address
   1893           * @param   clusterID - cluster ID
   1894           * @param   reportRspCmd - report response command to be sent
   1895           * @param   direction - direction of the command
   1896           * @param   seqNum - transaction sequence number
   1897           *
   1898           * @return  ZSuccess if OK
   1899           */
   1900          ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1901                                    uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
   1902                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1903          {
   1904            uint16 dataLen = 1; // Discovery complete
   1905            uint8 *buf;
   1906            ZStatus_t status;
   1907          
   1908            // calculate the size of the command
   1909            dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1910          
   1911            buf = zcl_mem_alloc( dataLen );
   1912            if ( buf != NULL )
   1913            {
   1914              // Load the buffer - serially
   1915              uint8 i;
   1916              uint8 *pBuf = buf;
   1917          
   1918              *pBuf++ = pDiscoverRspCmd->discComplete;
   1919          
   1920              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1921              {
   1922                *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1923                *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1924                *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
   1925              }
   1926          
   1927              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
   1928                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1929              zcl_mem_free( buf );
   1930            }
   1931            else
   1932            {
   1933              status = ZMemError;
   1934            }
   1935          
   1936            return ( status );
   1937          }
   1938          
   1939          /*********************************************************************
   1940           * @fn      zcl_SendDiscoverAttrsExt
   1941           *
   1942           * @brief   Send a Discover Attributes Extended command
   1943           *
   1944           * @param   dstAddr - destination address
   1945           * @param   clusterID - cluster ID
   1946           * @param   pDiscoverAttrsExt:
   1947           *            - startAttrID: the first attribute to be selected
   1948           *            - maxAttrIDs: maximum number of returned attributes
   1949           * @param   direction - direction of the command
   1950           * @param   seqNum - transaction sequence number
   1951           *
   1952           * @return  ZSuccess if OK
   1953           */
   1954          ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
   1955                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
   1956                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1957          {
   1958            uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
   1959            ZStatus_t status;
   1960          
   1961            // Load the buffer - serially
   1962            buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
   1963            buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
   1964            buf[2] = pDiscoverAttrsExt->maxAttrIDs;
   1965          
   1966            status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
   1967                                      direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
   1968          
   1969            return ( status );
   1970          }
   1971          
   1972          /*********************************************************************
   1973           * @fn      zcl_SendDiscoverAttrsExtRsp
   1974           *
   1975           * @brief   Send a Discover Attributes Extended Response command
   1976           *
   1977           * @param   dstAddr - destination address
   1978           * @param   clusterID - cluster ID
   1979           * @param   pDiscoverRspCmd:
   1980           *            - discComplete: indicates whether all requested attributes returned
   1981           *            - attrID: attribute ID
   1982           *            - attrDataType: data type of the given attribute
   1983           *            - attrAccessControl: access control of the given attribute
   1984           * @param   direction - direction of the command
   1985           * @param   seqNum - transaction sequence number
   1986           *
   1987           * @return  ZSuccess if OK
   1988           */
   1989          ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
   1990                                                uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
   1991                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1992          {
   1993            uint8 *buf;
   1994            uint8 i;
   1995            uint16 dataLen = 1; // Discovery complete
   1996            ZStatus_t status;
   1997          
   1998            // calculate the size of the command
   1999            dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
   2000          
   2001            buf = zcl_mem_alloc( dataLen );
   2002            if ( buf != NULL )
   2003            {
   2004              // Load the buffer - serially
   2005              uint8 *pBuf = buf;
   2006              *pBuf++ = pDiscoverRspCmd->discComplete;
   2007              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   2008              {
   2009                *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   2010                *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   2011                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
   2012                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
   2013              }
   2014          
   2015              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
   2016                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   2017              zcl_mem_free( buf );
   2018            }
   2019            else
   2020            {
   2021              status = ZMemError;
   2022            }
   2023          
   2024            return ( status );
   2025          }
   2026          #endif // ZCL_DISCOVER
   2027          
   2028          /*********************************************************************
   2029           * @fn      zcl_ProcessMessageMSG
   2030           *
   2031           * @brief   Data message processor callback.  This function processes
   2032           *          any incoming data - probably from other devices.  So, based
   2033           *          on cluster ID, perform the intended action.
   2034           *
   2035           * @param   pkt - incoming message
   2036           *
   2037           * @return  zclProcMsgStatus_t
   2038           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2039          zclProcMsgStatus_t zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zcl_ProcessMessageMSG:
   2040          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2041            endPointDesc_t *epDesc;
   2042            zclIncoming_t inMsg;
   2043            zclLibPlugin_t *pInPlugin;
   2044            zclDefaultRspCmd_t defautlRspCmd;
   2045            uint8 options;
   2046            uint8 securityEnable;
   2047            uint8 interPanMsg;
   2048            ZStatus_t status = ZFailure;
   2049            uint8 defaultResponseSent = FALSE;
   \   00000E   C2..         CLR     ?VB.0
   2050          
   2051            if ( pkt->cmd.DataLength == 0 )
   \   000010   EE           MOV     A,R6
   \   000011   2420         ADD     A,#0x20
   \   000013   F8           MOV     R0,A
   \   000014   E4           CLR     A
   \   000015   3F           ADDC    A,R7
   \   000016   F9           MOV     R1,A
   \   000017   88..         MOV     ?V0,R0
   \   000019   89..         MOV     ?V1,R1
   \   00001B   8882         MOV     DPL,R0
   \   00001D   F583         MOV     DPH,A
   \   00001F   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_372:
   \   000022   7005         JNZ     ??zcl_ProcessMessageMSG_0
   2052            {
   2053              return ( ZCL_PROC_INVALID );   // Error, ignore the message
   \   000024   7901         MOV     R1,#0x1
   \   000026   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2054            }
   2055          
   2056            // Initialize
   2057            rawAFMsg = (afIncomingMSGPacket_t *)pkt;
   \                     ??zcl_ProcessMessageMSG_0:
   \   000029   90....       MOV     DPTR,#rawAFMsg
   \   00002C   EE           MOV     A,R6
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   EF           MOV     A,R7
   \   000030   F0           MOVX    @DPTR,A
   2058            inMsg.msg = pkt;
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   EE           MOV     A,R6
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   EF           MOV     A,R7
   \   00003A   F0           MOVX    @DPTR,A
   2059            inMsg.attrCmd = NULL;
   \   00003B   740E         MOV     A,#0xe
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   E4           CLR     A
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   F0           MOVX    @DPTR,A
   2060            inMsg.pData = NULL;
   \   000044   740A         MOV     A,#0xa
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   E4           CLR     A
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   F0           MOVX    @DPTR,A
   2061            inMsg.pDataLen = 0;
   \   00004D   740C         MOV     A,#0xc
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   E4           CLR     A
   \   000053   F0           MOVX    @DPTR,A
   \   000054   A3           INC     DPTR
   \   000055   F0           MOVX    @DPTR,A
   2062          
   2063            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   000056   EE           MOV     A,R6
   \   000057   2422         ADD     A,#0x22
   \   000059   F8           MOV     R0,A
   \   00005A   E4           CLR     A
   \   00005B   3F           ADDC    A,R7
   \   00005C   F9           MOV     R1,A
   \   00005D   88..         MOV     ?V2,R0
   \   00005F   89..         MOV     ?V3,R1
   \   000061                ; Setup parameters for call to function zclParseHdr
   \   000061   8882         MOV     DPL,R0
   \   000063   F583         MOV     DPH,A
   \   000065   12....       LCALL   ??Subroutine213_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_483:
   \   000068   7404         MOV     A,#0x4
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   AA82         MOV     R2,DPL
   \   00006F   AB83         MOV     R3,DPH
   \   000071   12....       LCALL   `??zclParseHdr::?relay`; Banked call to: zclParseHdr
   \   000074   8A..         MOV     ?V4,R2
   \   000076   8B..         MOV     ?V5,R3
   \   000078   A8..         MOV     R0,?V4
   \   00007A   A9..         MOV     R1,?V5
   \   00007C   740A         MOV     A,#0xa
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   12....       LCALL   ??Subroutine209_0 & 0xFFFF
   2064            inMsg.pDataLen = pkt->cmd.DataLength;
   2065            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_463:
   \   000084   85..82       MOV     DPL,?V0
   \   000087   85..83       MOV     DPH,?V1
   \   00008A   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_389:
   \   00008D   EA           MOV     A,R2
   \   00008E   C3           CLR     C
   \   00008F   98           SUBB    A,R0
   \   000090   F8           MOV     R0,A
   \   000091   EB           MOV     A,R3
   \   000092   99           SUBB    A,R1
   \   000093   F9           MOV     R1,A
   \   000094   85..82       MOV     DPL,?V2
   \   000097   85..83       MOV     DPH,?V3
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   28           ADD     A,R0
   \   00009C   F8           MOV     R0,A
   \   00009D   A3           INC     DPTR
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   39           ADDC    A,R1
   \   0000A0   F9           MOV     R1,A
   \   0000A1   740C         MOV     A,#0xc
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   12....       LCALL   ??Subroutine209_0 & 0xFFFF
   2066          
   2067            // Temporary workaround to allow callback functions access to the 
   2068            // transaction sequence number.  Callback functions will call 
   2069            // zcl_getParsedTransSeqNum() to retrieve this number.
   2070            savedZCLTransSeqNum = inMsg.hdr.transSeqNum;
   \                     ??CrossCallReturnLabel_464:
   \   0000A9   7408         MOV     A,#0x8
   \   0000AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AE   E0           MOVX    A,@DPTR
   \   0000AF   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   0000B2   F0           MOVX    @DPTR,A
   2071            
   2072            // Find the wanted endpoint
   2073            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   0000B3   EE           MOV     A,R6
   \   0000B4   2414         ADD     A,#0x14
   \   0000B6   F5..         MOV     ?V0,A
   \   0000B8   E4           CLR     A
   \   0000B9   3F           ADDC    A,R7
   \   0000BA   F5..         MOV     ?V1,A
   \   0000BC                ; Setup parameters for call to function afFindEndPointDesc
   \   0000BC   85..82       MOV     DPL,?V0
   \   0000BF   F583         MOV     DPH,A
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   F9           MOV     R1,A
   \   0000C3   12....       LCALL   `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   \   0000C6   8A82         MOV     DPL,R2
   \   0000C8   8B83         MOV     DPH,R3
   2074            if ( epDesc == NULL )
   \   0000CA   E582         MOV     A,DPL
   \   0000CC   4583         ORL     A,DPH
   \   0000CE   700C         JNZ     ??zcl_ProcessMessageMSG_2
   2075            {
   2076              rawAFMsg = NULL;
   \   0000D0   90....       MOV     DPTR,#rawAFMsg
   \   0000D3   E4           CLR     A
   \   0000D4   F0           MOVX    @DPTR,A
   \   0000D5   A3           INC     DPTR
   \   0000D6   F0           MOVX    @DPTR,A
   2077              return ( ZCL_PROC_EP_NOT_FOUND );   // Error, ignore the message
   \   0000D7   7902         MOV     R1,#0x2
   \   0000D9   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2078            }
   2079          
   2080            if ( ( epDesc->simpleDesc == NULL ) ||
   2081                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   2082                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??zcl_ProcessMessageMSG_2:
   \   0000DC   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_347:
   \   0000DF   602B         JZ      ??zcl_ProcessMessageMSG_3
   \   0000E1   EE           MOV     A,R6
   \   0000E2   2404         ADD     A,#0x4
   \   0000E4   F5..         MOV     ?V2,A
   \   0000E6   E4           CLR     A
   \   0000E7   3F           ADDC    A,R7
   \   0000E8   F5..         MOV     ?V3,A
   \   0000EA                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000EA   A3           INC     DPTR
   \   0000EB   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000EE   740B         MOV     A,#0xb
   \   0000F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   FD           MOV     R5,A
   \   0000F5   7406         MOV     A,#0x6
   \   0000F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   5403         ANL     A,#0x3
   \   0000FD   FC           MOV     R4,A
   \   0000FE   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000101   12....       LCALL   `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   000104   7402         MOV     A,#0x2
   \   000106   12....       LCALL   ?DEALLOC_XSTACK8
   \   000109   E9           MOV     A,R1
   \   00010A   700C         JNZ     ??zcl_ProcessMessageMSG_4
   2083            {
   2084              rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_3:
   \   00010C   90....       MOV     DPTR,#rawAFMsg
   \   00010F   E4           CLR     A
   \   000110   F0           MOVX    @DPTR,A
   \   000111   A3           INC     DPTR
   \   000112   F0           MOVX    @DPTR,A
   2085              return ( ZCL_PROC_NOT_OPERATIONAL ); // Error, ignore the message
   \   000113   7903         MOV     R1,#0x3
   \   000115   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2086            }
   2087          
   2088          #if defined ( INTER_PAN )
   2089            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   2090            {
   2091              // No foundation command is supported thru Inter-PAN communication.
   2092              // But the Light Link cluster uses a different Frame Control format
   2093              // for it's Inter-PAN messages, where the messages could be confused
   2094              // with the foundation commands.
   2095              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   2096              {
   2097                rawAFMsg = NULL;
   2098                return ( ZCL_PROC_INTERPAN_FOUNDATION_CMD );
   2099              }
   2100          
   2101              interPanMsg = TRUE;
   2102              options = AF_TX_OPTIONS_NONE;
   2103            }
   2104            else
   2105          #endif
   2106            {
   2107              interPanMsg = FALSE;
   2108              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \                     ??zcl_ProcessMessageMSG_4:
   \   000118                ; Setup parameters for call to function zclGetClusterOption
   \   000118   12....       LCALL   ?Subroutine58 & 0xFFFF
   2109            }
   \                     ??CrossCallReturnLabel_95:
   \   00011B   12....       LCALL   `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   00011E   E9           MOV     A,R1
   \   00011F   F5..         MOV     ?V6,A
   2110          
   2111            // Find the appropriate plugin
   2112            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \   000121   85..82       MOV     DPL,?V2
   \   000124   85..83       MOV     DPH,?V3
   \   000127   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_390:
   \   00012A   EA           MOV     A,R2
   \   00012B   FC           MOV     R4,A
   \   00012C   EB           MOV     A,R3
   \   00012D   FD           MOV     R5,A
   \   00012E   90....       MOV     DPTR,#plugins
   \   000131   8004         SJMP    ??zcl_ProcessMessageMSG_5
   \                     ??zcl_ProcessMessageMSG_6:
   \   000133   8882         MOV     DPL,R0
   \   000135   8983         MOV     DPH,R1
   \                     ??zcl_ProcessMessageMSG_5:
   \   000137   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_373:
   \   00013A   7003         JNZ     $+5
   \   00013C   02....       LJMP    ??zcl_ProcessMessageMSG_7 & 0xFFFF
   \   00013F   8882         MOV     DPL,R0
   \   000141   8983         MOV     DPH,R1
   \   000143   A3           INC     DPTR
   \   000144   A3           INC     DPTR
   \   000145   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   000148   C3           CLR     C
   \   000149   EC           MOV     A,R4
   \   00014A   95..         SUBB    A,?V4
   \   00014C   ED           MOV     A,R5
   \   00014D   95..         SUBB    A,?V5
   \   00014F   40E2         JC      ??zcl_ProcessMessageMSG_6
   \   000151   8882         MOV     DPL,R0
   \   000153   8983         MOV     DPH,R1
   \   000155   A3           INC     DPTR
   \   000156   A3           INC     DPTR
   \   000157   A3           INC     DPTR
   \   000158   A3           INC     DPTR
   \   000159   C3           CLR     C
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   9C           SUBB    A,R4
   \   00015C   A3           INC     DPTR
   \   00015D   E0           MOVX    A,@DPTR
   \   00015E   9D           SUBB    A,R5
   \   00015F   40D2         JC      ??zcl_ProcessMessageMSG_6
   \   000161   E8           MOV     A,R0
   \   000162   FC           MOV     R4,A
   \   000163   E9           MOV     A,R1
   \   000164   FD           MOV     R5,A
   \   000165   7404         MOV     A,#0x4
   \   000167   12....       LCALL   ?XSTACK_DISP0_8
   \   00016A   E0           MOVX    A,@DPTR
   \   00016B   5407         ANL     A,#0x7
   \   00016D   700D         JNZ     ??zcl_ProcessMessageMSG_8
   \   00016F   7409         MOV     A,#0x9
   \   000171   12....       LCALL   ?XSTACK_DISP0_8
   \   000174   E0           MOVX    A,@DPTR
   \   000175   640B         XRL     A,#0xb
   \   000177   7003         JNZ     $+5
   \   000179   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   2113          
   2114            // Local and remote Security options must match except for Default Response command
   2115            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   2116            {
   2117              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zcl_ProcessMessageMSG_8:
   \   00017C   E5..         MOV     A,?V6
   \   00017E   A2E6         MOV     C,0xE0 /* A   */.6
   \   000180   4003         JC      $+5
   \   000182   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   \   000185   EE           MOV     A,R6
   \   000186   2419         ADD     A,#0x19
   \   000188   F582         MOV     DPL,A
   \   00018A   E4           CLR     A
   \   00018B   3F           ADDC    A,R7
   \   00018C   F583         MOV     DPH,A
   \   00018E   E0           MOVX    A,@DPTR
   \   00018F   6003         JZ      $+5
   \   000191   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   2118          
   2119              // Make sure that Clusters specifically defined to use security are received secure,
   2120              // any other cluster that wants to use APS security will be allowed
   2121              if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
   2122              {
   2123                if ( UNICAST_MSG( inMsg.msg ) )
   \   000194   7402         MOV     A,#0x2
   \   000196   12....       LCALL   ?XSTACK_DISP0_8
   \   000199   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   00019C   6003         JZ      $+5
   \   00019E   02....       LJMP    ??zcl_ProcessMessageMSG_10 & 0xFFFF
   \   0001A1   7402         MOV     A,#0x2
   \   0001A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A6   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_379:
   \   0001A9   7079         JNZ     ??zcl_ProcessMessageMSG_10
   2124                {
   2125                  // Send a Default Response command back with no Application Link Key security
   2126                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   0001AB                ; Setup parameters for call to function zclSetSecurityOption
   \   0001AB   7C00         MOV     R4,#0x0
   \   0001AD   85..82       MOV     DPL,?V0
   \   0001B0   85..83       MOV     DPH,?V1
   \   0001B3   E0           MOVX    A,@DPTR
   \   0001B4   F9           MOV     R1,A
   \   0001B5   12....       LCALL   `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   2127          
   2128                  defautlRspCmd.statusCode = status;
   \   0001B8   7401         MOV     A,#0x1
   \   0001BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BD   7401         MOV     A,#0x1
   \   0001BF   F0           MOVX    @DPTR,A
   2129                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0001C0   7409         MOV     A,#0x9
   \   0001C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C5   12....       LCALL   ?Subroutine92 & 0xFFFF
   2130                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2131                                         inMsg.msg->clusterId, &defautlRspCmd,
   2132                                         !inMsg.hdr.fc.direction, true,
   2133                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_155:
   \   0001C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CB   E0           MOVX    A,@DPTR
   \   0001CC   F5..         MOV     ?V4,A
   \   0001CE   78..         MOV     R0,#?V4
   \   0001D0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001D3   7407         MOV     A,#0x7
   \   0001D5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D8   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001DB   75..01       MOV     ?V4,#0x1
   \   0001DE   78..         MOV     R0,#?V4
   \   0001E0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001E3   7408         MOV     A,#0x8
   \   0001E5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E8   12....       LCALL   ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_480:
   \   0001EB   F5..         MOV     ?V4,A
   \   0001ED   78..         MOV     R0,#?V4
   \   0001EF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001F2   7405         MOV     A,#0x5
   \   0001F4   12....       LCALL   ?XSTACK_DISP100_8
   \   0001F7   88..         MOV     ?V4,R0
   \   0001F9   89..         MOV     ?V5,R1
   \   0001FB   78..         MOV     R0,#?V4
   \   0001FD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000200   7409         MOV     A,#0x9
   \   000202   12....       LCALL   ?XSTACK_DISP0_8
   \   000205   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000208   12....       LCALL   ?XSTACK_DISP0_8
   \   00020B   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   00020E   12....       LCALL   ?XSTACK_DISP0_8
   \   000211   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000214   12....       LCALL   `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   000217   7407         MOV     A,#0x7
   \   000219   12....       LCALL   ?DEALLOC_XSTACK8
   2134          
   2135                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   00021C                ; Setup parameters for call to function zclSetSecurityOption
   \   00021C   7C01         MOV     R4,#0x1
   \   00021E   12....       LCALL   ?Subroutine58 & 0xFFFF
   2136                }
   \                     ??CrossCallReturnLabel_96:
   \   000221   12....       LCALL   `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   2137          
   2138                rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_10:
   \   000224   90....       MOV     DPTR,#rawAFMsg
   \   000227   E4           CLR     A
   \   000228   F0           MOVX    @DPTR,A
   \   000229   A3           INC     DPTR
   \   00022A   F0           MOVX    @DPTR,A
   2139                return ( ZCL_PROC_NOT_SECURE );   // Error, ignore the message
   \   00022B   7905         MOV     R1,#0x5
   \   00022D   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2140              }
   2141            }
   \                     ??zcl_ProcessMessageMSG_7:
   \   000230   7C00         MOV     R4,#0x0
   \   000232   7D00         MOV     R5,#0x0
   2142          
   2143            // Is this a foundation type message
   2144            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zcl_ProcessMessageMSG_9:
   \   000234   7404         MOV     A,#0x4
   \   000236   12....       LCALL   ?XSTACK_DISP0_8
   \   000239   E0           MOVX    A,@DPTR
   \   00023A   F8           MOV     R0,A
   \   00023B   5403         ANL     A,#0x3
   \   00023D   6003         JZ      $+5
   \   00023F   02....       LJMP    ??zcl_ProcessMessageMSG_11 & 0xFFFF
   2145            {
   2146              if ( inMsg.hdr.fc.manuSpecific )
   \   000242   E8           MOV     A,R0
   \   000243   5404         ANL     A,#0x4
   \   000245   6005         JZ      ??zcl_ProcessMessageMSG_12
   2147              {
   2148                // We don't support any manufacturer specific command
   2149                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   000247   7E84         MOV     R6,#-0x7c
   \   000249   02....       LJMP    ??zcl_ProcessMessageMSG_13 & 0xFFFF
   2150              }
   2151              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   2152                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zcl_ProcessMessageMSG_12:
   \   00024C   7409         MOV     A,#0x9
   \   00024E   12....       LCALL   ?XSTACK_DISP0_8
   \   000251   E0           MOVX    A,@DPTR
   \   000252   F5..         MOV     ?V2,A
   \   000254   C3           CLR     C
   \   000255   9417         SUBB    A,#0x17
   \   000257   4003         JC      $+5
   \   000259   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   \   00025C   75..00       MOV     ?V3,#0x0
   \   00025F   7402         MOV     A,#0x2
   \   000261   78..         MOV     R0,#?V2
   \   000263   12....       LCALL   ?S_SHL
   \   000266   74..         MOV     A,#zclCmdTable & 0xff
   \   000268   25..         ADD     A,?V2
   \   00026A   F582         MOV     DPL,A
   \   00026C   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   00026E   35..         ADDC    A,?V3
   \   000270   F583         MOV     DPH,A
   \   000272   E4           CLR     A
   \   000273   93           MOVC    A,@A+DPTR
   \   000274   F8           MOV     R0,A
   \   000275   7401         MOV     A,#0x1
   \   000277   93           MOVC    A,@A+DPTR
   \   000278   F9           MOV     R1,A
   \   000279   E8           MOV     A,R0
   \   00027A   49           ORL     A,R1
   \   00027B   7003         JNZ     $+5
   \   00027D   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   2153              {
   2154                zclParseCmd_t parseCmd;
   2155          
   2156                parseCmd.endpoint = pkt->endPoint;
   \   000280   85..82       MOV     DPL,?V0
   \   000283   85..83       MOV     DPH,?V1
   \   000286   E0           MOVX    A,@DPTR
   \   000287   C0E0         PUSH    A
   \   000289   7410         MOV     A,#0x10
   \   00028B   12....       LCALL   ?XSTACK_DISP0_8
   \   00028E   D0E0         POP     A
   \   000290   F0           MOVX    @DPTR,A
   2157                parseCmd.dataLen = inMsg.pDataLen;
   \   000291   740C         MOV     A,#0xc
   \   000293   12....       LCALL   ?XSTACK_DISP0_8
   \   000296   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_391:
   \   000299   7411         MOV     A,#0x11
   \   00029B   12....       LCALL   ?XSTACK_DISP0_8
   \   00029E   12....       LCALL   ??Subroutine222_0 & 0xFFFF
   2158                parseCmd.pData = inMsg.pData;
   \                     ??CrossCallReturnLabel_537:
   \   0002A1   740A         MOV     A,#0xa
   \   0002A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A6   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_392:
   \   0002A9   7413         MOV     A,#0x13
   \   0002AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0002AE   12....       LCALL   ??Subroutine222_0 & 0xFFFF
   2159          
   2160                // Parse the command, remember that the return value is a pointer to allocated memory
   2161                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \                     ??CrossCallReturnLabel_538:
   \   0002B1                ; Setup parameters for indirect call
   \   0002B1   7410         MOV     A,#0x10
   \   0002B3   12....       LCALL   ?XSTACK_DISP101_8
   \   0002B6   8882         MOV     DPL,R0
   \   0002B8   8983         MOV     DPH,R1
   \   0002BA   12....       LCALL   ?CALL_IND
   \   0002BD   8A..         MOV     ?V0,R2
   \   0002BF   8B..         MOV     ?V1,R3
   \   0002C1   A8..         MOV     R0,?V0
   \   0002C3   A9..         MOV     R1,?V1
   \   0002C5   740E         MOV     A,#0xe
   \   0002C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0002CA   12....       LCALL   ??Subroutine209_0 & 0xFFFF
   2162                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \                     ??CrossCallReturnLabel_465:
   \   0002CD   E8           MOV     A,R0
   \   0002CE   49           ORL     A,R1
   \   0002CF   604C         JZ      ??zcl_ProcessMessageMSG_15
   \   0002D1   7409         MOV     A,#0x9
   \   0002D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D6   E0           MOVX    A,@DPTR
   \   0002D7   F5..         MOV     ?V0,A
   \   0002D9   75..00       MOV     ?V1,#0x0
   \   0002DC   7402         MOV     A,#0x2
   \   0002DE   78..         MOV     R0,#?V0
   \   0002E0   12....       LCALL   ?S_SHL
   \   0002E3   74..         MOV     A,#(zclCmdTable + 2) & 0xff
   \   0002E5   25..         ADD     A,?V0
   \   0002E7   F582         MOV     DPL,A
   \   0002E9   74..         MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
   \   0002EB   35..         ADDC    A,?V1
   \   0002ED   F583         MOV     DPH,A
   \   0002EF   E4           CLR     A
   \   0002F0   93           MOVC    A,@A+DPTR
   \   0002F1   F8           MOV     R0,A
   \   0002F2   7401         MOV     A,#0x1
   \   0002F4   93           MOVC    A,@A+DPTR
   \   0002F5   F9           MOV     R1,A
   \   0002F6   8882         MOV     DPL,R0
   \   0002F8   8983         MOV     DPH,R1
   \   0002FA   E582         MOV     A,DPL
   \   0002FC   4583         ORL     A,DPH
   \   0002FE   6012         JZ      ??zcl_ProcessMessageMSG_16
   2163                {
   2164                  // Process the command
   2165                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   000300                ; Setup parameters for indirect call
   \   000300   7402         MOV     A,#0x2
   \   000302   12....       LCALL   ?XSTACK_DISP101_8
   \   000305   12....       LCALL   ?CALL_IND
   2166                  {
   2167                    // Couldn't find attribute in the table.
   2168                  }
   2169                }
   2170          
   2171                // Free the buffer
   2172                if ( inMsg.attrCmd )
   \   000308   740E         MOV     A,#0xe
   \   00030A   12....       LCALL   ?XSTACK_DISP0_8
   \   00030D   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_374:
   \   000310   600B         JZ      ??zcl_ProcessMessageMSG_15
   2173                {
   2174                  zcl_mem_free( inMsg.attrCmd );
   \                     ??zcl_ProcessMessageMSG_16:
   \   000312                ; Setup parameters for call to function osal_mem_free
   \   000312   740E         MOV     A,#0xe
   \   000314   12....       LCALL   ?XSTACK_DISP0_8
   \   000317   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   2175                }
   \                     ??CrossCallReturnLabel_393:
   \   00031A   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2176          
   2177                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zcl_ProcessMessageMSG_15:
   \   00031D   7409         MOV     A,#0x9
   \   00031F   12....       LCALL   ?XSTACK_DISP0_8
   \   000322   E0           MOVX    A,@DPTR
   \   000323   F8           MOV     R0,A
   \   000324   6054         JZ      ??zcl_ProcessMessageMSG_17
   \   000326   7402         MOV     A,#0x2
   \   000328   68           XRL     A,R0
   \   000329   604F         JZ      ??zcl_ProcessMessageMSG_17
   \   00032B   7403         MOV     A,#0x3
   \   00032D   68           XRL     A,R0
   \   00032E   604A         JZ      ??zcl_ProcessMessageMSG_17
   \   000330   7406         MOV     A,#0x6
   \   000332   68           XRL     A,R0
   \   000333   6045         JZ      ??zcl_ProcessMessageMSG_17
   \   000335   7408         MOV     A,#0x8
   \   000337   68           XRL     A,R0
   \   000338   6040         JZ      ??zcl_ProcessMessageMSG_17
   \   00033A   740C         MOV     A,#0xc
   \   00033C   68           XRL     A,R0
   \   00033D   603B         JZ      ??zcl_ProcessMessageMSG_17
   \   00033F   7411         MOV     A,#0x11
   \   000341   68           XRL     A,R0
   \   000342   6036         JZ      ??zcl_ProcessMessageMSG_17
   \   000344   7413         MOV     A,#0x13
   \   000346   68           XRL     A,R0
   \   000347   6031         JZ      ??zcl_ProcessMessageMSG_17
   \   000349   7415         MOV     A,#0x15
   \   00034B   68           XRL     A,R0
   \   00034C   602C         JZ      ??zcl_ProcessMessageMSG_17
   \   00034E   740B         MOV     A,#0xb
   \   000350   68           XRL     A,R0
   \   000351   6027         JZ      ??zcl_ProcessMessageMSG_17
   2178                {
   2179                  rawAFMsg = NULL;
   2180                  return ( ZCL_PROC_SUCCESS ); // We're done
   2181                }
   2182          
   2183                status = ZSuccess;
   \   000353   7E00         MOV     R6,#0x0
   \   000355   8043         SJMP    ??zcl_ProcessMessageMSG_13
   2184              }
   2185              else
   2186              {
   2187                // Unsupported message
   2188                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zcl_ProcessMessageMSG_14:
   \   000357   7E82         MOV     R6,#-0x7e
   \   000359   803F         SJMP    ??zcl_ProcessMessageMSG_13
   2189              }
   2190            }
   2191            else  // Not a foundation type message, so it must be specific to the cluster ID.
   2192            {
   2193              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zcl_ProcessMessageMSG_11:
   \   00035B   EC           MOV     A,R4
   \   00035C   4D           ORL     A,R5
   \   00035D   602B         JZ      ??zcl_ProcessMessageMSG_18
   \   00035F   8C82         MOV     DPL,R4
   \   000361   8D83         MOV     DPH,R5
   \   000363   A3           INC     DPTR
   \   000364   A3           INC     DPTR
   \   000365   A3           INC     DPTR
   \   000366   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_348:
   \   000369   601F         JZ      ??zcl_ProcessMessageMSG_18
   2194              {
   2195                // The return value of the plugin function will be
   2196                //  ZSuccess - Supported and need default response
   2197                //  ZFailure - Unsupported
   2198                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   2199                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   2200                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   2201                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   2202                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   00036B                ; Setup parameters for indirect call
   \   00036B   7402         MOV     A,#0x2
   \   00036D   12....       LCALL   ?XSTACK_DISP101_8
   \   000370   12....       LCALL   ?CALL_IND
   \   000373   E9           MOV     A,R1
   \   000374   FE           MOV     R6,A
   2203                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   000375   74FF         MOV     A,#-0x1
   \   000377   6E           XRL     A,R6
   \   000378   700B         JNZ     ??zcl_ProcessMessageMSG_19
   2204                {
   2205                  rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_17:
   \   00037A   90....       MOV     DPTR,#rawAFMsg
   \   00037D   E4           CLR     A
   \   00037E   F0           MOVX    @DPTR,A
   \   00037F   A3           INC     DPTR
   \   000380   F0           MOVX    @DPTR,A
   2206                  return ( ZCL_PROC_SUCCESS ); // We're done
   \   000381   F9           MOV     R1,A
   \   000382   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2207                }
   2208              }
   2209          
   2210              if ( status == ZFailure )
   \                     ??zcl_ProcessMessageMSG_19:
   \   000385   7401         MOV     A,#0x1
   \   000387   6E           XRL     A,R6
   \   000388   7010         JNZ     ??zcl_ProcessMessageMSG_13
   2211              {
   2212                // Unsupported message
   2213                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zcl_ProcessMessageMSG_18:
   \   00038A   7404         MOV     A,#0x4
   \   00038C   12....       LCALL   ?XSTACK_DISP0_8
   \   00038F   E0           MOVX    A,@DPTR
   \   000390   5404         ANL     A,#0x4
   \   000392   6004         JZ      ??zcl_ProcessMessageMSG_20
   2214                {
   2215                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   000394   7E83         MOV     R6,#-0x7d
   \   000396   8002         SJMP    ??zcl_ProcessMessageMSG_13
   2216                }
   2217                else
   2218                {
   2219                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zcl_ProcessMessageMSG_20:
   \   000398   7E81         MOV     R6,#-0x7f
   2220                }
   2221              }
   2222            }
   2223          
   2224            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zcl_ProcessMessageMSG_13:
   \   00039A   7402         MOV     A,#0x2
   \   00039C   12....       LCALL   ?XSTACK_DISP0_8
   \   00039F   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   0003A2   707A         JNZ     ??zcl_ProcessMessageMSG_21
   \   0003A4   7402         MOV     A,#0x2
   \   0003A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A9   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_380:
   \   0003AC   7070         JNZ     ??zcl_ProcessMessageMSG_21
   \   0003AE   7404         MOV     A,#0x4
   \   0003B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B3   E0           MOVX    A,@DPTR
   \   0003B4   FA           MOV     R2,A
   \   0003B5   5410         ANL     A,#0x10
   \   0003B7   7065         JNZ     ??zcl_ProcessMessageMSG_21
   2225            {
   2226              // Send a Default Response command back
   2227              defautlRspCmd.statusCode = status;
   \   0003B9   7401         MOV     A,#0x1
   \   0003BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0003BE   EE           MOV     A,R6
   \   0003BF   F0           MOVX    @DPTR,A
   2228              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0003C0   7409         MOV     A,#0x9
   \   0003C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0003C5   12....       LCALL   ?Subroutine92 & 0xFFFF
   2229              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2230                                     inMsg.msg->clusterId, &defautlRspCmd,
   2231                                     !inMsg.hdr.fc.direction, true,
   2232                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_156:
   \   0003C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0003CB   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   0003CE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003D1   7407         MOV     A,#0x7
   \   0003D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0003D6   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0003D9   75..01       MOV     ?V0,#0x1
   \   0003DC   78..         MOV     R0,#?V0
   \   0003DE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003E1   EA           MOV     A,R2
   \   0003E2   13           RRC     A
   \   0003E3   13           RRC     A
   \   0003E4   13           RRC     A
   \   0003E5   541F         ANL     A,#0x1f
   \   0003E7   6401         XRL     A,#0x1
   \   0003E9   5401         ANL     A,#0x1
   \   0003EB   F5..         MOV     ?V0,A
   \   0003ED   78..         MOV     R0,#?V0
   \   0003EF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003F2   7405         MOV     A,#0x5
   \   0003F4   12....       LCALL   ?XSTACK_DISP100_8
   \   0003F7   88..         MOV     ?V0,R0
   \   0003F9   89..         MOV     ?V1,R1
   \   0003FB   78..         MOV     R0,#?V0
   \   0003FD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000400   7409         MOV     A,#0x9
   \   000402   12....       LCALL   ?XSTACK_DISP0_8
   \   000405   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000408   12....       LCALL   ?XSTACK_DISP0_8
   \   00040B   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   00040E   12....       LCALL   ?XSTACK_DISP0_8
   \   000411   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000414   12....       LCALL   `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   000417   7407         MOV     A,#0x7
   \   000419   12....       LCALL   ?DEALLOC_XSTACK8
   2233              defaultResponseSent = TRUE;
   \   00041C   D2..         SETB    ?VB.0
   2234            }
   2235          
   2236            rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_21:
   \   00041E   90....       MOV     DPTR,#rawAFMsg
   \   000421   E4           CLR     A
   \   000422   F0           MOVX    @DPTR,A
   \   000423   A3           INC     DPTR
   \   000424   F0           MOVX    @DPTR,A
   2237            if ( status == ZSuccess )
   \   000425   EE           MOV     A,R6
   \   000426   7004         JNZ     ??zcl_ProcessMessageMSG_22
   2238            {
   2239              return ( ZCL_PROC_SUCCESS );
   \   000428   7900         MOV     R1,#0x0
   \   00042A   8019         SJMP    ??zcl_ProcessMessageMSG_1
   2240            }
   2241            else if ( status == ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND )
   \                     ??zcl_ProcessMessageMSG_22:
   \   00042C   7484         MOV     A,#-0x7c
   \   00042E   6E           XRL     A,R6
   \   00042F   A2..         MOV     C,?VB.0
   \   000431   700A         JNZ     ??zcl_ProcessMessageMSG_23
   2242            {
   2243              if ( defaultResponseSent )
   \   000433   5004         JNC     ??zcl_ProcessMessageMSG_24
   2244              {
   2245                return ( ZCL_PROC_MANUFACTURER_SPECIFIC_DR );
   \   000435   7907         MOV     R1,#0x7
   \   000437   800C         SJMP    ??zcl_ProcessMessageMSG_1
   2246              }
   2247              else
   2248              {
   2249                return ( ZCL_PROC_MANUFACTURER_SPECIFIC );
   \                     ??zcl_ProcessMessageMSG_24:
   \   000439   7906         MOV     R1,#0x6
   \   00043B   8008         SJMP    ??zcl_ProcessMessageMSG_1
   2250              }
   2251            }
   2252            else
   2253            {
   2254              if ( defaultResponseSent )
   \                     ??zcl_ProcessMessageMSG_23:
   \   00043D   5004         JNC     ??zcl_ProcessMessageMSG_25
   2255              {
   2256                return ( ZCL_PROC_NOT_HANDLED_DR );
   \   00043F   7909         MOV     R1,#0x9
   \   000441   8002         SJMP    ??zcl_ProcessMessageMSG_1
   2257              }
   2258              else
   2259              {
   2260                return ( ZCL_PROC_NOT_HANDLED );
   \                     ??zcl_ProcessMessageMSG_25:
   \   000443   7908         MOV     R1,#0x8
   \                     ??zcl_ProcessMessageMSG_1:
   \   000445   7415         MOV     A,#0x15
   \   000447   12....       LCALL   ?DEALLOC_XSTACK8
   2261              }
   2262            }
   \   00044A   02....       LJMP    ?Subroutine8 & 0xFFFF
   2263          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008   7408         MOV     A,#0x8
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   7409         MOV     A,#0x9
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   C8           XCH     A,R0
   \   000003   12....       LCALL   ?Subroutine166 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   000006   38           ADDC    A,R0
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   12....       LCALL   ?Subroutine172 & 0xFFFF
   \                     ??CrossCallReturnLabel_512:
   \   000003   C8           XCH     A,R0
   \   000004   2415         ADD     A,#0x15
   \   000006   F582         MOV     DPL,A
   \   000008   E4           CLR     A
   \   000009   38           ADDC    A,R0
   \   00000A   F583         MOV     DPH,A
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   12....       LCALL   ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   000003   12....       LCALL   ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_534:
   \   000006   7409         MOV     A,#0x9
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine185_0
   \   000003                ; // Fall through to label ??Subroutine185_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine185_0:
   \   000000   12....       LCALL   ?Subroutine156 & 0xFFFF
   \                     ??CrossCallReturnLabel_350:
   \   000003   E582         MOV     A,DPL
   \   000005   4583         ORL     A,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_405:
   \   000009   85..82       MOV     DPL,?V0
   \   00000C   85..83       MOV     DPH,?V1
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7F07         MOV     R7,#0x7
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   12....       LCALL   ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005                REQUIRE ??Subroutine195_0
   \   000005                ; // Fall through to label ??Subroutine195_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine153:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   6401         XRL     A,#0x1
   \   000008   5401         ANL     A,#0x1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine147:
   \   000000   12....       LCALL   ?Subroutine172 & 0xFFFF
   \                     ??CrossCallReturnLabel_513:
   \   000003   F583         MOV     DPH,A
   \   000005   8882         MOV     DPL,R0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine146:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine221_0
   \   000004                ; // Fall through to label ??Subroutine221_0
   2264          
   2265          /*********************************************************************
   2266           * PRIVATE FUNCTIONS
   2267           *********************************************************************/
   2268          
   2269          /*********************************************************************
   2270           * @fn      zclParseHdr
   2271           *
   2272           * @brief   Parse header of the ZCL format
   2273           *
   2274           * @param   hdr - place to put the frame control information
   2275           * @param   pData - incoming buffer to parse
   2276           *
   2277           * @return  pointer past the header
   2278           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2279          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   2280          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   2281            // Clear the header
   2282            zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2283          
   2284            // Parse the Frame Control
   2285            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV     DPL,?V0
   \   000019   85..83       MOV     DPH,?V1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   54FC         ANL     A,#0xfc
   \   00001F   FA           MOV     R2,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FB           MOV     R3,A
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   E0           MOVX    A,@DPTR
   \   000028   5403         ANL     A,#0x3
   \   00002A   F8           MOV     R0,A
   \   00002B   EA           MOV     A,R2
   \   00002C   48           ORL     A,R0
   \   00002D   F8           MOV     R0,A
   \   00002E   EB           MOV     A,R3
   \   00002F   F9           MOV     R1,A
   \   000030   85..82       MOV     DPL,?V0
   \   000033   85..83       MOV     DPH,?V1
   \   000036   E8           MOV     A,R0
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   E9           MOV     A,R1
   \   00003A   12....       LCALL   ?Subroutine37 & 0xFFFF
   2286            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_41:
   \   00003D   A2E2         MOV     C,0xE0 /* A   */.2
   \   00003F   5004         JNC     ??zclParseHdr_0
   \   000041   7804         MOV     R0,#0x4
   \   000043   8002         SJMP    ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000045   7800         MOV     R0,#0x0
   \                     ??zclParseHdr_1:
   \   000047   85..82       MOV     DPL,?V0
   \   00004A   85..83       MOV     DPH,?V1
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   54FB         ANL     A,#0xfb
   \   000050   F0           MOVX    @DPTR,A
   \   000051   E0           MOVX    A,@DPTR
   \   000052   48           ORL     A,R0
   \   000053   12....       LCALL   ?Subroutine37 & 0xFFFF
   2287            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_42:
   \   000056   A2E3         MOV     C,0xE0 /* A   */.3
   \   000058   85..82       MOV     DPL,?V0
   \   00005B   85..83       MOV     DPH,?V1
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   5004         JNC     ??zclParseHdr_2
   2288            {
   2289              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000061   4408         ORL     A,#0x8
   \   000063   8002         SJMP    ??zclParseHdr_3
   2290            }
   2291            else
   2292            {
   2293              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000065   54F7         ANL     A,#0xf7
   2294            }
   \                     ??zclParseHdr_3:
   \   000067   12....       LCALL   ?Subroutine37 & 0xFFFF
   2295          
   2296            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_43:
   \   00006A   A2E4         MOV     C,0xE0 /* A   */.4
   \   00006C   5004         JNC     ??zclParseHdr_4
   \   00006E   7810         MOV     R0,#0x10
   \   000070   8002         SJMP    ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   000072   7800         MOV     R0,#0x0
   \                     ??zclParseHdr_5:
   \   000074   85..82       MOV     DPL,?V0
   \   000077   85..83       MOV     DPH,?V1
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   54EF         ANL     A,#0xef
   \   00007D   F0           MOVX    @DPTR,A
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   48           ORL     A,R0
   \   000080   12....       LCALL   ?Subroutine33 & 0xFFFF
   2297            pData++;  // move past the frame control field
   2298          
   2299            // parse the manfacturer code
   2300            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_32:
   \   000083   85..82       MOV     DPL,?V0
   \   000086   85..83       MOV     DPH,?V1
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   5404         ANL     A,#0x4
   \   00008C   6010         JZ      ??zclParseHdr_6
   2301            {
   2302              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   00008E   8E82         MOV     DPL,R6
   \   000090   8F83         MOV     DPH,R7
   \   000092   E0           MOVX    A,@DPTR
   \   000093   FA           MOV     R2,A
   \   000094   A3           INC     DPTR
   \   000095   12....       LCALL   ??Subroutine202_0 & 0xFFFF
   2303              pData += 2;
   2304            }
   \                     ??CrossCallReturnLabel_426:
   \   000098   12....       LCALL   ??Subroutine188_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_355:
   \   00009B   5001         JNC     ??zclParseHdr_6
   \   00009D   0F           INC     R7
   2305          
   2306            // parse the Transaction Sequence Number
   2307            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   00009E   8E82         MOV     DPL,R6
   \   0000A0   8F83         MOV     DPH,R7
   \   0000A2   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   12....       LCALL   ??Subroutine208_0 & 0xFFFF
   2308          
   2309            // parse the Cluster's command ID
   2310            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_455:
   \   0000AA   85..82       MOV     DPL,?V0
   \   0000AD   85..83       MOV     DPH,?V1
   \   0000B0   A3           INC     DPTR
   \   0000B1   A3           INC     DPTR
   \   0000B2   A3           INC     DPTR
   \   0000B3   A3           INC     DPTR
   \   0000B4   A3           INC     DPTR
   \   0000B5   F0           MOVX    @DPTR,A
   2311          
   2312            // Should point to the frame payload
   2313            return ( pData );
   \   0000B6   EE           MOV     A,R6
   \   0000B7   2402         ADD     A,#0x2
   \   0000B9   FA           MOV     R2,A
   \   0000BA   E4           CLR     A
   \   0000BB   3F           ADDC    A,R7
   \   0000BC   FB           MOV     R3,A
   \   0000BD   02....       LJMP    ?Subroutine3 & 0xFFFF
   2314          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   12....       LCALL   ?Subroutine169 & 0xFFFF
   \                     ??CrossCallReturnLabel_458:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine188_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine189_0
   \   000001                ; // Fall through to label ??Subroutine189_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine189_0:
   \   000000   A3           INC     DPTR
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ??Subroutine204_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_438:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_419:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine135:
   \   000000   12....       LCALL   ?Subroutine169 & 0xFFFF
   \                     ??CrossCallReturnLabel_460:
   \   000003   A3           INC     DPTR
   \   000004   AE82         MOV     R6,DPL
   \   000006   AF83         MOV     R7,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine202_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   EA           MOV     A,R2
   \   000003   85..82       MOV     DPL,?V0
   \   000006   85..83       MOV     DPH,?V1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine204_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EE           MOV     A,R6
   \   000002   2402         ADD     A,#0x2
   \   000004   FE           MOV     R6,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine208_0:
   \   000000   12....       LCALL   ?Subroutine169 & 0xFFFF
   \                     ??CrossCallReturnLabel_461:
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET
   2315          
   2316          /*********************************************************************
   2317           * @fn      zclBuildHdr
   2318           *
   2319           * @brief   Build header of the ZCL format
   2320           *
   2321           * @param   hdr - outgoing header information
   2322           * @param   pData - outgoing header space
   2323           *
   2324           * @return  pointer past the header
   2325           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2326          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   2327          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   2328            // Build the Frame Control byte
   2329            *pData = hdr->fc.type;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   5403         ANL     A,#0x3
   \   00000C   8C82         MOV     DPL,R4
   \   00000E   8D83         MOV     DPH,R5
   \   000010   12....       LCALL   ??Subroutine192_0 & 0xFFFF
   2330            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_367:
   \   000013   5404         ANL     A,#0x4
   \   000015   12....       LCALL   ?Subroutine41 & 0xFFFF
   2331            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_365:
   \   000018   5408         ANL     A,#0x8
   \   00001A   12....       LCALL   ?Subroutine41 & 0xFFFF
   2332            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_366:
   \   00001D   5410         ANL     A,#0x10
   \   00001F   F8           MOV     R0,A
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   E0           MOVX    A,@DPTR
   \   000025   48           ORL     A,R0
   \   000026   F0           MOVX    @DPTR,A
   2333            pData++;  // move past the frame control field
   \   000027   A3           INC     DPTR
   \   000028   AC82         MOV     R4,DPL
   \   00002A   AD83         MOV     R5,DPH
   2334          
   2335            // Add the manfacturer code
   2336            if ( hdr->fc.manuSpecific )
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   E0           MOVX    A,@DPTR
   \   000031   5404         ANL     A,#0x4
   \   000033   6010         JZ      ??zclBuildHdr_0
   2337            {
   2338              *pData++ = LO_UINT16( hdr->manuCode );
   \   000035   12....       LCALL   ?Subroutine117 & 0xFFFF
   2339              *pData++ = HI_UINT16( hdr->manuCode );
   2340            }
   \                     ??CrossCallReturnLabel_360:
   \   000038   12....       LCALL   ??Subroutine191_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_361:
   \   00003B   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   00003E   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   000041   FC           MOV     R4,A
   \   000042   5001         JNC     ??zclBuildHdr_0
   \   000044   0D           INC     R5
   2341          
   2342            // Add the Transaction Sequence Number
   2343            *pData++ = hdr->transSeqNum;
   \                     ??zclBuildHdr_0:
   \   000045   8A82         MOV     DPL,R2
   \   000047   8B83         MOV     DPH,R3
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   12....       LCALL   ?Subroutine160 & 0xFFFF
   \                     ??CrossCallReturnLabel_363:
   \   00004F   12....       LCALL   ?Subroutine39 & 0xFFFF
   2344          
   2345            // Add the Cluster's command ID
   2346            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_50:
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   12....       LCALL   ?Subroutine95 & 0xFFFF
   2347          
   2348            // Should point to the frame payload
   2349            return ( pData );
   \                     ??CrossCallReturnLabel_163:
   \   000059   FA           MOV     R2,A
   \   00005A   E4           CLR     A
   \   00005B   3D           ADDC    A,R5
   \   00005C   FB           MOV     R3,A
   \   00005D   80..         SJMP    ??Subroutine193_0
   2350          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   12....       LCALL   ??Subroutine191_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_362:
   \   000003   A3           INC     DPTR
   \   000004   F0           MOVX    @DPTR,A
   \   000005   EC           MOV     A,R4
   \   000006   2402         ADD     A,#0x2
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   F8           MOV     R0,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   48           ORL     A,R0
   \   000007                REQUIRE ??Subroutine192_0
   \   000007                ; // Fall through to label ??Subroutine192_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine192_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET
   2351          
   2352          /*********************************************************************
   2353           * @fn      zclCalcHdrSize
   2354           *
   2355           * @brief   Calculate the number of bytes needed for an outgoing
   2356           *          ZCL header.
   2357           *
   2358           * @param   hdr - outgoing header information
   2359           *
   2360           * @return  returns the number of bytes needed
   2361           */
   2362          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   2363          {
   2364            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   2365          
   2366            // Add the manfacturer code
   2367            if ( hdr->fc.manuSpecific )
   2368            {
   2369              needed += 2;
   2370            }
   2371          
   2372            return ( needed );
   2373          }
   2374          
   2375          /*********************************************************************
   2376           * @fn      zclFindPlugin
   2377           *
   2378           * @brief   Find the right plugin for a cluster ID
   2379           *
   2380           * @param   clusterID - cluster ID to look for
   2381           * @param   profileID - profile ID
   2382           *
   2383           * @return  pointer to plugin, NULL if not found
   2384           */
   2385          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   2386          {
   2387            zclLibPlugin_t *pLoop = plugins;
   2388          
   2389            (void)profileID;  // Intentionally unreferenced parameter
   2390          
   2391            while ( pLoop != NULL )
   2392            {
   2393              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   2394              {
   2395                return ( pLoop );
   2396              }
   2397          
   2398              pLoop = pLoop->next;
   2399            }
   2400          
   2401            return ( (zclLibPlugin_t *)NULL );
   2402          }
   2403          
   2404          #ifdef ZCL_DISCOVER
   2405          /*********************************************************************
   2406           * @fn      zclFindCmdRecsList
   2407           *
   2408           * @brief   Find the right command record list for an endpoint
   2409           *
   2410           * @param   endpoint - endpoint to look for
   2411           *
   2412           * @return  pointer to record list, NULL if not found
   2413           */
   2414          static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
   2415          {
   2416            zclCmdRecsList_t *pLoop = gpCmdList;
   2417          
   2418            while ( pLoop != NULL )
   2419            {
   2420              if ( pLoop->endpoint == endpoint )
   2421              {
   2422                return ( pLoop );
   2423              }
   2424          
   2425              pLoop = pLoop->pNext;
   2426            }
   2427          
   2428            return ( NULL );
   2429          }
   2430          
   2431          /*********************************************************************
   2432           * @fn      zclFindCmdRec
   2433           *
   2434           * @brief   Find the command record that matchs the parameters
   2435           *
   2436           * @param   endpoint - Application's endpoint
   2437           * @param   clusterID - cluster ID
   2438           * @param   attrId - attribute looking for
   2439           * @param   pAttr - attribute record to be returned
   2440           *
   2441           * @return  TRUE if record found. FALSE, otherwise.
   2442           */
   2443          uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
   2444          {
   2445            uint8 i;
   2446            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2447          
   2448            if ( pRec != NULL )
   2449            {
   2450              for ( i = 0; i < pRec->numCommands; i++ )
   2451              {
   2452                if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
   2453                {
   2454                  *pCmd = pRec->pCmdRecs[i];
   2455          
   2456                  return ( TRUE ); // EMBEDDED RETURN
   2457                }
   2458              }
   2459            }
   2460          
   2461            return ( FALSE );
   2462          }
   2463          #endif // ZCL_DISCOVER
   2464          
   2465          /*********************************************************************
   2466           * @fn      zclFindAttrRecsList
   2467           *
   2468           * @brief   Find the right attribute record list for an endpoint
   2469           *
   2470           * @param   clusterID - endpointto look for
   2471           *
   2472           * @return  pointer to record list, NULL if not found
   2473           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2474          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   2475          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2476            zclAttrRecsList *pLoop = attrList;
   \   000004   90....       MOV     DPTR,#attrList
   \   000007   8004         SJMP    ??zclFindAttrRecsList_0
   2477          
   2478            while ( pLoop != NULL )
   2479            {
   2480              if ( pLoop->endpoint == endpoint )
   2481              {
   2482                return ( pLoop );
   2483              }
   2484          
   2485              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_1:
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \                     ??zclFindAttrRecsList_0:
   \   00000D   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_306:
   \   000010   600C         JZ      ??zclFindAttrRecsList_2
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   69           XRL     A,R1
   \   00001A   70ED         JNZ     ??zclFindAttrRecsList_1
   \   00001C   8004         SJMP    ??zclFindAttrRecsList_3
   2486            }
   2487          
   2488            return ( NULL );
   \                     ??zclFindAttrRecsList_2:
   \   00001E   7A00         MOV     R2,#0x0
   \   000020   7B00         MOV     R3,#0x0
   \                     ??zclFindAttrRecsList_3:
   \   000022   02....       LJMP    ?Subroutine0 & 0xFFFF
   2489          }
   2490          
   2491          /*********************************************************************
   2492           * @fn      zclFindAttrRec
   2493           *
   2494           * @brief   Find the attribute record that matchs the parameters
   2495           *
   2496           * @param   endpoint - Application's endpoint
   2497           * @param   clusterID - cluster ID
   2498           * @param   attrId - attribute looking for
   2499           * @param   pAttr - attribute record to be returned
   2500           *
   2501           * @return  TRUE if record found. FALSE, otherwise.
   2502           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2503          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   2504          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   2505            uint8 x;
   2506            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000010   8A..         MOV     ?V4,R2
   \   000012   8B..         MOV     ?V5,R3
   2507          
   2508            if ( pRec != NULL )
   \   000014   EA           MOV     A,R2
   \   000015   45..         ORL     A,?V5
   \   000017   6075         JZ      ??zclFindAttrRec_0
   2509            {
   2510              for ( x = 0; x < pRec->numAttributes; x++ )
   \   000019   7C00         MOV     R4,#0x0
   \   00001B   8001         SJMP    ??zclFindAttrRec_1
   \                     ??zclFindAttrRec_2:
   \   00001D   0C           INC     R4
   \                     ??zclFindAttrRec_1:
   \   00001E   85..82       MOV     DPL,?V4
   \   000021   85..83       MOV     DPH,?V5
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   12....       LCALL   ??Subroutine178_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   00002E   505E         JNC     ??zclFindAttrRec_0
   2511              {
   2512                if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
   \   000030   8C..         MOV     ?V6,R4
   \   000032   75..00       MOV     ?V7,#0x0
   \   000035   7403         MOV     A,#0x3
   \   000037   78..         MOV     R0,#?V6
   \   000039   12....       LCALL   ?S_SHL
   \   00003C   85..82       MOV     DPL,?V4
   \   00003F   85..83       MOV     DPH,?V5
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   25..         ADD     A,?V6
   \   00004D   F8           MOV     R0,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   35..         ADDC    A,?V7
   \   000052   F9           MOV     R1,A
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   E4           CLR     A
   \   000058   93           MOVC    A,@A+DPTR
   \   000059   FA           MOV     R2,A
   \   00005A   7401         MOV     A,#0x1
   \   00005C   93           MOVC    A,@A+DPTR
   \   00005D   FB           MOV     R3,A
   \   00005E   E5..         MOV     A,?V0
   \   000060   6A           XRL     A,R2
   \   000061   7003         JNZ     ??zclFindAttrRec_3
   \   000063   E5..         MOV     A,?V1
   \   000065   6B           XRL     A,R3
   \                     ??zclFindAttrRec_3:
   \   000066   70B5         JNZ     ??zclFindAttrRec_2
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   E4           CLR     A
   \   00006B   93           MOVC    A,@A+DPTR
   \   00006C   FA           MOV     R2,A
   \   00006D   7401         MOV     A,#0x1
   \   00006F   93           MOVC    A,@A+DPTR
   \   000070   FB           MOV     R3,A
   \   000071   EE           MOV     A,R6
   \   000072   6A           XRL     A,R2
   \   000073   7002         JNZ     ??zclFindAttrRec_4
   \   000075   EF           MOV     A,R7
   \   000076   6B           XRL     A,R3
   \                     ??zclFindAttrRec_4:
   \   000077   70A4         JNZ     ??zclFindAttrRec_2
   2513                {
   2514                  *pAttr = pRec->attrs[x];
   \   000079   7410         MOV     A,#0x10
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   12....       LCALL   ??Subroutine213_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_484:
   \   000081   8983         MOV     DPH,R1
   \   000083   8882         MOV     DPL,R0
   \   000085   7408         MOV     A,#0x8
   \   000087   12....       LCALL   ?MOVE_LONG8_XDATA_CODE
   2515          
   2516                  return ( TRUE ); // EMBEDDED RETURN
   \   00008A   7901         MOV     R1,#0x1
   \   00008C   8002         SJMP    ??zclFindAttrRec_5
   2517                }
   2518              }
   2519            }
   2520          
   2521            return ( FALSE );
   \                     ??zclFindAttrRec_0:
   \   00008E   7900         MOV     R1,#0x0
   \                     ??zclFindAttrRec_5:
   \   000090   80..         SJMP    ??Subroutine194_0
   2522          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine194_0:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   2523          
   2524          #if defined ( ZCL_STANDALONE )
   2525          /*********************************************************************
   2526           * @fn      zclSetAttrRecList
   2527           *
   2528           * @brief   Set attribute record list for end point
   2529           *
   2530           * @param   endpoint - endpoint the attribute list belongs to
   2531           * @param   numAttr - number of attributes in list
   2532           * @param   attrList - array of attribute records.
   2533           *                     NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE
   2534           *                     IN ASCENDING ORDER. OTHERWISE, THE DISCOVERY 
   2535           *                     RESPONSE COMMAND WILL NOT HAVE THE RIGHT 
   2536           *                     ATTRIBUTE INFO
   2537           *
   2538           * @return  TRUE if successful, FALSE otherwise.
   2539           */
   2540          uint8 zclSetAttrRecList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t attrList[] )
   2541          {
   2542            zclAttrRecsList *pRecsList = zclFindAttrRecsList( endpoint );
   2543          
   2544            if ( pRecsList != NULL )
   2545            {
   2546              pRecsList->numAttributes = numAttr;
   2547              pRecsList->attrs = attrList;
   2548              return ( TRUE );
   2549            }
   2550          
   2551            return ( FALSE );
   2552          }
   2553          
   2554          #endif // ZCL_STANDALONE
   2555          
   2556          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   2557          /*********************************************************************
   2558           * @fn      zclGetReadWriteCB
   2559           *
   2560           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   2561           *
   2562           * @param   endpoint - Application's endpoint
   2563           *
   2564           * @return  Read/Write CB, NULL if not found
   2565           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2566          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   \                     zclGetReadWriteCB:
   2567          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2568            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2569          
   2570            if ( pRec != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6005         JZ      ??zclGetReadWriteCB_0
   2571            {
   2572              return ( pRec->pfnReadWriteCB );
   \   000012   12....       LCALL   ??Subroutine197_0 & 0xFFFF
   2573            }
   \                     ??CrossCallReturnLabel_398:
   \   000015   8004         SJMP    ??zclGetReadWriteCB_1
   2574          
   2575            return ( NULL );
   \                     ??zclGetReadWriteCB_0:
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7B00         MOV     R3,#0x0
   \                     ??zclGetReadWriteCB_1:
   \   00001B   80..         SJMP    ?Subroutine3
   2576          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine197_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine198_0
   \   000003                ; // Fall through to label ??Subroutine198_0
   2577          
   2578          /*********************************************************************
   2579           * @fn      zclGetAuthorizeCB
   2580           *
   2581           * @brief   Get the Read/Write Authorization callback function pointer
   2582           *          for a given endpoint.
   2583           *
   2584           * @param   endpoint - Application's endpoint
   2585           *
   2586           * @return  Authorization CB, NULL if not found
   2587           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2588          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   \                     zclGetAuthorizeCB:
   2589          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2590            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL   `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2591          
   2592            if ( pRec != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6005         JZ      ??zclGetAuthorizeCB_0
   2593            {
   2594              return ( pRec->pfnAuthorizeCB );
   \   000012   12....       LCALL   ?Subroutine97 & 0xFFFF
   2595            }
   \                     ??CrossCallReturnLabel_402:
   \   000015   8004         SJMP    ??zclGetAuthorizeCB_1
   2596          
   2597            return ( NULL );
   \                     ??zclGetAuthorizeCB_0:
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7B00         MOV     R3,#0x0
   \                     ??zclGetAuthorizeCB_1:
   \   00001B                REQUIRE ?Subroutine3
   \   00001B                ; // Fall through to label ?Subroutine3
   2598          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine196_0
   \   000001                ; // Fall through to label ??Subroutine196_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine196_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine197_0
   \   000001                ; // Fall through to label ??Subroutine197_0
   2599          #endif // ZCL_READ || ZCL_WRITE
   2600          
   2601          /*********************************************************************
   2602           * @fn      zclFindClusterOption
   2603           *
   2604           * @brief   Find the option record that matchs the cluster id
   2605           *
   2606           * @param   endpoint - Application's endpoint
   2607           * @param   clusterID - cluster ID looking for
   2608           *
   2609           * @return  pointer to clutser option, NULL if not found
   2610           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2611          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   2612          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V1,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   2613            zclClusterOptionList *pLoop;
   2614          
   2615            pLoop = clusterOptionList;
   \   00000B   90....       MOV     DPTR,#clusterOptionList
   \   00000E   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   000011   8009         SJMP    ??zclFindClusterOption_0
   2616            while ( pLoop != NULL )
   2617            {
   2618              if ( pLoop->endpoint == endpoint )
   2619              {
   2620                uint8 x;
   2621                for ( x = 0; x < pLoop->numOptions; x++ )
   2622                {
   2623                  if ( pLoop->options[x].clusterID == clusterID )
   2624                  {
   2625                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   2626                  }
   2627                }
   2628              }
   2629          
   2630              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   000013   8C82         MOV     DPL,R4
   \   000015   8D83         MOV     DPH,R5
   \   000017   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   00001A   FC           MOV     R4,A
   \   00001B   E9           MOV     A,R1
   \                     ??zclFindClusterOption_0:
   \   00001C   FD           MOV     R5,A
   \   00001D   EC           MOV     A,R4
   \   00001E   4D           ORL     A,R5
   \   00001F   6045         JZ      ??zclFindClusterOption_2
   \   000021   8C82         MOV     DPL,R4
   \   000023   8D83         MOV     DPH,R5
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   65..         XRL     A,?V1
   \   00002A   70E7         JNZ     ??zclFindClusterOption_1
   \   00002C   75..00       MOV     ?V0,#0x0
   \   00002F   8002         SJMP    ??zclFindClusterOption_3
   \                     ??zclFindClusterOption_4:
   \   000031   05..         INC     ?V0
   \                     ??zclFindClusterOption_3:
   \   000033   8C82         MOV     DPL,R4
   \   000035   8D83         MOV     DPH,R5
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   12....       LCALL   ??Subroutine181_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   00003D   50D4         JNC     ??zclFindClusterOption_1
   \   00003F   E5..         MOV     A,?V0
   \   000041   75F003       MOV     B,#0x3
   \   000044   A4           MUL     AB
   \   000045   F8           MOV     R0,A
   \   000046   A9F0         MOV     R1,B
   \   000048   8C82         MOV     DPL,R4
   \   00004A   8D83         MOV     DPH,R5
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   28           ADD     A,R0
   \   000052   FA           MOV     R2,A
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   39           ADDC    A,R1
   \   000056   FB           MOV     R3,A
   \   000057   8A82         MOV     DPL,R2
   \   000059   8B83         MOV     DPH,R3
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   6E           XRL     A,R6
   \   00005D   7003         JNZ     ??zclFindClusterOption_5
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   6F           XRL     A,R7
   \                     ??zclFindClusterOption_5:
   \   000062   70CD         JNZ     ??zclFindClusterOption_4
   \   000064   8004         SJMP    ??zclFindClusterOption_6
   2631            }
   2632          
   2633            return ( NULL );
   \                     ??zclFindClusterOption_2:
   \   000066   7A00         MOV     R2,#0x0
   \   000068   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_6:
   \   00006A   80..         SJMP    ?Subroutine3
   2634          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   12....       LCALL   ?Subroutine157 & 0xFFFF
   \                     ??CrossCallReturnLabel_383:
   \   000003   22           RET
   2635          
   2636          /*********************************************************************
   2637           * @fn      zclGetClusterOption
   2638           *
   2639           * @brief   Get the option record that matchs the cluster id
   2640           *
   2641           * @param   endpoint - Application's endpoint
   2642           * @param   clusterID - cluster ID looking for
   2643           *
   2644           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   2645           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2646          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2647          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2648            uint8 option;
   2649            zclOptionRec_t *pOption;
   2650          
   2651            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption
   \   000005   12....       LCALL   `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2652            if ( pOption != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6006         JZ      ??zclGetClusterOption_0
   2653            {
   2654              option = pOption->option;
   2655              if ( !ZG_SECURE_ENABLED )
   2656              {
   2657                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2658              }
   2659          
   2660              return ( option ); // EMBEDDED RETURN
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   8002         SJMP    ??zclGetClusterOption_1
   2661            }
   2662          
   2663            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   000018   7900         MOV     R1,#0x0
   \                     ??zclGetClusterOption_1:
   \   00001A   02....       LJMP    ?Subroutine3 & 0xFFFF
   2664          }
   2665          
   2666          /*********************************************************************
   2667           * @fn      zclSetSecurityOption
   2668           *
   2669           * @brief   Set the security option for the cluster id
   2670           *
   2671           * @param   endpoint - Application's endpoint
   2672           * @param   clusterID - cluster ID looking for
   2673           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2674           *
   2675           * @return  none
   2676           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2677          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2678          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FF           MOV     R7,A
   2679            zclOptionRec_t *pOption;
   2680          
   2681            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL   `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   A8..         MOV     R0,?V0
   \   000010   A9..         MOV     R1,?V1
   2682            if ( pOption != NULL )
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   6015         JZ      ??zclSetSecurityOption_0
   2683            {
   2684              if ( enable )
   \   000016   E8           MOV     A,R0
   \   000017   2402         ADD     A,#0x2
   \   000019   F582         MOV     DPL,A
   \   00001B   E4           CLR     A
   \   00001C   39           ADDC    A,R1
   \   00001D   F583         MOV     DPH,A
   \   00001F   EF           MOV     A,R7
   \   000020   6005         JZ      ??zclSetSecurityOption_1
   2685              {
   2686                pOption->option |= AF_EN_SECURITY;
   \   000022   E0           MOVX    A,@DPTR
   \   000023   D2E6         SETB    0xE0 /* A   */.6
   \   000025   8003         SJMP    ??zclSetSecurityOption_2
   2687              }
   2688              else
   2689              {
   2690                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   000027   E0           MOVX    A,@DPTR
   \   000028   C2E6         CLR     0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_2:
   \   00002A   F0           MOVX    @DPTR,A
   2691              }
   2692            }
   2693          }
   \                     ??zclSetSecurityOption_0:
   \   00002B   02....       LJMP    ?Subroutine3 & 0xFFFF
   2694          
   2695          #ifdef ZCL_DISCOVER
   2696          /*********************************************************************
   2697           * @fn      zclFindNextCmdRec
   2698           *
   2699           * @brief   Find the command (or next) record that matchs the parameters
   2700           *
   2701           * @param   endpoint - Application's endpoint
   2702           * @param   clusterID - cluster ID
   2703           * @param   commandID - command ID from requesting command
   2704           * @param   direction- direction of received command
   2705           * @param   pCmdID - command looking for
   2706           * @param   pCmd - command information within command record list
   2707           *
   2708           * @return  pointer to command record, NULL no more records of this cluster
   2709           */
   2710          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
   2711                                          uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
   2712          {
   2713            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2714            uint8 i;
   2715          
   2716            if ( pRec != NULL )
   2717            {
   2718              for ( i = 0; i < pRec->numCommands; i++ )
   2719              {
   2720                if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
   2721                    ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
   2722                {
   2723                  if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   2724                  {
   2725                    if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
   2726                    {
   2727                      *pCmd = pRec->pCmdRecs[i];
   2728          
   2729                      // Update command ID
   2730                      *pCmdID = pCmd->cmdID;
   2731          
   2732                      return ( TRUE ); // EMBEDDED RETURN
   2733                    }
   2734                    else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
   2735                    {
   2736                      *pCmd = pRec->pCmdRecs[i];
   2737          
   2738                      // Update command ID
   2739                      *pCmdID = pCmd->cmdID;
   2740          
   2741                      return ( TRUE ); // EMBEDDED RETURN
   2742                    }
   2743                  }
   2744                  else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
   2745                  {
   2746                    if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
   2747                    {
   2748                      *pCmd = pRec->pCmdRecs[i];
   2749          
   2750                      // Update command ID
   2751                      *pCmdID = pCmd->cmdID;
   2752          
   2753                      return ( TRUE ); // EMBEDDED RETURN
   2754                    }
   2755                    else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
   2756                    {
   2757                      *pCmd = pRec->pCmdRecs[i];
   2758          
   2759                      // Update command ID
   2760                      *pCmdID = pCmd->cmdID;
   2761          
   2762                      return ( TRUE ); // EMBEDDED RETURN
   2763                    }
   2764                  }
   2765                  else
   2766                  {
   2767                    return ( FALSE ); // Incorrect Command ID
   2768                  }
   2769                }
   2770              }
   2771            }
   2772          
   2773            return ( FALSE );
   2774          }
   2775          
   2776          /*********************************************************************
   2777           * @fn      zclFindNextAttrRec
   2778           *
   2779           * @brief   Find the attribute (or next) record that matchs the parameters
   2780           *
   2781           * @param   endpoint - Application's endpoint
   2782           * @param   clusterID - cluster ID
   2783           * @param   attr - attribute looking for
   2784           *
   2785           * @return  pointer to attribute record, NULL if not found
   2786           */
   2787          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
   2788                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2789          {
   2790            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2791            uint8 attrDir;
   2792          
   2793            if ( pRec != NULL )
   2794            {
   2795              uint16 x;
   2796          
   2797              for ( x = 0; x < pRec->numAttributes; x++ )
   2798              {
   2799                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2800                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2801                {
   2802                  // also make sure direction is right
   2803                  attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
   2804                  if ( attrDir == direction )
   2805                  {
   2806                    // return attribute and found attribute ID
   2807                    *pAttr = pRec->attrs[x];
   2808                    *attrId = pAttr->attr.attrId;
   2809          
   2810                    return ( TRUE ); // EMBEDDED RETURN
   2811                  }
   2812                }
   2813              }
   2814            }
   2815          
   2816            return ( FALSE );
   2817          }
   2818          #endif // ZCL_DISCOVER
   2819          
   2820          /*********************************************************************
   2821           * @fn      zclSerializeData
   2822           *
   2823           * @brief   Builds a buffer from the attribute data to sent out over
   2824           *          the air.
   2825           *          NOTE - Not compatible with application's attributes callbacks.
   2826           *
   2827           * @param   dataType - data types defined in zcl.h
   2828           * @param   attrData - pointer to the attribute data
   2829           * @param   buf - where to put the serialized data
   2830           *
   2831           * @return  pointer to end of destination buffer
   2832           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2833          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2834          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EC           MOV     A,R4
   \   00000A   FA           MOV     R2,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FB           MOV     R3,A
   2835            uint8 *pStr;
   2836            uint16 len;
   2837          
   2838            if ( attrData == NULL )
   \   00000D   EE           MOV     A,R6
   \   00000E   4F           ORL     A,R7
   \   00000F   7003         JNZ     $+5
   \   000011   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2839            {
   2840              return ( buf );
   2841            }
   2842          
   2843            switch ( dataType )
   \   000014   EA           MOV     A,R2
   \   000015   2402         ADD     A,#0x2
   \   000017   F5..         MOV     ?V4,A
   \   000019   E4           CLR     A
   \   00001A   3B           ADDC    A,R3
   \   00001B   F5..         MOV     ?V5,A
   \   00001D   8A82         MOV     DPL,R2
   \   00001F   8B83         MOV     DPH,R3
   \   000021   A3           INC     DPTR
   \   000022   AC82         MOV     R4,DPL
   \   000024   AD83         MOV     R5,DPH
   \   000026   8E..         MOV     ?V0,R6
   \   000028   8F..         MOV     ?V1,R7
   \   00002A   75..00       MOV     ?V2,#0x0
   \   00002D   E9           MOV     A,R1
   \   00002E   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   000031   04           DB        4
   \   000032   41           DB        65
   \   000033   42           DB        66
   \   000034   ....         DW        ??zclSerializeData_1
   \   000036   43           DB        67
   \   000037   44           DB        68
   \   000038   ....         DW        ??zclSerializeData_2
   \   00003A   E0           DB        224
   \   00003B   E2           DB        226
   \   00003C   ....         DW        ??zclSerializeData_3
   \   00003E   E8           DB        232
   \   00003F   E9           DB        233
   \   000040   ....         DW        ??zclSerializeData_4
   \   000042   21           DB        33
   \   000043   08           DB        8
   \   000044   ....         DW        ??zclSerializeData_5
   \   000046   09           DB        9
   \   000047   ....         DW        ??zclSerializeData_4
   \   000049   0A           DB        10
   \   00004A   ....         DW        ??zclSerializeData_6
   \   00004C   0B           DB        11
   \   00004D   ....         DW        ??zclSerializeData_3
   \   00004F   10           DB        16
   \   000050   ....         DW        ??zclSerializeData_5
   \   000052   18           DB        24
   \   000053   ....         DW        ??zclSerializeData_5
   \   000055   19           DB        25
   \   000056   ....         DW        ??zclSerializeData_4
   \   000058   1A           DB        26
   \   000059   ....         DW        ??zclSerializeData_6
   \   00005B   1B           DB        27
   \   00005C   ....         DW        ??zclSerializeData_3
   \   00005E   20           DB        32
   \   00005F   ....         DW        ??zclSerializeData_5
   \   000061   21           DB        33
   \   000062   ....         DW        ??zclSerializeData_4
   \   000064   22           DB        34
   \   000065   ....         DW        ??zclSerializeData_6
   \   000067   23           DB        35
   \   000068   ....         DW        ??zclSerializeData_3
   \   00006A   24           DB        36
   \   00006B   ....         DW        ??zclSerializeData_7
   \   00006D   25           DB        37
   \   00006E   ....         DW        ??zclSerializeData_8
   \   000070   26           DB        38
   \   000071   ....         DW        ??zclSerializeData_9
   \   000073   27           DB        39
   \   000074   ....         DW        ??zclSerializeData_10
   \   000076   28           DB        40
   \   000077   ....         DW        ??zclSerializeData_5
   \   000079   29           DB        41
   \   00007A   ....         DW        ??zclSerializeData_4
   \   00007C   2A           DB        42
   \   00007D   ....         DW        ??zclSerializeData_6
   \   00007F   2B           DB        43
   \   000080   ....         DW        ??zclSerializeData_3
   \   000082   2C           DB        44
   \   000083   ....         DW        ??zclSerializeData_7
   \   000085   2D           DB        45
   \   000086   ....         DW        ??zclSerializeData_8
   \   000088   2E           DB        46
   \   000089   ....         DW        ??zclSerializeData_9
   \   00008B   2F           DB        47
   \   00008C   ....         DW        ??zclSerializeData_10
   \   00008E   30           DB        48
   \   00008F   ....         DW        ??zclSerializeData_5
   \   000091   31           DB        49
   \   000092   ....         DW        ??zclSerializeData_4
   \   000094   38           DB        56
   \   000095   ....         DW        ??zclSerializeData_4
   \   000097   39           DB        57
   \   000098   ....         DW        ??zclSerializeData_3
   \   00009A   3A           DB        58
   \   00009B   ....         DW        ??zclSerializeData_10
   \   00009D   EA           DB        234
   \   00009E   ....         DW        ??zclSerializeData_3
   \   0000A0   F0           DB        240
   \   0000A1   ....         DW        ??zclSerializeData_10
   \   0000A3   F1           DB        241
   \   0000A4   ....         DW        ??zclSerializeData_11
   \   0000A6   ....         DW        ??zclSerializeData_0
   2844            {
   2845              case ZCL_DATATYPE_DATA8:
   2846              case ZCL_DATATYPE_BOOLEAN:
   2847              case ZCL_DATATYPE_BITMAP8:
   2848              case ZCL_DATATYPE_INT8:
   2849              case ZCL_DATATYPE_UINT8:
   2850              case ZCL_DATATYPE_ENUM8:
   2851                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_5:
   \   0000A8   8E82         MOV     DPL,R6
   \   0000AA   8F83         MOV     DPH,R7
   \   0000AC   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   0000AF   EC           MOV     A,R4
   \   0000B0   FA           MOV     R2,A
   \   0000B1   ED           MOV     A,R5
   \   0000B2   FB           MOV     R3,A
   2852                 break;
   \   0000B3   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2853          
   2854              case ZCL_DATATYPE_DATA16:
   2855              case ZCL_DATATYPE_BITMAP16:
   2856              case ZCL_DATATYPE_UINT16:
   2857              case ZCL_DATATYPE_INT16:
   2858              case ZCL_DATATYPE_ENUM16:
   2859              case ZCL_DATATYPE_SEMI_PREC:
   2860              case ZCL_DATATYPE_CLUSTER_ID:
   2861              case ZCL_DATATYPE_ATTR_ID:
   2862                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_4:
   \   0000B6   12....       LCALL   ?Subroutine19 & 0xFFFF
   2863                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_453:
   \   0000B9   8C82         MOV     DPL,R4
   \   0000BB   8D83         MOV     DPH,R5
   \   0000BD   F0           MOVX    @DPTR,A
   \   0000BE   0A           INC     R2
   \   0000BF   0A           INC     R2
   \   0000C0   AB..         MOV     R3,?V5
   2864                break;
   \   0000C2   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2865          
   2866              case ZCL_DATATYPE_DATA24:
   2867              case ZCL_DATATYPE_BITMAP24:
   2868              case ZCL_DATATYPE_UINT24:
   2869              case ZCL_DATATYPE_INT24:
   2870                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_6:
   \   0000C5   8E82         MOV     DPL,R6
   \   0000C7   8F83         MOV     DPH,R7
   \   0000C9   78..         MOV     R0,#?V0
   \   0000CB   12....       LCALL   ?L_MOV_X
   \   0000CE   8A82         MOV     DPL,R2
   \   0000D0   8B83         MOV     DPH,R3
   \   0000D2   E5..         MOV     A,?V0
   \   0000D4   12....       LCALL   ?Subroutine38 & 0xFFFF
   2871                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_45:
   \   0000D7   78..         MOV     R0,#?V0
   \   0000D9   12....       LCALL   ?L_MOV_X
   \   0000DC   E5..         MOV     A,?V1
   \   0000DE   8C82         MOV     DPL,R4
   \   0000E0   8D83         MOV     DPH,R5
   \   0000E2   12....       LCALL   ?Subroutine38 & 0xFFFF
   2872                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \                     ??CrossCallReturnLabel_46:
   \   0000E5   78..         MOV     R0,#?V0
   \   0000E7   12....       LCALL   ?L_MOV_X
   \   0000EA   7410         MOV     A,#0x10
   \   0000EC   78..         MOV     R0,#?V0
   \   0000EE   12....       LCALL   ?UL_SHR
   \   0000F1   85..82       MOV     DPL,?V4
   \   0000F4   85..83       MOV     DPH,?V5
   \   0000F7   E5..         MOV     A,?V0
   \   0000F9   F0           MOVX    @DPTR,A
   \   0000FA   EA           MOV     A,R2
   \   0000FB   2403         ADD     A,#0x3
   \   0000FD   FA           MOV     R2,A
   \   0000FE   506D         JNC     ??zclSerializeData_0
   \   000100   0B           INC     R3
   2873                break;
   \   000101   806A         SJMP    ??zclSerializeData_0
   2874          
   2875              case ZCL_DATATYPE_DATA32:
   2876              case ZCL_DATATYPE_BITMAP32:
   2877              case ZCL_DATATYPE_UINT32:
   2878              case ZCL_DATATYPE_INT32:
   2879              case ZCL_DATATYPE_SINGLE_PREC:
   2880              case ZCL_DATATYPE_TOD:
   2881              case ZCL_DATATYPE_DATE:
   2882              case ZCL_DATATYPE_UTC:
   2883              case ZCL_DATATYPE_BAC_OID:
   2884                buf = zcl_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_3:
   \   000103                ; Setup parameters for call to function osal_buffer_uint32
   \   000103   8E82         MOV     DPL,R6
   \   000105   8F83         MOV     DPH,R7
   \   000107   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   00010A   12....       LCALL   `??osal_buffer_uint32::?relay`; Banked call to: osal_buffer_uint32
   \   00010D   7404         MOV     A,#0x4
   \   00010F   12....       LCALL   ?DEALLOC_XSTACK8
   2885                break;
   \   000112   8059         SJMP    ??zclSerializeData_0
   2886          
   2887              case ZCL_DATATYPE_UINT40:
   2888              case ZCL_DATATYPE_INT40:
   2889                pStr = (uint8*)attrData;
   2890                buf = zcl_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_7:
   \   000114                ; Setup parameters for call to function osal_memcpy
   \   000114   78..         MOV     R0,#?V0
   \   000116   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000119   7C05         MOV     R4,#0x5
   \   00011B   8046         SJMP    ??zclSerializeData_12
   2891                break;
   2892          
   2893              case ZCL_DATATYPE_UINT48:
   2894              case ZCL_DATATYPE_INT48:
   2895                pStr = (uint8*)attrData;
   2896                buf = zcl_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_8:
   \   00011D                ; Setup parameters for call to function osal_memcpy
   \   00011D   78..         MOV     R0,#?V0
   \   00011F   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000122   7C06         MOV     R4,#0x6
   \   000124   803D         SJMP    ??zclSerializeData_12
   2897                break;
   2898          
   2899              case ZCL_DATATYPE_UINT56:
   2900              case ZCL_DATATYPE_INT56:
   2901                pStr = (uint8*)attrData;
   2902                buf = zcl_memcpy( buf, pStr, 7 );
   \                     ??zclSerializeData_9:
   \   000126                ; Setup parameters for call to function osal_memcpy
   \   000126   78..         MOV     R0,#?V0
   \   000128   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00012B   7C07         MOV     R4,#0x7
   \   00012D   8034         SJMP    ??zclSerializeData_12
   2903                break;
   2904          
   2905              case ZCL_DATATYPE_DOUBLE_PREC:
   2906              case ZCL_DATATYPE_IEEE_ADDR:
   2907              case ZCL_DATATYPE_UINT64:
   2908              case ZCL_DATATYPE_INT64:
   2909                pStr = (uint8*)attrData;
   2910                buf = zcl_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_10:
   \   00012F                ; Setup parameters for call to function osal_memcpy
   \   00012F   78..         MOV     R0,#?V0
   \   000131   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000134   7C08         MOV     R4,#0x8
   \   000136   802B         SJMP    ??zclSerializeData_12
   2911                break;
   2912          
   2913              case ZCL_DATATYPE_CHAR_STR:
   2914              case ZCL_DATATYPE_OCTET_STR:
   2915                pStr = (uint8*)attrData;
   2916                len = *pStr;
   2917                buf = zcl_memcpy( buf, pStr, len+1 ); // Including length field
   \                     ??zclSerializeData_1:
   \   000138                ; Setup parameters for call to function osal_memcpy
   \   000138   78..         MOV     R0,#?V0
   \   00013A   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00013D   8E82         MOV     DPL,R6
   \   00013F   8F83         MOV     DPH,R7
   \   000141   E0           MOVX    A,@DPTR
   \   000142   2401         ADD     A,#0x1
   \   000144   FC           MOV     R4,A
   \   000145   E4           CLR     A
   \   000146   3400         ADDC    A,#0x0
   \   000148   800F         SJMP    ??zclSerializeData_13
   2918                break;
   2919          
   2920              case ZCL_DATATYPE_LONG_CHAR_STR:
   2921              case ZCL_DATATYPE_LONG_OCTET_STR:
   2922                pStr = (uint8*)attrData;
   2923                len = BUILD_UINT16( pStr[0], pStr[1] );
   2924                buf = zcl_memcpy( buf, pStr, len+2 ); // Including length field
   \                     ??zclSerializeData_2:
   \   00014A                ; Setup parameters for call to function osal_memcpy
   \   00014A   78..         MOV     R0,#?V0
   \   00014C   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00014F   8E82         MOV     DPL,R6
   \   000151   8F83         MOV     DPH,R7
   \   000153   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   000156   FC           MOV     R4,A
   \   000157   E4           CLR     A
   \   000158   39           ADDC    A,R1
   \                     ??zclSerializeData_13:
   \   000159   FD           MOV     R5,A
   \   00015A   8009         SJMP    ??zclSerializeData_14
   2925                break;
   2926          
   2927              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2928                pStr = (uint8*)attrData;
   2929                buf = zcl_memcpy( buf, pStr, SEC_KEY_LEN );
   \                     ??zclSerializeData_11:
   \   00015C                ; Setup parameters for call to function osal_memcpy
   \   00015C   78..         MOV     R0,#?V0
   \   00015E   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000161   7C10         MOV     R4,#0x10
   \                     ??zclSerializeData_12:
   \   000163   7D00         MOV     R5,#0x0
   \                     ??zclSerializeData_14:
   \   000165   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000168   7403         MOV     A,#0x3
   \   00016A   12....       LCALL   ?DEALLOC_XSTACK8
   2930                break;
   2931          
   2932              case ZCL_DATATYPE_NO_DATA:
   2933              case ZCL_DATATYPE_UNKNOWN:
   2934                // Fall through
   2935          
   2936              default:
   2937                break;
   2938            }
   2939          
   2940            return ( buf );
   \                     ??zclSerializeData_0:
   \   00016D   02....       LJMP    ?Subroutine8 & 0xFFFF
   2941          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine110:
   \   000000   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   000003   F9           MOV     R1,A
   \   000004   EC           MOV     A,R4
   \   000005   2402         ADD     A,#0x2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ??Subroutine199_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_410:
   \   000007                REQUIRE ??Subroutine208_0
   \   000007                ; // Fall through to label ??Subroutine208_0
   2942          
   2943          #ifdef ZCL_REPORT
   2944          /*********************************************************************
   2945           * @fn      zclAnalogDataType
   2946           *
   2947           * @brief   Checks to see if Data Type is Analog
   2948           *
   2949           * @param   dataType - data type
   2950           *
   2951           * @return  TRUE if data type is analog
   2952           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2953          uint8 zclAnalogDataType( uint8 dataType )
   \                     zclAnalogDataType:
   2954          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   2955            uint8 analog;
   2956          
   2957            switch ( dataType )
   \   000005   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclAnalogDataType>_0`:
   \   000008   03           DB        3
   \   000009   20           DB        32
   \   00000A   2F           DB        47
   \   00000B   ....         DW        ??zclAnalogDataType_0
   \   00000D   38           DB        56
   \   00000E   3A           DB        58
   \   00000F   ....         DW        ??zclAnalogDataType_0
   \   000011   E0           DB        224
   \   000012   E2           DB        226
   \   000013   ....         DW        ??zclAnalogDataType_0
   \   000015   00           DB        0
   \   000016   ....         DW        ??zclAnalogDataType_1
   2958            {
   2959              case ZCL_DATATYPE_UINT8:
   2960              case ZCL_DATATYPE_UINT16:
   2961              case ZCL_DATATYPE_UINT24:
   2962              case ZCL_DATATYPE_UINT32:
   2963              case ZCL_DATATYPE_UINT40:
   2964              case ZCL_DATATYPE_UINT48:
   2965              case ZCL_DATATYPE_UINT56:
   2966              case ZCL_DATATYPE_UINT64:
   2967              case ZCL_DATATYPE_INT8:
   2968              case ZCL_DATATYPE_INT16:
   2969              case ZCL_DATATYPE_INT24:
   2970              case ZCL_DATATYPE_INT32:
   2971              case ZCL_DATATYPE_INT40:
   2972              case ZCL_DATATYPE_INT48:
   2973              case ZCL_DATATYPE_INT56:
   2974              case ZCL_DATATYPE_INT64:
   2975              case ZCL_DATATYPE_SEMI_PREC:
   2976              case ZCL_DATATYPE_SINGLE_PREC:
   2977              case ZCL_DATATYPE_DOUBLE_PREC:
   2978              case ZCL_DATATYPE_TOD:
   2979              case ZCL_DATATYPE_DATE:
   2980              case ZCL_DATATYPE_UTC:
   2981                analog = TRUE;
   \                     ??zclAnalogDataType_0:
   \   000018   7901         MOV     R1,#0x1
   2982                break;
   \   00001A   8002         SJMP    ??zclAnalogDataType_2
   2983          
   2984              default:
   2985                analog = FALSE;
   \                     ??zclAnalogDataType_1:
   \   00001C   7900         MOV     R1,#0x0
   2986                break;
   2987            }
   2988          
   2989            return ( analog );
   \                     ??zclAnalogDataType_2:
   \   00001E   02....       LJMP    ?Subroutine0 & 0xFFFF
   2990          }
   2991          
   2992          /*********************************************************************
   2993           * @fn      zclIsLittleEndianMachine
   2994           *
   2995           * @brief   Verifies endianness in system.
   2996           *
   2997           * @param   none
   2998           *
   2999           * @return  MSB-00 or LSB-01 depending on endianness in the system
   3000           */
   3001          static int zclIsLittleEndianMachine(void)
   3002          {
   3003            uint16 test = 0x0001;
   3004          
   3005            return (*((uint8 *)(&test)));
   3006          }
   3007          
   3008          /*********************************************************************
   3009           * @fn      zcl_BuildAnalogData
   3010           *
   3011           * @brief   Build an analog arribute out of sequential bytes.
   3012           *
   3013           * @param   dataType - type of data
   3014           * @param   pData - pointer to data
   3015           * @param   pBuf - where to put the data
   3016           *
   3017           * @return  none
   3018           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3019          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
   \                     zcl_BuildAnalogData:
   3020          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
   3021            int current_byte_index;
   3022            int remaining_bytes;
   3023            int step;
   3024          
   3025            remaining_bytes = zclGetAttrDataLength(dataType, pData);
   \   000012                ; Setup parameters for call to function zclGetAttrDataLength
   \   000012   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   3026          
   3027            // decide if move forward or backwards to copy data
   3028            if ( zclIsLittleEndianMachine() )
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   7401         MOV     A,#0x1
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   E4           CLR     A
   \   000020   F0           MOVX    @DPTR,A
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   E0           MOVX    A,@DPTR
   \   000028   600C         JZ      ??zcl_BuildAnalogData_0
   3029            {
   3030              step = 1;
   \   00002A   75..01       MOV     ?V4,#0x1
   \   00002D   75..00       MOV     ?V5,#0x0
   3031              current_byte_index = 0;
   \   000030   7800         MOV     R0,#0x0
   \   000032   7900         MOV     R1,#0x0
   \   000034   8033         SJMP    ??zcl_BuildAnalogData_1
   3032            }
   3033            else
   3034            {
   3035              step = -1;
   \                     ??zcl_BuildAnalogData_0:
   \   000036   75..FF       MOV     ?V4,#-0x1
   \   000039   75..FF       MOV     ?V5,#-0x1
   3036              current_byte_index = remaining_bytes - 1;
   \   00003C   EA           MOV     A,R2
   \   00003D   24FF         ADD     A,#-0x1
   \   00003F   F8           MOV     R0,A
   \   000040   EB           MOV     A,R3
   \   000041   34FF         ADDC    A,#-0x1
   \   000043   8023         SJMP    ??zcl_BuildAnalogData_2
   3037            }
   3038          
   3039            while ( remaining_bytes-- )
   3040            {
   3041              pData[current_byte_index] = *(pBuf++);
   \                     ??zcl_BuildAnalogData_3:
   \   000045   85..82       MOV     DPL,?V0
   \   000048   85..83       MOV     DPH,?V1
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   C0E0         PUSH    A
   \   00004E   EE           MOV     A,R6
   \   00004F   28           ADD     A,R0
   \   000050   F582         MOV     DPL,A
   \   000052   EF           MOV     A,R7
   \   000053   39           ADDC    A,R1
   \   000054   F583         MOV     DPH,A
   \   000056   D0E0         POP     A
   \   000058   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   00005B   8582..       MOV     ?V0,DPL
   \   00005E   8583..       MOV     ?V1,DPH
   3042              current_byte_index += step;
   \   000061   E8           MOV     A,R0
   \   000062   25..         ADD     A,?V4
   \   000064   F8           MOV     R0,A
   \   000065   E9           MOV     A,R1
   \   000066   35..         ADDC    A,?V5
   \                     ??zcl_BuildAnalogData_2:
   \   000068   F9           MOV     R1,A
   3043            }
   \                     ??zcl_BuildAnalogData_1:
   \   000069   EA           MOV     A,R2
   \   00006A   FC           MOV     R4,A
   \   00006B   EB           MOV     A,R3
   \   00006C   FD           MOV     R5,A
   \   00006D   EC           MOV     A,R4
   \   00006E   24FF         ADD     A,#-0x1
   \   000070   1A           DEC     R2
   \   000071   ED           MOV     A,R5
   \   000072   34FF         ADDC    A,#-0x1
   \   000074   FB           MOV     R3,A
   \   000075   EC           MOV     A,R4
   \   000076   4D           ORL     A,R5
   \   000077   70CC         JNZ     ??zcl_BuildAnalogData_3
   3044          }
   \   000079   7402         MOV     A,#0x2
   \   00007B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007E   02....       LJMP    ?Subroutine4 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine140:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0
   \   000004   85..83       MOV     DPH,?V1
   \   000007   A3           INC     DPTR
   \   000008   22           RET
   3045          #endif // ZCL_REPORT
   3046          
   3047          /*********************************************************************
   3048           * @fn      zclGetDataTypeLength
   3049           *
   3050           * @brief   Return the length of the datatype in octet.
   3051           *
   3052           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   3053           *                ZCL_DATATYPE_CHAR_STR data types.
   3054           *
   3055           * @param   dataType - data type
   3056           *
   3057           * @return  length of data
   3058           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3059          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   3060          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   3061            uint8 len;
   3062          
   3063            switch ( dataType )
   \   000001   24F8         ADD     A,#-0x8
   \   000003   6078         JZ      ??zclGetDataTypeLength_0
   \   000005   14           DEC     A
   \   000006   6079         JZ      ??zclGetDataTypeLength_1
   \   000008   14           DEC     A
   \   000009   607A         JZ      ??zclGetDataTypeLength_2
   \   00000B   14           DEC     A
   \   00000C   607B         JZ      ??zclGetDataTypeLength_3
   \   00000E   24FB         ADD     A,#-0x5
   \   000010   606B         JZ      ??zclGetDataTypeLength_0
   \   000012   24F8         ADD     A,#-0x8
   \   000014   6067         JZ      ??zclGetDataTypeLength_0
   \   000016   14           DEC     A
   \   000017   6068         JZ      ??zclGetDataTypeLength_1
   \   000019   14           DEC     A
   \   00001A   6069         JZ      ??zclGetDataTypeLength_2
   \   00001C   14           DEC     A
   \   00001D   606A         JZ      ??zclGetDataTypeLength_3
   \   00001F   24FB         ADD     A,#-0x5
   \   000021   605A         JZ      ??zclGetDataTypeLength_0
   \   000023   14           DEC     A
   \   000024   605B         JZ      ??zclGetDataTypeLength_1
   \   000026   14           DEC     A
   \   000027   605C         JZ      ??zclGetDataTypeLength_2
   \   000029   14           DEC     A
   \   00002A   605D         JZ      ??zclGetDataTypeLength_3
   \   00002C   14           DEC     A
   \   00002D   605E         JZ      ??zclGetDataTypeLength_4
   \   00002F   14           DEC     A
   \   000030   605F         JZ      ??zclGetDataTypeLength_5
   \   000032   14           DEC     A
   \   000033   6060         JZ      ??zclGetDataTypeLength_6
   \   000035   14           DEC     A
   \   000036   6061         JZ      ??zclGetDataTypeLength_7
   \   000038   14           DEC     A
   \   000039   6042         JZ      ??zclGetDataTypeLength_0
   \   00003B   14           DEC     A
   \   00003C   6043         JZ      ??zclGetDataTypeLength_1
   \   00003E   14           DEC     A
   \   00003F   6044         JZ      ??zclGetDataTypeLength_2
   \   000041   14           DEC     A
   \   000042   6045         JZ      ??zclGetDataTypeLength_3
   \   000044   14           DEC     A
   \   000045   6046         JZ      ??zclGetDataTypeLength_4
   \   000047   14           DEC     A
   \   000048   6047         JZ      ??zclGetDataTypeLength_5
   \   00004A   14           DEC     A
   \   00004B   6048         JZ      ??zclGetDataTypeLength_6
   \   00004D   14           DEC     A
   \   00004E   6049         JZ      ??zclGetDataTypeLength_7
   \   000050   14           DEC     A
   \   000051   602A         JZ      ??zclGetDataTypeLength_0
   \   000053   14           DEC     A
   \   000054   602B         JZ      ??zclGetDataTypeLength_1
   \   000056   24F9         ADD     A,#-0x7
   \   000058   6027         JZ      ??zclGetDataTypeLength_1
   \   00005A   14           DEC     A
   \   00005B   602C         JZ      ??zclGetDataTypeLength_3
   \   00005D   14           DEC     A
   \   00005E   6039         JZ      ??zclGetDataTypeLength_7
   \   000060   245A         ADD     A,#0x5a
   \   000062   6025         JZ      ??zclGetDataTypeLength_3
   \   000064   14           DEC     A
   \   000065   6022         JZ      ??zclGetDataTypeLength_3
   \   000067   14           DEC     A
   \   000068   601F         JZ      ??zclGetDataTypeLength_3
   \   00006A   24FA         ADD     A,#-0x6
   \   00006C   6013         JZ      ??zclGetDataTypeLength_1
   \   00006E   14           DEC     A
   \   00006F   6010         JZ      ??zclGetDataTypeLength_1
   \   000071   14           DEC     A
   \   000072   6015         JZ      ??zclGetDataTypeLength_3
   \   000074   24FA         ADD     A,#-0x6
   \   000076   6021         JZ      ??zclGetDataTypeLength_7
   \   000078   14           DEC     A
   \   000079   6022         JZ      ??zclGetDataTypeLength_8
   \   00007B   8024         SJMP    ??zclGetDataTypeLength_9
   3064            {
   3065              case ZCL_DATATYPE_DATA8:
   3066              case ZCL_DATATYPE_BOOLEAN:
   3067              case ZCL_DATATYPE_BITMAP8:
   3068              case ZCL_DATATYPE_INT8:
   3069              case ZCL_DATATYPE_UINT8:
   3070              case ZCL_DATATYPE_ENUM8:
   3071                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   00007D   7901         MOV     R1,#0x1
   3072                break;
   \   00007F   8022         SJMP    ??zclGetDataTypeLength_10
   3073          
   3074              case ZCL_DATATYPE_DATA16:
   3075              case ZCL_DATATYPE_BITMAP16:
   3076              case ZCL_DATATYPE_UINT16:
   3077              case ZCL_DATATYPE_INT16:
   3078              case ZCL_DATATYPE_ENUM16:
   3079              case ZCL_DATATYPE_SEMI_PREC:
   3080              case ZCL_DATATYPE_CLUSTER_ID:
   3081              case ZCL_DATATYPE_ATTR_ID:
   3082                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000081   7902         MOV     R1,#0x2
   3083                break;
   \   000083   801E         SJMP    ??zclGetDataTypeLength_10
   3084          
   3085              case ZCL_DATATYPE_DATA24:
   3086              case ZCL_DATATYPE_BITMAP24:
   3087              case ZCL_DATATYPE_UINT24:
   3088              case ZCL_DATATYPE_INT24:
   3089                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   000085   7903         MOV     R1,#0x3
   3090                break;
   \   000087   801A         SJMP    ??zclGetDataTypeLength_10
   3091          
   3092              case ZCL_DATATYPE_DATA32:
   3093              case ZCL_DATATYPE_BITMAP32:
   3094              case ZCL_DATATYPE_UINT32:
   3095              case ZCL_DATATYPE_INT32:
   3096              case ZCL_DATATYPE_SINGLE_PREC:
   3097              case ZCL_DATATYPE_TOD:
   3098              case ZCL_DATATYPE_DATE:
   3099              case ZCL_DATATYPE_UTC:
   3100              case ZCL_DATATYPE_BAC_OID:
   3101                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   000089   7904         MOV     R1,#0x4
   3102                break;
   \   00008B   8016         SJMP    ??zclGetDataTypeLength_10
   3103          
   3104             case ZCL_DATATYPE_UINT40:
   3105             case ZCL_DATATYPE_INT40:
   3106                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   00008D   7905         MOV     R1,#0x5
   3107                 break;
   \   00008F   8012         SJMP    ??zclGetDataTypeLength_10
   3108          
   3109             case ZCL_DATATYPE_UINT48:
   3110             case ZCL_DATATYPE_INT48:
   3111                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000091   7906         MOV     R1,#0x6
   3112                 break;
   \   000093   800E         SJMP    ??zclGetDataTypeLength_10
   3113          
   3114             case ZCL_DATATYPE_UINT56:
   3115             case ZCL_DATATYPE_INT56:
   3116                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   000095   7907         MOV     R1,#0x7
   3117                 break;
   \   000097   800A         SJMP    ??zclGetDataTypeLength_10
   3118          
   3119             case ZCL_DATATYPE_DOUBLE_PREC:
   3120             case ZCL_DATATYPE_IEEE_ADDR:
   3121             case ZCL_DATATYPE_UINT64:
   3122             case ZCL_DATATYPE_INT64:
   3123               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   000099   7908         MOV     R1,#0x8
   3124               break;
   \   00009B   8006         SJMP    ??zclGetDataTypeLength_10
   3125          
   3126              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   3127               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   00009D   7910         MOV     R1,#0x10
   3128               break;
   \   00009F   8002         SJMP    ??zclGetDataTypeLength_10
   3129          
   3130              case ZCL_DATATYPE_NO_DATA:
   3131              case ZCL_DATATYPE_UNKNOWN:
   3132                // Fall through
   3133          
   3134              default:
   3135                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000A1   7900         MOV     R1,#0x0
   3136                break;
   3137            }
   3138          
   3139            return ( len );
   \                     ??zclGetDataTypeLength_10:
   \   0000A3   02....       LJMP    ?BRET
   3140          }
   3141          
   3142          /*********************************************************************
   3143           * @fn      zclGetAttrDataLength
   3144           *
   3145           * @brief   Return the length of the attribute.
   3146           *
   3147           * @param   dataType - data type
   3148           * @param   pData - pointer to data
   3149           *
   3150           * @return  returns atrribute length
   3151           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3152          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   3153          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   3154            uint16 dataLen = 0;
   3155          
   3156            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000007   7444         MOV     A,#0x44
   \   000009   6E           XRL     A,R6
   \   00000A   6005         JZ      ??zclGetAttrDataLength_0
   \   00000C   7443         MOV     A,#0x43
   \   00000E   6E           XRL     A,R6
   \   00000F   700C         JNZ     ??zclGetAttrDataLength_1
   3157            {
   3158              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   12....       LCALL   ?Subroutine110 & 0xFFFF
   3159            }
   \                     ??CrossCallReturnLabel_195:
   \   000018   FA           MOV     R2,A
   \   000019   E4           CLR     A
   \   00001A   39           ADDC    A,R1
   \   00001B   8015         SJMP    ??zclGetAttrDataLength_2
   3160            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   00001D   7442         MOV     A,#0x42
   \   00001F   6E           XRL     A,R6
   \   000020   6005         JZ      ??zclGetAttrDataLength_3
   \   000022   7441         MOV     A,#0x41
   \   000024   6E           XRL     A,R6
   \   000025   700E         JNZ     ??zclGetAttrDataLength_4
   3161            {
   3162              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_3:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   2401         ADD     A,#0x1
   \   00002E   FA           MOV     R2,A
   \   00002F   E4           CLR     A
   \   000030   3400         ADDC    A,#0x0
   \                     ??zclGetAttrDataLength_2:
   \   000032   FB           MOV     R3,A
   \   000033   8007         SJMP    ??zclGetAttrDataLength_5
   3163            }
   3164            else
   3165            {
   3166              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_4:
   \   000035                ; Setup parameters for call to function zclGetDataTypeLength
   \   000035   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000038   E9           MOV     A,R1
   \   000039   FA           MOV     R2,A
   \   00003A   7B00         MOV     R3,#0x0
   3167            }
   3168          
   3169            return ( dataLen );
   \                     ??zclGetAttrDataLength_5:
   \   00003C   02....       LJMP    ??Subroutine193_0 & 0xFFFF
   3170          }
   3171          
   3172          #ifdef ZCL_READ
   3173          /*********************************************************************
   3174           * @fn      zclReadAttrData
   3175           *
   3176           * @brief   Read the attribute's current value into pAttrData.
   3177           *          NOTE - Not compatible with application's attributes callbacks.
   3178           *
   3179           * @param   pAttrData - where to put attribute data
   3180           * @param   pAttr - pointer to attribute
   3181           * @param   pDataLen - where to put attribute data length
   3182           *
   3183           * @return Success
   3184           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3185          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   3186          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3187            uint16 dataLen;
   3188          
   3189            if ( pAttr->attr.dataPtr == NULL )
   \   000009   EC           MOV     A,R4
   \   00000A   2406         ADD     A,#0x6
   \   00000C   F8           MOV     R0,A
   \   00000D   E4           CLR     A
   \   00000E   3D           ADDC    A,R5
   \   00000F   F9           MOV     R1,A
   \   000010   88..         MOV     ?V0,R0
   \   000012   89..         MOV     ?V1,R1
   \   000014   8882         MOV     DPL,R0
   \   000016   F583         MOV     DPH,A
   \   000018   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_312:
   \   00001B   7004         JNZ     ??zclReadAttrData_0
   3190            {
   3191              return ( ZCL_STATUS_FAILURE );
   \   00001D   7901         MOV     R1,#0x1
   \   00001F   804C         SJMP    ??zclReadAttrData_1
   3192            }
   3193          
   3194            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \                     ??zclReadAttrData_0:
   \   000021                ; Setup parameters for call to function zclGetAttrDataLength
   \   000021   8C82         MOV     DPL,R4
   \   000023   8D83         MOV     DPH,R5
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F9           MOV     R1,A
   \   00002B   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   00002E   8A..         MOV     ?V2,R2
   \   000030   8B..         MOV     ?V3,R3
   3195            zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   000032                ; Setup parameters for call to function osal_memcpy
   \   000032   85..82       MOV     DPL,?V0
   \   000035   85..83       MOV     DPH,?V1
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   85....       MOV     ?V4,?V0
   \   000040   F5..         MOV     ?V5,A
   \   000042   75..00       MOV     ?V6,#0x0
   \   000045   78..         MOV     R0,#?V4
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00004A   AC..         MOV     R4,?V2
   \   00004C   AD..         MOV     R5,?V3
   \   00004E   EE           MOV     A,R6
   \   00004F   FA           MOV     R2,A
   \   000050   EF           MOV     A,R7
   \   000051   FB           MOV     R3,A
   \   000052   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000055   7403         MOV     A,#0x3
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   740F         MOV     A,#0xf
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   3196          
   3197            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_346:
   \   000062   6007         JZ      ??zclReadAttrData_2
   3198            {
   3199              *pDataLen = dataLen;
   \   000064   E5..         MOV     A,?V2
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   E5..         MOV     A,?V3
   \   00006A   F0           MOVX    @DPTR,A
   3200            }
   3201          
   3202            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_2:
   \   00006B   7900         MOV     R1,#0x0
   \                     ??zclReadAttrData_1:
   \   00006D                REQUIRE ?Subroutine8
   \   00006D                ; // Fall through to label ?Subroutine8
   3203          }
   3204          
   3205          /*********************************************************************
   3206           * @fn      zcl_ReadAttrData
   3207           *
   3208           * @brief   Read the attribute's current value into pAttrData.
   3209           *          Use application's callback function if assigned to this attribute.
   3210           *
   3211           * @param   endpoint - application's endpoint
   3212           * @param   clusterId - cluster that attribute belongs to
   3213           * @param   attrId - attribute id
   3214           * @param   pAttrData - where to put attribute data
   3215           * @param   pDataLen - where to put attribute data length
   3216           *
   3217           * @return  Successful if data was read
   3218           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine194_0
   \   000003                ; // Fall through to label ??Subroutine194_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3219          ZStatus_t zcl_ReadAttrData( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zcl_ReadAttrData:
   3220                                                   uint8 *pAttrData, uint16 *pDataLen )
   3221          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V2,R1
   \   00000C   8A..         MOV     ?V0,R2
   \   00000E   8B..         MOV     ?V1,R3
   \   000010   EC           MOV     A,R4
   \   000011   FE           MOV     R6,A
   \   000012   ED           MOV     A,R5
   \   000013   FF           MOV     R7,A
   3222            zclAttrRec_t attrRec;
   3223          
   3224            if ( zclFindAttrRec( endpoint, clusterId, attrId, &attrRec ) == FALSE )
   \   000014                ; Setup parameters for call to function zclFindAttrRec
   \   000014   A8..         MOV     R0,?XSP + 0
   \   000016   A9..         MOV     R1,?XSP + 1
   \   000018   88..         MOV     ?V4,R0
   \   00001A   89..         MOV     ?V5,R1
   \   00001C   78..         MOV     R0,#?V4
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   A9..         MOV     R1,?V2
   \   000023   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000026   7402         MOV     A,#0x2
   \   000028   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002B   E9           MOV     A,R1
   \   00002C   7004         JNZ     ??zcl_ReadAttrData_0
   3225            {
   3226              return ( ZCL_STATUS_FAILURE );
   \   00002E   7901         MOV     R1,#0x1
   \   000030   804C         SJMP    ??zcl_ReadAttrData_1
   3227            }
   \                     ??zcl_ReadAttrData_0:
   \   000032   7418         MOV     A,#0x18
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   00003A   741A         MOV     A,#0x1a
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   12....       LCALL   ?Subroutine81 & 0xFFFF
   3228          
   3229            if ( attrRec.attr.dataPtr != NULL )
   \                     ??CrossCallReturnLabel_140:
   \   000042   7406         MOV     A,#0x6
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_375:
   \   00004A   78..         MOV     R0,#?V4
   \   00004C   6016         JZ      ??zcl_ReadAttrData_2
   3230            {
   3231              return zclReadAttrData( pAttrData, &attrRec, pDataLen );
   \   00004E                ; Setup parameters for call to function zclReadAttrData
   \   00004E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000051   7402         MOV     A,#0x2
   \   000053   12....       LCALL   ?XSTACK_DISP102_8
   \   000056   AA..         MOV     R2,?V6
   \   000058   AB..         MOV     R3,?V7
   \   00005A   12....       LCALL   `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   00005D   7402         MOV     A,#0x2
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   801A         SJMP    ??zcl_ReadAttrData_1
   3232            }
   3233            else
   3234            {
   3235              return zclReadAttrDataUsingCB( endpoint, clusterId, attrId, pAttrData, pDataLen );
   \                     ??zcl_ReadAttrData_2:
   \   000064                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000067   78..         MOV     R0,#?V6
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   EE           MOV     A,R6
   \   00006D   FC           MOV     R4,A
   \   00006E   EF           MOV     A,R7
   \   00006F   FD           MOV     R5,A
   \   000070   AA..         MOV     R2,?V0
   \   000072   AB..         MOV     R3,?V1
   \   000074   A9..         MOV     R1,?V2
   \   000076   12....       LCALL   `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   000079   7404         MOV     A,#0x4
   \   00007B   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zcl_ReadAttrData_1:
   \   00007E   7408         MOV     A,#0x8
   3236            }
   \   000080   02....       LJMP    ?Subroutine9 & 0xFFFF
   3237          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine108:
   \   000000   12....       LCALL   ??Subroutine215_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_498:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine215_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V6,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V7,A
   \   000007   22           RET
   3238          
   3239          /*********************************************************************
   3240           * @fn      zclGetAttrDataLengthUsingCB
   3241           *
   3242           * @brief   Use application's callback to get the length of the attribute's
   3243           *          current value stored in the database.
   3244           *
   3245           * @param   endpoint - application's endpoint
   3246           * @param   clusterId - cluster that attribute belongs to
   3247           * @param   attrId - attribute id
   3248           *
   3249           * @return  returns attribute length
   3250           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3251          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   \                     zclGetAttrDataLengthUsingCB:
   3252          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3253            uint16 dataLen = 0;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   E4           CLR     A
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
   3254            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00001C                ; Setup parameters for call to function zclGetReadWriteCB
   \   00001C   12....       LCALL   `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   00001F   8A..         MOV     ?V0,R2
   \   000021   8B..         MOV     ?V1,R3
   3255          
   3256            if ( pfnReadWriteCB != NULL )
   \   000023   EA           MOV     A,R2
   \   000024   45..         ORL     A,?V1
   \   000026   602F         JZ      ??zclGetAttrDataLengthUsingCB_0
   3257            {
   3258              // Only get the attribute length
   3259              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   \   000028                ; Setup parameters for indirect call
   \   000028   A8..         MOV     R0,?XSP + 0
   \   00002A   A9..         MOV     R1,?XSP + 1
   \   00002C   88..         MOV     ?V6,R0
   \   00002E   89..         MOV     ?V7,R1
   \   000030   78..         MOV     R0,#?V6
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000035   E4           CLR     A
   \   000036   F5..         MOV     ?V6,A
   \   000038   F5..         MOV     ?V7,A
   \   00003A   78..         MOV     R0,#?V6
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003F   7900         MOV     R1,#0x0
   \   000041   EE           MOV     A,R6
   \   000042   FC           MOV     R4,A
   \   000043   EF           MOV     A,R7
   \   000044   FD           MOV     R5,A
   \   000045   AA..         MOV     R2,?V4
   \   000047   AB..         MOV     R3,?V5
   \   000049   85..82       MOV     DPL,?V0
   \   00004C   85..83       MOV     DPH,?V1
   \   00004F   12....       LCALL   ?CALL_IND
   \   000052   7404         MOV     A,#0x4
   \   000054   12....       LCALL   ?DEALLOC_XSTACK8
   3260            }
   3261          
   3262            return ( dataLen );
   \                     ??zclGetAttrDataLengthUsingCB_0:
   \   000057   85..82       MOV     DPL,?XSP + 0
   \   00005A   85..83       MOV     DPH,?XSP + 1
   \   00005D   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_394:
   \   000060   7402         MOV     A,#0x2
   \   000062   02....       LJMP    ?Subroutine9 & 0xFFFF
   3263          }
   3264          
   3265          /*********************************************************************
   3266           * @fn      zclReadAttrDataUsingCB
   3267           *
   3268           * @brief   Use application's callback to read the attribute's current
   3269           *          value stored in the database.
   3270           *
   3271           * @param   endpoint - application's endpoint
   3272           * @param   clusterId - cluster that attribute belongs to
   3273           * @param   attrId - attribute id
   3274           * @param   pAttrData - where to put attribute data
   3275           * @param   pDataLen - where to put attribute data length
   3276           *
   3277           * @return  Successful if data was read
   3278           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3279          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclReadAttrDataUsingCB:
   3280                                                   uint8 *pAttrData, uint16 *pDataLen )
   3281          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   3282            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00000D                ; Setup parameters for call to function zclGetReadWriteCB
   \   00000D   12....       LCALL   `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   000010   8A..         MOV     ?V2,R2
   \   000012   8B..         MOV     ?V3,R3
   \   000014   7412         MOV     A,#0x12
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   12....       LCALL   ?Subroutine108 & 0xFFFF
   3283          
   3284            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_190:
   \   00001C   E5..         MOV     A,?V6
   \   00001E   45..         ORL     A,?V7
   \   000020   600A         JZ      ??zclReadAttrDataUsingCB_0
   3285            {
   3286              *pDataLen = 0; // Always initialize it to 0
   \   000022   85..82       MOV     DPL,?V6
   \   000025   85..83       MOV     DPH,?V7
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   F0           MOVX    @DPTR,A
   3287            }
   3288          
   3289            if ( pfnReadWriteCB != NULL )
   \                     ??zclReadAttrDataUsingCB_0:
   \   00002C   EA           MOV     A,R2
   \   00002D   45..         ORL     A,?V3
   \   00002F   6027         JZ      ??zclReadAttrDataUsingCB_1
   3290            {
   3291              // Read the attribute value and its length
   3292              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   \   000031                ; Setup parameters for indirect call
   \   000031   78..         MOV     R0,#?V6
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000036   7412         MOV     A,#0x12
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00003E   7901         MOV     R1,#0x1
   \   000040   EE           MOV     A,R6
   \   000041   FC           MOV     R4,A
   \   000042   EF           MOV     A,R7
   \   000043   FD           MOV     R5,A
   \   000044   AA..         MOV     R2,?V0
   \   000046   AB..         MOV     R3,?V1
   \   000048   85..82       MOV     DPL,?V2
   \   00004B   85..83       MOV     DPH,?V3
   \   00004E   12....       LCALL   ?CALL_IND
   \   000051   7404         MOV     A,#0x4
   \   000053   12....       LCALL   ?DEALLOC_XSTACK8
   \   000056   8002         SJMP    ??zclReadAttrDataUsingCB_2
   3293            }
   3294          
   3295            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   \                     ??zclReadAttrDataUsingCB_1:
   \   000058   79C1         MOV     R1,#-0x3f
   \                     ??zclReadAttrDataUsingCB_2:
   \   00005A   02....       LJMP    ??Subroutine194_0 & 0xFFFF
   3296          }
   3297          
   3298          /*********************************************************************
   3299           * @fn      zclAuthorizeRead
   3300           *
   3301           * @brief   Use application's callback to authorize a Read operation
   3302           *          on a given attribute.
   3303           *
   3304           * @param   endpoint - application's endpoint
   3305           * @param   srcAddr - source Address
   3306           * @param   pAttr - pointer to attribute
   3307           *
   3308           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3309           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3310           */
   3311          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   3312          {
   3313            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   3314            {
   3315              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   3316          
   3317              if ( pfnAuthorizeCB != NULL )
   3318              {
   3319                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   3320              }
   3321            }
   3322          
   3323            return ( ZCL_STATUS_SUCCESS );
   3324          }
   3325          #endif // ZCL_READ
   3326          
   3327          #ifdef ZCL_WRITE
   3328          /*********************************************************************
   3329           * @fn      zclWriteAttrData
   3330           *
   3331           * @brief   Write the received data.
   3332           *
   3333           * @param   endpoint - application's endpoint
   3334           * @param   pAttr - where to write data to
   3335           * @param   pWriteRec - data to be written
   3336           *
   3337           * @return  Successful if data was written
   3338           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3339          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrData:
   3340                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   3341          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   3342            uint8 status;
   3343          
   3344            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   A2E1         MOV     C,0xE0 /* A   */.1
   \   000015   5077         JNC     ??zclWriteAttrData_0
   3345            {
   3346              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000017                ; Setup parameters for call to function zclAuthorizeWrite
   \   000017   12....       LCALL   `??zclAuthorizeWrite::?relay`; Banked call to: zclAuthorizeWrite
   \   00001A   E9           MOV     A,R1
   \   00001B   F5..         MOV     ?V2,A
   3347              if ( status == ZCL_STATUS_SUCCESS )
   \   00001D   7072         JNZ     ??zclWriteAttrData_1
   \   00001F   740F         MOV     A,#0xf
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ?Subroutine150 & 0xFFFF
   3348              {
   3349                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \                     ??CrossCallReturnLabel_267:
   \   000027   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   00002A   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_376:
   \   00002D   6013         JZ      ??zclWriteAttrData_2
   \   00002F                ; Setup parameters for indirect call
   \   00002F   AC..         MOV     R4,?V0
   \   000031   AD..         MOV     R5,?V1
   \   000033   EE           MOV     A,R6
   \   000034   FA           MOV     R2,A
   \   000035   EF           MOV     A,R7
   \   000036   FB           MOV     R3,A
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F583         MOV     DPH,A
   \   00003A   8882         MOV     DPL,R0
   \   00003C   12....       LCALL   ?CALL_IND
   \   00003F   E9           MOV     A,R1
   \   000040   6047         JZ      ??zclWriteAttrData_3
   3350                {
   3351                  // Write the attribute value
   3352                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000042   E5..         MOV     A,?V0
   \   000044   2403         ADD     A,#0x3
   \   000046   F8           MOV     R0,A
   \   000047   E4           CLR     A
   \   000048   35..         ADDC    A,?V1
   \   00004A   F9           MOV     R1,A
   \   00004B   88..         MOV     ?V0,R0
   \   00004D   89..         MOV     ?V1,R1
   \   00004F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00004F   8882         MOV     DPL,R0
   \   000051   F583         MOV     DPH,A
   \   000053   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_395:
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000063   8A..         MOV     ?V4,R2
   \   000065   8B..         MOV     ?V5,R3
   \   000067   AC..         MOV     R4,?V4
   \   000069   AD..         MOV     R5,?V5
   3353                  zcl_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   00006B                ; Setup parameters for call to function osal_memcpy
   \   00006B   85..82       MOV     DPL,?V0
   \   00006E   85..83       MOV     DPH,?V1
   \   000071   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000077   8E82         MOV     DPL,R6
   \   000079   8F83         MOV     DPH,R7
   \   00007B   A3           INC     DPTR
   \   00007C   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_403:
   \   00007F   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000082   7403         MOV     A,#0x3
   \   000084   12....       LCALL   ?DEALLOC_XSTACK8
   3354          
   3355                  status = ZCL_STATUS_SUCCESS;
   \   000087   8008         SJMP    ??zclWriteAttrData_1
   3356                }
   3357                else
   3358                {
   3359                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   000089   75..87       MOV     ?V2,#-0x79
   \   00008C   8003         SJMP    ??zclWriteAttrData_1
   3360                }
   3361              }
   3362            }
   3363            else
   3364            {
   3365              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_0:
   \   00008E   75..88       MOV     ?V2,#-0x78
   3366            }
   3367          
   3368            return ( status );
   \                     ??zclWriteAttrData_1:
   \   000091   A9..         MOV     R1,?V2
   \   000093   02....       LJMP    ?Subroutine8 & 0xFFFF
   3369          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine150:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V1,A
   \   000007   22           RET
   3370          
   3371          /*********************************************************************
   3372           * @fn      zclWriteAttrDataUsingCB
   3373           *
   3374           * @brief   Use application's callback to write the attribute's current
   3375           *          value stored in the database.
   3376           *
   3377           * @param   endpoint - application's endpoint
   3378           * @param   pAttr - where to write data to
   3379           * @param   pAttrData - data to be written
   3380           *
   3381           * @return  Successful if data was written
   3382           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3383          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrDataUsingCB:
   3384                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   3385          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   EC           MOV     A,R4
   \   000008   FE           MOV     R6,A
   \   000009   ED           MOV     A,R5
   \   00000A   FF           MOV     R7,A
   3386            uint8 status;
   3387          
   3388            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00000B   8E82         MOV     DPL,R6
   \   00000D   8F83         MOV     DPH,R7
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   A2E1         MOV     C,0xE0 /* A   */.1
   \   000017   504D         JNC     ??zclWriteAttrDataUsingCB_0
   3389            {
   3390              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000019                ; Setup parameters for call to function zclAuthorizeWrite
   \   000019   12....       LCALL   `??zclAuthorizeWrite::?relay`; Banked call to: zclAuthorizeWrite
   \   00001C   E9           MOV     A,R1
   \   00001D   F9           MOV     R1,A
   3391              if ( status == ZCL_STATUS_SUCCESS )
   \   00001E   7048         JNZ     ??zclWriteAttrDataUsingCB_1
   3392              {
   3393                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000020                ; Setup parameters for call to function zclGetReadWriteCB
   \   000020   A9..         MOV     R1,?V0
   \   000022   12....       LCALL   `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   000025   8A..         MOV     ?V2,R2
   \   000027   8B..         MOV     ?V3,R3
   3394                if ( pfnReadWriteCB != NULL )
   \   000029   EA           MOV     A,R2
   \   00002A   45..         ORL     A,?V3
   \   00002C   6034         JZ      ??zclWriteAttrDataUsingCB_2
   3395                {
   3396                  // Write the attribute value
   3397                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
   3398                                              ZCL_OPER_WRITE, pAttrData, NULL );
   \   00002E                ; Setup parameters for indirect call
   \   00002E   E4           CLR     A
   \   00002F   F5..         MOV     ?V4,A
   \   000031   F5..         MOV     ?V5,A
   \   000033   78..         MOV     R0,#?V4
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000038   7410         MOV     A,#0x10
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000040   7902         MOV     R1,#0x2
   \   000042   8E82         MOV     DPL,R6
   \   000044   8F83         MOV     DPH,R7
   \   000046   12....       LCALL   ??Subroutine212_0 & 0xFFFF
   3399                }
   \                     ??CrossCallReturnLabel_488:
   \   000049   8E82         MOV     DPL,R6
   \   00004B   8F83         MOV     DPH,R7
   \   00004D   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_396:
   \   000050   85..82       MOV     DPL,?V2
   \   000053   85..83       MOV     DPH,?V3
   \   000056   12....       LCALL   ?CALL_IND
   \   000059   7404         MOV     A,#0x4
   \   00005B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005E   E9           MOV     A,R1
   \   00005F   F9           MOV     R1,A
   \   000060   8006         SJMP    ??zclWriteAttrDataUsingCB_1
   3400                else
   3401                {
   3402                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   \                     ??zclWriteAttrDataUsingCB_2:
   \   000062   79C1         MOV     R1,#-0x3f
   \   000064   8002         SJMP    ??zclWriteAttrDataUsingCB_1
   3403                }
   3404              }
   3405            }
   3406            else
   3407            {
   3408              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrDataUsingCB_0:
   \   000066   7988         MOV     R1,#-0x78
   3409            }
   3410          
   3411            return ( status );
   \                     ??zclWriteAttrDataUsingCB_1:
   \   000068                REQUIRE ?Subroutine4
   \   000068                ; // Fall through to label ?Subroutine4
   3412          }
   3413          
   3414          /*********************************************************************
   3415           * @fn      zclAuthorizeWrite
   3416           *
   3417           * @brief   Use application's callback to authorize a Write operation
   3418           *          on a given attribute.
   3419           *
   3420           * @param   endpoint - application's endpoint
   3421           * @param   srcAddr - source Address
   3422           * @param   pAttr - pointer to attribute
   3423           *
   3424           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3425           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3426           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3427          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeWrite:
   3428          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
   3429            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   \   00000D   8C82         MOV     DPL,R4
   \   00000F   8D83         MOV     DPH,R5
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   A2E5         MOV     C,0xE0 /* A   */.5
   \   000019   501C         JNC     ??zclAuthorizeWrite_0
   3430            {
   3431              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00001B                ; Setup parameters for call to function zclGetAuthorizeCB
   \   00001B   12....       LCALL   `??zclGetAuthorizeCB::?relay`; Banked call to: zclGetAuthorizeCB
   \   00001E   8A82         MOV     DPL,R2
   \   000020   8B83         MOV     DPH,R3
   3432          
   3433              if ( pfnAuthorizeCB != NULL )
   \   000022   E582         MOV     A,DPL
   \   000024   4583         ORL     A,DPH
   \   000026   600F         JZ      ??zclAuthorizeWrite_0
   3434              {
   3435                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   \   000028                ; Setup parameters for indirect call
   \   000028   7902         MOV     R1,#0x2
   \   00002A   AC..         MOV     R4,?V0
   \   00002C   AD..         MOV     R5,?V1
   \   00002E   EE           MOV     A,R6
   \   00002F   FA           MOV     R2,A
   \   000030   EF           MOV     A,R7
   \   000031   FB           MOV     R3,A
   \   000032   12....       LCALL   ?CALL_IND
   \   000035   8002         SJMP    ??zclAuthorizeWrite_1
   3436              }
   3437            }
   3438          
   3439            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeWrite_0:
   \   000037   7900         MOV     R1,#0x0
   \                     ??zclAuthorizeWrite_1:
   \   000039   80..         SJMP    ?Subroutine4
   3440          }
   3441          #endif // ZCL_WRITE
   3442          
   3443          #ifdef ZCL_READ
   3444          /*********************************************************************
   3445           * @fn      zclParseInReadCmd
   3446           *
   3447           * @brief   Parse the "Profile" Read Commands
   3448           *
   3449           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3450           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3451           *
   3452           * @param   pCmd - pointer to incoming data to parse
   3453           *
   3454           * @return  pointer to the parsed command structure
   3455           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3456          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   3457          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3458            zclReadCmd_t *readCmd;
   3459            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine99 & 0xFFFF
   3460          
   3461            readCmd = (zclReadCmd_t *)zcl_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \                     ??CrossCallReturnLabel_169:
   \   000008   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   00000B   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3462            if ( readCmd != NULL )
   \   00000E   EA           MOV     A,R2
   \   00000F   4B           ORL     A,R3
   \   000010   6049         JZ      ??zclParseInReadCmd_0
   3463            {
   3464              uint8 i;
   3465              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   000012   85..82       MOV     DPL,?V0
   \   000015   85..83       MOV     DPH,?V1
   \   000018   12....       LCALL   ?Subroutine172 & 0xFFFF
   \                     ??CrossCallReturnLabel_511:
   \   00001B   C3           CLR     C
   \   00001C   13           RRC     A
   \   00001D   E8           MOV     A,R0
   \   00001E   13           RRC     A
   \   00001F   8A82         MOV     DPL,R2
   \   000021   8B83         MOV     DPH,R3
   \   000023   F0           MOVX    @DPTR,A
   3466              for ( i = 0; i < readCmd->numAttr; i++ )
   \   000024   75..00       MOV     ?V0,#0x0
   \   000027   8029         SJMP    ??zclParseInReadCmd_1
   3467              {
   3468                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_2:
   \   000029   8E82         MOV     DPL,R6
   \   00002B   8F83         MOV     DPH,R7
   \   00002D   12....       LCALL   ?Subroutine161 & 0xFFFF
   3469                pBuf += 2;
   3470              }
   \                     ??CrossCallReturnLabel_281:
   \   000030   F8           MOV     R0,A
   \   000031   E4           CLR     A
   \   000032   C8           XCH     A,R0
   \   000033   F9           MOV     R1,A
   \   000034   EC           MOV     A,R4
   \   000035   28           ADD     A,R0
   \   000036   E4           CLR     A
   \   000037   39           ADDC    A,R1
   \   000038   FD           MOV     R5,A
   \   000039   A8..         MOV     R0,?V0
   \   00003B   E8           MOV     A,R0
   \   00003C   28           ADD     A,R0
   \   00003D   F8           MOV     R0,A
   \   00003E   E4           CLR     A
   \   00003F   33           RLC     A
   \   000040   F9           MOV     R1,A
   \   000041   EA           MOV     A,R2
   \   000042   28           ADD     A,R0
   \   000043   F582         MOV     DPL,A
   \   000045   EB           MOV     A,R3
   \   000046   12....       LCALL   ??Subroutine210_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_471:
   \   000049   EC           MOV     A,R4
   \   00004A   12....       LCALL   ??Subroutine205_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_437:
   \   00004D   5001         JNC     ??zclParseInReadCmd_3
   \   00004F   0F           INC     R7
   \                     ??zclParseInReadCmd_3:
   \   000050   05..         INC     ?V0
   \                     ??zclParseInReadCmd_1:
   \   000052   8A82         MOV     DPL,R2
   \   000054   8B83         MOV     DPH,R3
   \   000056   12....       LCALL   ??Subroutine181_0 & 0xFFFF
   3471            }
   \                     ??CrossCallReturnLabel_326:
   \   000059   40CE         JC      ??zclParseInReadCmd_2
   3472          
   3473            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_0:
   \   00005B   02....       LJMP    ?Subroutine1 & 0xFFFF
   3474          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine106:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   8582..       MOV     ?V0,DPL
   \   000008   8583..       MOV     ?V1,DPH
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   2401         ADD     A,#0x1
   \   00000E   FA           MOV     R2,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   3400         ADDC    A,#0x0
   \   000013   FB           MOV     R3,A
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine205_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   ED           MOV     A,R5
   \   000003   12....       LCALL   ??Subroutine204_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_439:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine157 & 0xFFFF
   \                     ??CrossCallReturnLabel_382:
   \   00000A   FE           MOV     R6,A
   \   00000B   E9           MOV     A,R1
   \   00000C   FF           MOV     R7,A
   \   00000D   22           RET
   3475          
   3476          /*********************************************************************
   3477           * @fn      zclParseInReadRspCmd
   3478           *
   3479           * @brief   Parse the "Profile" Read Response Commands
   3480           *
   3481           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3482           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3483           *
   3484           * @param   pCmd - pointer to incoming data to parse
   3485           *
   3486           * @return  pointer to the parsed command structure
   3487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   AA..         MOV     R2,?V10
   \   000002   AB..         MOV     R3,?V11
   \   000004                REQUIRE ??Subroutine177_0
   \   000004                ; // Fall through to label ??Subroutine177_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3488          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   3489          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V8,R2
   \   000007   8B..         MOV     ?V9,R3
   3490            zclReadRspCmd_t *readRspCmd;
   3491            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V4,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V9
   \   000011   F5..         MOV     ?V5,A
   \   000013   85..82       MOV     DPL,?V4
   \   000016   12....       LCALL   ?Subroutine76 & 0xFFFF
   3492            uint8 *dataPtr;
   3493            uint8 numAttr = 0;
   3494            uint8 hdrLen;
   3495            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_127:
   \   000019   8049         SJMP    ??zclParseInReadRspCmd_0
   3496            uint16 attrDataLen;
   3497          
   3498            // find out the number of attributes and the length of attribute data
   3499            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3500            {
   3501              uint8 status;
   3502          
   3503              numAttr++;
   \                     ??zclParseInReadRspCmd_1:
   \   00001B   05..         INC     ?V2
   3504              pBuf += 2; // move pass attribute id
   3505          
   3506              status = *pBuf++;
   \   00001D   8E82         MOV     DPL,R6
   \   00001F   8F83         MOV     DPH,R7
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F8           MOV     R0,A
   \   000025   EE           MOV     A,R6
   \   000026   2403         ADD     A,#0x3
   \   000028   FE           MOV     R6,A
   \   000029   5001         JNC     ??zclParseInReadRspCmd_2
   \   00002B   0F           INC     R7
   3507              if ( status == ZCL_STATUS_SUCCESS )
   \                     ??zclParseInReadRspCmd_2:
   \   00002C   E8           MOV     A,R0
   \   00002D   7035         JNZ     ??zclParseInReadRspCmd_0
   3508              {
   3509                uint8 dataType = *pBuf++;
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F9           MOV     R1,A
   \   000035   A3           INC     DPTR
   \   000036   AE82         MOV     R6,DPL
   \   000038   AF83         MOV     R7,DPH
   3510          
   3511                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   00003A                ; Setup parameters for call to function zclGetAttrDataLength
   \   00003A   EE           MOV     A,R6
   \   00003B   FA           MOV     R2,A
   \   00003C   EF           MOV     A,R7
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000041   8A..         MOV     ?V0,R2
   \   000043   8B..         MOV     ?V1,R3
   3512                pBuf += attrDataLen; // move pass attribute data
   \   000045   EE           MOV     A,R6
   \   000046   2A           ADD     A,R2
   \   000047   FE           MOV     R6,A
   \   000048   EF           MOV     A,R7
   \   000049   35..         ADDC    A,?V1
   \   00004B   FF           MOV     R7,A
   3513          
   3514                // add padding if needed
   3515                if ( PADDING_NEEDED( attrDataLen ) )
   \   00004C   EA           MOV     A,R2
   \   00004D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004F   5007         JNC     ??zclParseInReadRspCmd_3
   3516                {
   3517                  attrDataLen++;
   \   000051   05..         INC     ?V0
   \   000053   04           INC     A
   \   000054   7002         JNZ     ??zclParseInReadRspCmd_3
   \   000056   05..         INC     ?V1
   3518                }
   3519          
   3520                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_3:
   \   000058   E5..         MOV     A,?V6
   \   00005A   25..         ADD     A,?V0
   \   00005C   F5..         MOV     ?V6,A
   \   00005E   E5..         MOV     A,?V7
   \   000060   35..         ADDC    A,?V1
   \   000062   F5..         MOV     ?V7,A
   3521              }
   3522            }
   \                     ??zclParseInReadRspCmd_0:
   \   000064   85..82       MOV     DPL,?V8
   \   000067   85..83       MOV     DPH,?V9
   \   00006A   A3           INC     DPTR
   \   00006B   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   00006E   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_429:
   \   000071   40A8         JC      ??zclParseInReadRspCmd_1
   3523          
   3524            // calculate the length of the response header
   3525            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   000073   75F006       MOV     B,#0x6
   \   000076   E5..         MOV     A,?V2
   \   000078   A4           MUL     AB
   \   000079   04           INC     A
   \   00007A   F5..         MOV     ?V0,A
   3526          
   3527            readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   00007C                ; Setup parameters for call to function osal_mem_alloc
   \   00007C   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   00007F   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000082   8A..         MOV     ?V10,R2
   \   000084   8B..         MOV     ?V11,R3
   3528            if ( readRspCmd != NULL )
   \   000086   EA           MOV     A,R2
   \   000087   45..         ORL     A,?V11
   \   000089   7003         JNZ     $+5
   \   00008B   02....       LJMP    ??zclParseInReadRspCmd_4 & 0xFFFF
   3529            {
   3530              uint8 i;
   3531              pBuf = pCmd->pData;
   \   00008E   85..82       MOV     DPL,?V4
   \   000091   85..83       MOV     DPH,?V5
   \   000094   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   3532              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_421:
   \   000097   A8..         MOV     R0,?V0
   \   000099   EA           MOV     A,R2
   \   00009A   28           ADD     A,R0
   \   00009B   F5..         MOV     ?V8,A
   \   00009D   E4           CLR     A
   \   00009E   3B           ADDC    A,R3
   \   00009F   F5..         MOV     ?V9,A
   3533          
   3534              readRspCmd->numAttr = numAttr;
   \   0000A1   8A82         MOV     DPL,R2
   \   0000A3   8B83         MOV     DPH,R3
   \   0000A5   E5..         MOV     A,?V2
   \   0000A7   F0           MOVX    @DPTR,A
   3535              for ( i = 0; i < numAttr; i++ )
   \   0000A8   75..00       MOV     ?V3,#0x0
   \   0000AB   02....       LJMP    ??zclParseInReadRspCmd_5 & 0xFFFF
   3536              {
   3537                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_6:
   \   0000AE   E5..         MOV     A,?V3
   \   0000B0   75F006       MOV     B,#0x6
   \   0000B3   12....       LCALL   ?Subroutine164 & 0xFFFF
   3538          
   3539                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_283:
   \   0000B6   8E82         MOV     DPL,R6
   \   0000B8   8F83         MOV     DPH,R7
   \   0000BA   12....       LCALL   ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_257:
   \   0000BD   12....       LCALL   ?Subroutine38 & 0xFFFF
   3540                pBuf += 2;
   3541          
   3542                statusRec->status = *pBuf++;
   \                     ??CrossCallReturnLabel_47:
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   F8           MOV     R0,A
   \   0000C4   85..82       MOV     DPL,?V12
   \   0000C7   85..83       MOV     DPH,?V13
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   EE           MOV     A,R6
   \   0000CE   2403         ADD     A,#0x3
   \   0000D0   FE           MOV     R6,A
   \   0000D1   5001         JNC     ??zclParseInReadRspCmd_7
   \   0000D3   0F           INC     R7
   3543                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??zclParseInReadRspCmd_7:
   \   0000D4   E8           MOV     A,R0
   \   0000D5   7064         JNZ     ??zclParseInReadRspCmd_8
   3544                {
   3545                  statusRec->dataType = *pBuf++;
   \   0000D7   8E82         MOV     DPL,R6
   \   0000D9   8F83         MOV     DPH,R7
   \   0000DB   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   0000DE   A3           INC     DPTR
   \   0000DF   12....       LCALL   ?Subroutine33 & 0xFFFF
   3546          
   3547                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_33:
   \   0000E2                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000E2   EE           MOV     A,R6
   \   0000E3   FA           MOV     R2,A
   \   0000E4   EF           MOV     A,R7
   \   0000E5   FB           MOV     R3,A
   \   0000E6   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000E9   8A..         MOV     ?V0,R2
   \   0000EB   8B..         MOV     ?V1,R3
   3548                  zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0000ED                ; Setup parameters for call to function osal_memcpy
   \   0000ED   8E..         MOV     ?V4,R6
   \   0000EF   8F..         MOV     ?V5,R7
   \   0000F1   75..00       MOV     ?V6,#0x0
   \   0000F4   78..         MOV     R0,#?V4
   \   0000F6   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000F9   AC..         MOV     R4,?V0
   \   0000FB   AD..         MOV     R5,?V1
   \   0000FD   AA..         MOV     R2,?V8
   \   0000FF   AB..         MOV     R3,?V9
   \   000101   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000104   7403         MOV     A,#0x3
   \   000106   12....       LCALL   ?DEALLOC_XSTACK8
   3549                  statusRec->data = dataPtr;
   \   000109   85..82       MOV     DPL,?V12
   \   00010C   85..83       MOV     DPH,?V13
   \   00010F   A3           INC     DPTR
   \   000110   A3           INC     DPTR
   \   000111   A3           INC     DPTR
   \   000112   A3           INC     DPTR
   \   000113   E5..         MOV     A,?V8
   \   000115   F0           MOVX    @DPTR,A
   \   000116   A3           INC     DPTR
   \   000117   E5..         MOV     A,?V9
   \   000119   F0           MOVX    @DPTR,A
   3550          
   3551                  pBuf += attrDataLen; // move pass attribute data
   \   00011A   EE           MOV     A,R6
   \   00011B   25..         ADD     A,?V0
   \   00011D   FE           MOV     R6,A
   \   00011E   EF           MOV     A,R7
   \   00011F   35..         ADDC    A,?V1
   \   000121   FF           MOV     R7,A
   3552          
   3553                  // advance attribute data pointer
   3554                  if ( PADDING_NEEDED( attrDataLen ) )
   \   000122   E5..         MOV     A,?V0
   \   000124   A2E0         MOV     C,0xE0 /* A   */.0
   \   000126   5007         JNC     ??zclParseInReadRspCmd_9
   3555                  {
   3556                    attrDataLen++;
   \   000128   05..         INC     ?V0
   \   00012A   04           INC     A
   \   00012B   7002         JNZ     ??zclParseInReadRspCmd_9
   \   00012D   05..         INC     ?V1
   3557                  }
   3558          
   3559                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_9:
   \   00012F   E5..         MOV     A,?V8
   \   000131   25..         ADD     A,?V0
   \   000133   F5..         MOV     ?V8,A
   \   000135   E5..         MOV     A,?V9
   \   000137   35..         ADDC    A,?V1
   \   000139   F5..         MOV     ?V9,A
   3560                }
   3561              }
   \                     ??zclParseInReadRspCmd_8:
   \   00013B   05..         INC     ?V3
   \                     ??zclParseInReadRspCmd_5:
   \   00013D   E5..         MOV     A,?V3
   \   00013F   C3           CLR     C
   \   000140   95..         SUBB    A,?V2
   \   000142   5003         JNC     $+5
   \   000144   02....       LJMP    ??zclParseInReadRspCmd_6 & 0xFFFF
   3562            }
   3563          
   3564            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_4:
   \   000147   02....       LJMP    ?Subroutine7 & 0xFFFF
   3565          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine128:
   \   000000   25..         ADD     A,?V6
   \   000002   FA           MOV     R2,A
   \   000003   E4           CLR     A
   \   000004   35..         ADDC    A,?V7
   \   000006   FB           MOV     R3,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine201_0:
   \   000000   12....       LCALL   ??Subroutine220_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_530:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   12....       LCALL   ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_528:
   \   000003   75..00       MOV     ?V2,#0x0
   \   000006   75..00       MOV     ?V6,#0x0
   \   000009   75..00       MOV     ?V7,#0x0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine203_0:
   \   000000   12....       LCALL   ?Subroutine162 & 0xFFFF
   \                     ??CrossCallReturnLabel_434:
   \   000003   EE           MOV     A,R6
   \   000004   98           SUBB    A,R0
   \   000005   EF           MOV     A,R7
   \   000006   99           SUBB    A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine162:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   F8           MOV     R0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   F9           MOV     R1,A
   \   000007   C3           CLR     C
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine164:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V10
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V11
   \   00000B   39           ADDC    A,R1
   \   00000C   F583         MOV     DPH,A
   \   00000E   A3           INC     DPTR
   \   00000F   8582..       MOV     ?V12,DPL
   \   000012   8583..       MOV     ?V13,DPH
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine152:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   85..82       MOV     DPL,?V12
   \   000005   85..83       MOV     DPH,?V13
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine142:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   EA           MOV     A,R2
   \   000006   85..82       MOV     DPL,?V12
   \   000009   85..83       MOV     DPH,?V13
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   A3           INC     DPTR
   \   00000E   E9           MOV     A,R1
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_508:
   \   000003   85..82       MOV     DPL,?V4
   \   000006   85..83       MOV     DPH,?V5
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine148:
   \   000000   F583         MOV     DPH,A
   \   000002                REQUIRE ??Subroutine220_0
   \   000002                ; // Fall through to label ??Subroutine220_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine220_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   22           RET
   3566          #endif // ZCL_READ
   3567          
   3568          #ifdef ZCL_WRITE
   3569          /*********************************************************************
   3570           * @fn      zclParseInWriteCmd
   3571           *
   3572           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   3573           *          Response Commands
   3574           *
   3575           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3576           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3577           *
   3578           * @param   pCmd - pointer to incoming data to parse
   3579           *
   3580           * @return  pointer to the parsed command structure
   3581           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3582          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   3583          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine73 & 0xFFFF
   3584            zclWriteCmd_t *writeCmd;
   3585            uint8 *pBuf = pCmd->pData;
   3586            uint16 attrDataLen;
   3587            uint8 *dataPtr;
   3588            uint8 numAttr = 0;
   3589            uint8 hdrLen;
   3590            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_123:
   \   000008   801A         SJMP    ??CrossCallReturnLabel_239
   3591          
   3592            // find out the number of attributes and the length of attribute data
   3593            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3594            {
   3595              uint8 dataType;
   3596          
   3597              numAttr++;
   \                     ??zclParseInWriteCmd_0:
   \   00000A   12....       LCALL   ?Subroutine109 & 0xFFFF
   3598              pBuf += 2; // move pass attribute id
   3599          
   3600              dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_192:
   \   00000D   5002         JNC     ??zclParseInWriteCmd_1
   \   00000F   05..         INC     ?V1
   3601          
   3602              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \                     ??zclParseInWriteCmd_1:
   \   000011                ; Setup parameters for call to function zclGetAttrDataLength
   \   000011   FA           MOV     R2,A
   \   000012   AB..         MOV     R3,?V1
   \   000014   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000017   12....       LCALL   ?Subroutine124 & 0xFFFF
   3603              pBuf += attrDataLen; // move pass attribute data
   3604          
   3605              // add padding if needed
   3606              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_224:
   \   00001A   5005         JNC     ??zclParseInWriteCmd_2
   3607              {
   3608                attrDataLen++;
   \   00001C   0E           INC     R6
   \   00001D   04           INC     A
   \   00001E   7001         JNZ     ??zclParseInWriteCmd_2
   \   000020   0F           INC     R7
   3609              }
   3610          
   3611              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_2:
   \   000021   12....       LCALL   ?Subroutine131 & 0xFFFF
   3612            }
   \                     ??CrossCallReturnLabel_239:
   \   000024   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000027   40E1         JC      ??zclParseInWriteCmd_0
   3613          
   3614            // calculate the length of the response header
   3615            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \   000029   75F005       MOV     B,#0x5
   \   00002C   E5..         MOV     A,?V7
   \   00002E   A4           MUL     AB
   \   00002F   04           INC     A
   \   000030   FE           MOV     R6,A
   3616          
   3617            writeCmd = (zclWriteCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000031                ; Setup parameters for call to function osal_mem_alloc
   \   000031   25..         ADD     A,?V4
   \   000033   FA           MOV     R2,A
   \   000034   E4           CLR     A
   \   000035   35..         ADDC    A,?V5
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003B   8A..         MOV     ?V10,R2
   \   00003D   8B..         MOV     ?V11,R3
   3618            if ( writeCmd != NULL )
   \   00003F   EA           MOV     A,R2
   \   000040   45..         ORL     A,?V11
   \   000042   604C         JZ      ??zclParseInWriteCmd_3
   3619            {
   3620              uint8 i;
   3621              pBuf = pCmd->pData;
   \   000044   12....       LCALL   ?Subroutine56 & 0xFFFF
   3622              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   3623          
   3624              writeCmd->numAttr = numAttr;
   3625              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_92:
   \   000047   8040         SJMP    ??CrossCallReturnLabel_235
   3626              {
   3627                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_4:
   \   000049   12....       LCALL   ?Subroutine15 & 0xFFFF
   3628          
   3629                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3630                pBuf += 2;
   3631                statusRec->dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_2:
   \   00004C   5002         JNC     ??zclParseInWriteCmd_5
   \   00004E   05..         INC     ?V1
   3632          
   3633                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??zclParseInWriteCmd_5:
   \   000050                ; Setup parameters for call to function zclGetAttrDataLength
   \   000050   FA           MOV     R2,A
   \   000051   AB..         MOV     R3,?V1
   \   000053   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000056   8A..         MOV     ?V4,R2
   \   000058   8B..         MOV     ?V5,R3
   \   00005A   AE..         MOV     R6,?V4
   \   00005C   AF..         MOV     R7,?V5
   3634                zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   00005E                ; Setup parameters for call to function osal_memcpy
   \   00005E   85....       MOV     ?V4,?V0
   \   000061   85....       MOV     ?V5,?V1
   \   000064   75..00       MOV     ?V6,#0x0
   \   000067   78..         MOV     R0,#?V4
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00006C   EE           MOV     A,R6
   \   00006D   FC           MOV     R4,A
   \   00006E   EF           MOV     A,R7
   \   00006F   FD           MOV     R5,A
   \   000070   AA..         MOV     R2,?V2
   \   000072   AB..         MOV     R3,?V3
   \   000074   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000077   7403         MOV     A,#0x3
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   3635                statusRec->attrData = dataPtr;
   \   00007C   12....       LCALL   ?Subroutine21 & 0xFFFF
   3636          
   3637                pBuf += attrDataLen; // move pass attribute data
   3638          
   3639                // advance attribute data pointer
   3640                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_10:
   \   00007F   5005         JNC     ??zclParseInWriteCmd_6
   3641                {
   3642                  attrDataLen++;
   \   000081   0E           INC     R6
   \   000082   04           INC     A
   \   000083   7001         JNZ     ??zclParseInWriteCmd_6
   \   000085   0F           INC     R7
   3643                }
   3644          
   3645                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_6:
   \   000086   12....       LCALL   ?Subroutine129 & 0xFFFF
   3646              }
   \                     ??CrossCallReturnLabel_235:
   \   000089   E5..         MOV     A,?V8
   \   00008B   C3           CLR     C
   \   00008C   95..         SUBB    A,?V7
   \   00008E   40B9         JC      ??zclParseInWriteCmd_4
   3647            }
   3648          
   3649            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_3:
   \   000090   02....       LJMP    ?Subroutine7 & 0xFFFF
   3650          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine131:
   \   000000   E5..         MOV     A,?V4
   \   000002   2E           ADD     A,R6
   \   000003   F5..         MOV     ?V4,A
   \   000005   E5..         MOV     A,?V5
   \   000007   3F           ADDC    A,R7
   \   000008   F5..         MOV     ?V5,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine129:
   \   000000   E5..         MOV     A,?V2
   \   000002   2E           ADD     A,R6
   \   000003   F5..         MOV     ?V2,A
   \   000005   E5..         MOV     A,?V3
   \   000007   3F           ADDC    A,R7
   \   000008   F5..         MOV     ?V3,A
   \   00000A   05..         INC     ?V8
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine124:
   \   000000   8A..         MOV     ?V10,R2
   \   000002   8B..         MOV     ?V11,R3
   \   000004   AE..         MOV     R6,?V10
   \   000006   AF..         MOV     R7,?V11
   \   000008   E5..         MOV     A,?V0
   \   00000A   2A           ADD     A,R2
   \   00000B   F5..         MOV     ?V0,A
   \   00000D   E5..         MOV     A,?V1
   \   00000F   3F           ADDC    A,R7
   \   000010   F5..         MOV     ?V1,A
   \   000012   EE           MOV     A,R6
   \   000013   A2E0         MOV     C,0xE0 /* A   */.0
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine109:
   \   000000   05..         INC     ?V7
   \   000002   85..82       MOV     DPL,?V0
   \   000005   85..83       MOV     DPH,?V1
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   E5..         MOV     A,?V0
   \   00000E   2403         ADD     A,#0x3
   \   000010   F5..         MOV     ?V0,A
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   8A..         MOV     ?V8,R2
   \   000002   8B..         MOV     ?V9,R3
   \   000004   EA           MOV     A,R2
   \   000005   2403         ADD     A,#0x3
   \   000007   F5..         MOV     ?V2,A
   \   000009   E4           CLR     A
   \   00000A   35..         ADDC    A,?V9
   \   00000C   F5..         MOV     ?V3,A
   \   00000E   85..82       MOV     DPL,?V2
   \   000011   F583         MOV     DPH,A
   \   000013   12....       LCALL   ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_269:
   \   000016   75..00       MOV     ?V7,#0x0
   \   000019   75..00       MOV     ?V4,#0x0
   \   00001C   75..00       MOV     ?V5,#0x0
   \   00001F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006   12....       LCALL   ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   000009   EA           MOV     A,R2
   \   00000A   2E           ADD     A,R6
   \   00000B   F5..         MOV     ?V2,A
   \   00000D   E4           CLR     A
   \   00000E   3B           ADDC    A,R3
   \   00000F   F5..         MOV     ?V3,A
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   E5..         MOV     A,?V7
   \   000017   F0           MOVX    @DPTR,A
   \   000018   75..00       MOV     ?V8,#0x0
   \   00001B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_524:
   \   00000A   12....       LCALL   ?Subroutine162 & 0xFFFF
   \                     ??CrossCallReturnLabel_433:
   \   00000D   E5..         MOV     A,?V0
   \   00000F   98           SUBB    A,R0
   \   000010   E5..         MOV     A,?V1
   \   000012   99           SUBB    A,R1
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   85..82       MOV     DPL,?V12
   \   000003   85..83       MOV     DPH,?V13
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   E5..         MOV     A,?V2
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   E5..         MOV     A,?V3
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   E5..         MOV     A,?V0
   \   000012   2E           ADD     A,R6
   \   000013   F5..         MOV     ?V0,A
   \   000015   E5..         MOV     A,?V1
   \   000017   3F           ADDC    A,R7
   \   000018   F5..         MOV     ?V1,A
   \   00001A   EE           MOV     A,R6
   \   00001B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E5..         MOV     A,?V8
   \   000002   75F005       MOV     B,#0x5
   \   000005   12....       LCALL   ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   000008   85..82       MOV     DPL,?V0
   \   00000B   85..83       MOV     DPH,?V1
   \   00000E   12....       LCALL   ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   000011   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_255:
   \   000014   A3           INC     DPTR
   \   000015   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   000018   F0           MOVX    @DPTR,A
   \   000019   E5..         MOV     A,?V0
   \   00001B   2403         ADD     A,#0x3
   \   00001D   F5..         MOV     ?V0,A
   \   00001F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine143:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine219_0
   \   000003                ; // Fall through to label ??Subroutine219_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine219_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000002                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000002   85..82       MOV     DPL,?V2
   \   000005   85..83       MOV     DPH,?V3
   \   000008   22           RET
   3651          
   3652          /*********************************************************************
   3653           * @fn      zclParseInWriteRspCmd
   3654           *
   3655           * @brief   Parse the "Profile" Write Response Commands
   3656           *
   3657           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3658           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3659           *
   3660           * @param   pCmd - pointer to incoming data to parse
   3661           *
   3662           * @return  pointer to the parsed command structure
   3663           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3664          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   3665          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   3666            zclWriteRspCmd_t *writeRspCmd;
   3667            uint8 *pBuf = pCmd->pData;
   \   000005   EA           MOV     A,R2
   \   000006   2403         ADD     A,#0x3
   \   000008   F5..         MOV     ?V2,A
   \   00000A   E4           CLR     A
   \   00000B   3B           ADDC    A,R3
   \   00000C   F5..         MOV     ?V3,A
   \   00000E   85..82       MOV     DPL,?V2
   \   000011   12....       LCALL   ?Subroutine111 & 0xFFFF
   3668            uint8 i = 0;
   3669          
   3670            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \                     ??CrossCallReturnLabel_196:
   \   000014   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   000017   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3671            if ( writeRspCmd != NULL )
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   6050         JZ      ??zclParseInWriteRspCmd_0
   3672            {
   3673              if ( pCmd->dataLen == 1 )
   \   00001E   85..82       MOV     DPL,?V0
   \   000021   85..83       MOV     DPH,?V1
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6401         XRL     A,#0x1
   \   000027   7002         JNZ     ??zclParseInWriteRspCmd_1
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \                     ??zclParseInWriteRspCmd_1:
   \   00002B   702C         JNZ     ??zclParseInWriteRspCmd_2
   3674              {
   3675                // special case when all writes were successfull
   3676                writeRspCmd->attrList[i++].status = *pBuf;
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   12....       LCALL   ?Subroutine103 & 0xFFFF
   3677              }
   \                     ??CrossCallReturnLabel_179:
   \   000034   F0           MOVX    @DPTR,A
   \   000035   75..01       MOV     ?V4,#0x1
   \   000038   802D         SJMP    ??zclParseInWriteRspCmd_3
   3678              else
   3679              {
   3680                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3681                {
   3682                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_4:
   \   00003A   E5..         MOV     A,?V4
   \   00003C   12....       LCALL   ?Subroutine18 & 0xFFFF
   3683                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_416:
   \   00003F   F5..         MOV     ?V6,A
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   FD           MOV     R5,A
   \   000044   E5..         MOV     A,?V6
   \   000046   8882         MOV     DPL,R0
   \   000048   8983         MOV     DPH,R1
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   A3           INC     DPTR
   \   00004E   ED           MOV     A,R5
   \   00004F   F0           MOVX    @DPTR,A
   \   000050   05..         INC     ?V4
   3684                  pBuf += 2;
   \   000052   EE           MOV     A,R6
   \   000053   2402         ADD     A,#0x2
   \   000055   FE           MOV     R6,A
   \   000056   5001         JNC     ??zclParseInWriteRspCmd_2
   \   000058   0F           INC     R7
   3685                }
   \                     ??zclParseInWriteRspCmd_2:
   \   000059   85..82       MOV     DPL,?V0
   \   00005C   85..83       MOV     DPH,?V1
   \   00005F   12....       LCALL   ??Subroutine218_0 & 0xFFFF
   3686              }
   \                     ??CrossCallReturnLabel_520:
   \   000062   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_430:
   \   000065   40D3         JC      ??zclParseInWriteRspCmd_4
   3687          
   3688              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_3:
   \   000067   8A82         MOV     DPL,R2
   \   000069   8B83         MOV     DPH,R3
   \   00006B   E5..         MOV     A,?V4
   \   00006D   F0           MOVX    @DPTR,A
   3689            }
   3690          
   3691            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_0:
   \   00006E   02....       LJMP    ??Subroutine194_0 & 0xFFFF
   3692          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   75F003       MOV     B,#0x3
   \   000003   A4           MUL     AB
   \   000004   F8           MOV     R0,A
   \   000005   A9F0         MOV     R1,B
   \   000007   EA           MOV     A,R2
   \   000008   28           ADD     A,R0
   \   000009   F8           MOV     R0,A
   \   00000A   EB           MOV     A,R3
   \   00000B   39           ADDC    A,R1
   \   00000C   F9           MOV     R1,A
   \   00000D   8E82         MOV     DPL,R6
   \   00000F   8F83         MOV     DPH,R7
   \   000011   12....       LCALL   ?Subroutine159 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   000014                REQUIRE ??Subroutine200_0
   \   000014                ; // Fall through to label ??Subroutine200_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine200_0:
   \   000000   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_420:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine111:
   \   000000   12....       LCALL   ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_529:
   \   000003   75..00       MOV     ?V4,#0x0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine218_0:
   \   000000   12....       LCALL   ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_525:
   \   000003   22           RET
   3693          #endif // ZCL_WRITE
   3694          
   3695          #ifdef ZCL_REPORT
   3696          /*********************************************************************
   3697           * @fn      zclParseInConfigReportCmd
   3698           *
   3699           * @brief   Parse the "Profile" Configure Reporting Command
   3700           *
   3701           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3702           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3703           *
   3704           * @param   pCmd - pointer to incoming data to parse
   3705           *
   3706           * @return  pointer to the parsed command structure
   3707           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   AA..         MOV     R2,?V6
   \   000002   AB..         MOV     R3,?V7
   \   000004                REQUIRE ??Subroutine179_0
   \   000004                ; // Fall through to label ??Subroutine179_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine186_0
   \   000001                ; // Fall through to label ??Subroutine186_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine186_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine187_0
   \   000001                ; // Fall through to label ??Subroutine187_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine187_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine188_0
   \   000002                ; // Fall through to label ??Subroutine188_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3708          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportCmd:
   3709          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V4,R2
   \   000007   8B..         MOV     ?V5,R3
   3710            zclCfgReportCmd_t *cfgReportCmd;
   3711            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V0,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V5
   \   000011   F5..         MOV     ?V1,A
   \   000013   85..82       MOV     DPL,?V0
   \   000016   12....       LCALL   ?Subroutine76 & 0xFFFF
   3712            uint8 *dataPtr;
   3713            uint8 numAttr = 0;
   3714            uint8 dataType;
   3715            uint8 hdrLen;
   3716            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_128:
   \   000019   8007         SJMP    ??zclParseInConfigReportCmd_0
   3717            uint8 reportChangeLen; // length of Reportable Change field
   3718          
   3719            // Calculate the length of the Request command
   3720            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3721            {
   3722              uint8 direction;
   3723          
   3724              numAttr++;
   3725              direction = *pBuf++;
   3726              pBuf += 2; // move pass the attribute ID
   3727          
   3728              // Is there a Reportable Change field?
   3729              if ( direction == ZCL_SEND_ATTR_REPORTS )
   3730              {
   3731                dataType = *pBuf++;
   3732                pBuf += 4; // move pass the Min and Max Reporting Intervals
   3733          
   3734                // For attributes of 'discrete' data types this field is omitted
   3735                if ( zclAnalogDataType( dataType ) )
   3736                {
   3737                  reportChangeLen = zclGetDataTypeLength( dataType );
   3738                  pBuf += reportChangeLen;
   3739          
   3740                  // add padding if needed
   3741                  if ( PADDING_NEEDED( reportChangeLen ) )
   3742                  {
   3743                    reportChangeLen++;
   3744                  }
   3745          
   3746                  dataLen += reportChangeLen;
   3747                }
   3748                else
   3749                {
   3750                  pBuf++; // move past reportable change field
   3751                }
   3752              }
   3753              else
   3754              {
   3755                pBuf += 2; // move pass the Timeout Period
   \                     ??zclParseInConfigReportCmd_1:
   \   00001B   EE           MOV     A,R6
   \   00001C   2405         ADD     A,#0x5
   \   00001E   FE           MOV     R6,A
   \   00001F   5001         JNC     ??zclParseInConfigReportCmd_0
   \   000021   0F           INC     R7
   3756              }
   \                     ??zclParseInConfigReportCmd_0:
   \   000022   85..82       MOV     DPL,?V4
   \   000025   85..83       MOV     DPH,?V5
   \   000028   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_431:
   \   00002B   5039         JNC     ??zclParseInConfigReportCmd_2
   \   00002D   05..         INC     ?V2
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   E0           MOVX    A,@DPTR
   \   000034   70E5         JNZ     ??zclParseInConfigReportCmd_1
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F5..         MOV     ?V3,A
   \   00003C   EE           MOV     A,R6
   \   00003D   2408         ADD     A,#0x8
   \   00003F   FE           MOV     R6,A
   \   000040   5001         JNC     ??zclParseInConfigReportCmd_3
   \   000042   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_3:
   \   000043                ; Setup parameters for call to function zclAnalogDataType
   \   000043   A9..         MOV     R1,?V3
   \   000045   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   000048   E9           MOV     A,R1
   \   000049   6010         JZ      ??zclParseInConfigReportCmd_4
   \   00004B                ; Setup parameters for call to function zclGetDataTypeLength
   \   00004B   A9..         MOV     R1,?V3
   \   00004D   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000050   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   000053   5001         JNC     ??zclParseInConfigReportCmd_5
   \   000055   0A           INC     R2
   \                     ??zclParseInConfigReportCmd_5:
   \   000056   12....       LCALL   ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000059   80C7         SJMP    ??zclParseInConfigReportCmd_0
   \                     ??zclParseInConfigReportCmd_4:
   \   00005B   8E82         MOV     DPL,R6
   \   00005D   8F83         MOV     DPH,R7
   \   00005F   A3           INC     DPTR
   \   000060   AE82         MOV     R6,DPL
   \   000062   AF83         MOV     R7,DPH
   \   000064   80BC         SJMP    ??zclParseInConfigReportCmd_0
   3757            } // while loop
   3758          
   3759            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   \                     ??zclParseInConfigReportCmd_2:
   \   000066   75F00C       MOV     B,#0xc
   \   000069   E5..         MOV     A,?V2
   \   00006B   A4           MUL     AB
   \   00006C   04           INC     A
   \   00006D   F5..         MOV     ?V3,A
   3760          
   3761            cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   00006F                ; Setup parameters for call to function osal_mem_alloc
   \   00006F   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   000072   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000075   8A..         MOV     ?V6,R2
   \   000077   8B..         MOV     ?V7,R3
   3762            if ( cfgReportCmd != NULL )
   \   000079   EA           MOV     A,R2
   \   00007A   45..         ORL     A,?V7
   \   00007C   7003         JNZ     $+5
   \   00007E   02....       LJMP    ??zclParseInConfigReportCmd_6 & 0xFFFF
   3763            {
   3764              uint8 i;
   3765              pBuf = pCmd->pData;
   \   000081   12....       LCALL   ?Subroutine112 & 0xFFFF
   3766              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   \                     ??CrossCallReturnLabel_424:
   \   000084   A8..         MOV     R0,?V3
   \   000086   EA           MOV     A,R2
   \   000087   28           ADD     A,R0
   \   000088   F5..         MOV     ?V4,A
   \   00008A   E4           CLR     A
   \   00008B   3B           ADDC    A,R3
   \   00008C   F5..         MOV     ?V5,A
   3767          
   3768              cfgReportCmd->numAttr = numAttr;
   \   00008E   8A82         MOV     DPL,R2
   \   000090   8B83         MOV     DPH,R3
   \   000092   E5..         MOV     A,?V2
   \   000094   F0           MOVX    @DPTR,A
   3769              for ( i = 0; i < numAttr; i++ )
   \   000095   75..00       MOV     ?V3,#0x0
   \   000098   8008         SJMP    ??zclParseInConfigReportCmd_7
   3770              {
   3771                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   3772          
   3773                zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   3774          
   3775                reportRec->direction = *pBuf++;
   3776                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3777                pBuf += 2;
   3778                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   3779                {
   3780                  // Attribute to be reported
   3781                  reportRec->dataType = *pBuf++;
   3782                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3783                  pBuf += 2;
   3784                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3785                  pBuf += 2;
   3786          
   3787                  // For attributes of 'discrete' data types this field is omitted
   3788                  if ( zclAnalogDataType( reportRec->dataType ) )
   3789                  {
   3790                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   3791                    reportRec->reportableChange = dataPtr;
   3792          
   3793                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   3794                    pBuf += reportChangeLen;
   3795          
   3796                    // advance attribute data pointer
   3797                    if ( PADDING_NEEDED( reportChangeLen ) )
   3798                    {
   3799                      reportChangeLen++;
   3800                    }
   3801          
   3802                    dataPtr += reportChangeLen;
   3803                  }
   3804                }
   3805                else
   3806                {
   3807                  // Attribute reports to be received
   3808                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInConfigReportCmd_8:
   \   00009A   12....       LCALL   ?Subroutine74 & 0xFFFF
   3809                  pBuf += 2;
   3810                }
   \                     ??CrossCallReturnLabel_427:
   \   00009D   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   0000A0   05..         INC     ?V3
   \                     ??zclParseInConfigReportCmd_7:
   \   0000A2   E5..         MOV     A,?V3
   \   0000A4   C3           CLR     C
   \   0000A5   95..         SUBB    A,?V2
   \   0000A7   4003         JC      $+5
   \   0000A9   02....       LJMP    ??zclParseInConfigReportCmd_6 & 0xFFFF
   \   0000AC   E5..         MOV     A,?V3
   \   0000AE   75F00C       MOV     B,#0xc
   \   0000B1   12....       LCALL   ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   0000B4                ; Setup parameters for call to function osal_memset
   \   0000B4   7C0C         MOV     R4,#0xc
   \   0000B6   7D00         MOV     R5,#0x0
   \   0000B8   7900         MOV     R1,#0x0
   \   0000BA   AA..         MOV     R2,?V0
   \   0000BC   AB..         MOV     R3,?V1
   \   0000BE   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   \   0000C1   8E82         MOV     DPL,R6
   \   0000C3   8F83         MOV     DPH,R7
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   FB           MOV     R3,A
   \   0000C7   85..82       MOV     DPL,?V0
   \   0000CA   85..83       MOV     DPH,?V1
   \   0000CD   12....       LCALL   ??Subroutine200_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_418:
   \   0000D0   12....       LCALL   ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_449:
   \   0000D3   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_357:
   \   0000D6   5001         JNC     ??zclParseInConfigReportCmd_9
   \   0000D8   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_9:
   \   0000D9   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   0000DC   70BC         JNZ     ??zclParseInConfigReportCmd_8
   \   0000DE   E5..         MOV     A,?V0
   \   0000E0   2403         ADD     A,#0x3
   \   0000E2   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   0000E5   0E           INC     R6
   \   0000E6   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   0000E9   12....       LCALL   ??Subroutine187_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_354:
   \   0000EC   5001         JNC     ??zclParseInConfigReportCmd_10
   \   0000EE   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_10:
   \   0000EF   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_450:
   \   0000F2   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_351:
   \   0000F5   5001         JNC     ??zclParseInConfigReportCmd_11
   \   0000F7   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_11:
   \   0000F8                ; Setup parameters for call to function zclAnalogDataType
   \   0000F8   EA           MOV     A,R2
   \   0000F9   F9           MOV     R1,A
   \   0000FA   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   0000FD   E9           MOV     A,R1
   \   0000FE   60A0         JZ      ??CrossCallReturnLabel_57
   \   000100                ; Setup parameters for call to function zcl_BuildAnalogData
   \   000100   EE           MOV     A,R6
   \   000101   FC           MOV     R4,A
   \   000102   EF           MOV     A,R7
   \   000103   FD           MOV     R5,A
   \   000104   AA..         MOV     R2,?V4
   \   000106   AB..         MOV     R3,?V5
   \   000108   85..82       MOV     DPL,?V8
   \   00010B   85..83       MOV     DPH,?V9
   \   00010E   E0           MOVX    A,@DPTR
   \   00010F   F9           MOV     R1,A
   \   000110   12....       LCALL   `??zcl_BuildAnalogData::?relay`; Banked call to: zcl_BuildAnalogData
   \   000113   85..82       MOV     DPL,?V0
   \   000116   85..83       MOV     DPH,?V1
   \   000119   A3           INC     DPTR
   \   00011A   A3           INC     DPTR
   \   00011B   A3           INC     DPTR
   \   00011C   A3           INC     DPTR
   \   00011D   A3           INC     DPTR
   \   00011E   A3           INC     DPTR
   \   00011F   A3           INC     DPTR
   \   000120   A3           INC     DPTR
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   E5..         MOV     A,?V4
   \   000125   F0           MOVX    @DPTR,A
   \   000126   A3           INC     DPTR
   \   000127   E5..         MOV     A,?V5
   \   000129   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   00012C   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   00012F   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   000132   5001         JNC     ??zclParseInConfigReportCmd_12
   \   000134   0A           INC     R2
   \                     ??zclParseInConfigReportCmd_12:
   \   000135   E5..         MOV     A,?V4
   \   000137   2A           ADD     A,R2
   \   000138   F5..         MOV     ?V4,A
   \   00013A   E4           CLR     A
   \   00013B   35..         ADDC    A,?V5
   \   00013D   F5..         MOV     ?V5,A
   \   00013F   02....       LJMP    ??CrossCallReturnLabel_57 & 0xFFFF
   3811              } // while loop
   3812            }
   3813          
   3814            return ( (void *)cfgReportCmd );
   \                     ??zclParseInConfigReportCmd_6:
   \   000142   02....       LJMP    ?Subroutine6 & 0xFFFF
   3815          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine112:
   \   000000   85..82       MOV     DPL,?V0
   \   000003   85..83       MOV     DPH,?V1
   \   000006                REQUIRE ??Subroutine201_0
   \   000006                ; // Fall through to label ??Subroutine201_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004                REQUIRE ??Subroutine202_0
   \   000004                ; // Fall through to label ??Subroutine202_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_507:
   \   000004   85..82       MOV     DPL,?V0
   \   000007   85..83       MOV     DPH,?V1
   \   00000A                REQUIRE ??Subroutine203_0
   \   00000A                ; // Fall through to label ??Subroutine203_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine127:
   \   000000   F5..         MOV     ?V8,A
   \   000002   E4           CLR     A
   \   000003   35..         ADDC    A,?V1
   \   000005   F5..         MOV     ?V9,A
   \   000007   EA           MOV     A,R2
   \   000008   85..82       MOV     DPL,?V8
   \   00000B   85..83       MOV     DPH,?V9
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine125:
   \   000000   E5..         MOV     A,?V6
   \   000002   2A           ADD     A,R2
   \   000003   F5..         MOV     ?V6,A
   \   000005   E4           CLR     A
   \   000006   35..         ADDC    A,?V7
   \   000008   F5..         MOV     ?V7,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine121:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V6
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V7
   \   00000B   12....       LCALL   ??Subroutine210_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_473:
   \   00000E   8582..       MOV     ?V0,DPL
   \   000011   8583..       MOV     ?V1,DPH
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine120:
   \   000000   E9           MOV     A,R1
   \   000001   FA           MOV     R2,A
   \   000002   EE           MOV     A,R6
   \   000003   29           ADD     A,R1
   \   000004   FE           MOV     R6,A
   \   000005   E4           CLR     A
   \   000006   3F           ADDC    A,R7
   \   000007   FF           MOV     R7,A
   \   000008   EA           MOV     A,R2
   \   000009   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine118:
   \   000000   2402         ADD     A,#0x2
   \   000002   FC           MOV     R4,A
   \   000003   E4           CLR     A
   \   000004   3F           ADDC    A,R7
   \   000005   FD           MOV     R5,A
   \   000006   8E82         MOV     DPL,R6
   \   000008   8F83         MOV     DPH,R7
   \   00000A   A3           INC     DPTR
   \   00000B   A882         MOV     R0,DPL
   \   00000D   A983         MOV     R1,DPH
   \   00000F   8E82         MOV     DPL,R6
   \   000011   8F83         MOV     DPH,R7
   \   000013   E0           MOVX    A,@DPTR
   \   000014   FA           MOV     R2,A
   \   000015   EB           MOV     A,R3
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   E9           MOV     A,R1
   \   000001   FF           MOV     R7,A
   \   000002   8E82         MOV     DPL,R6
   \   000004   8F83         MOV     DPH,R7
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V10,A
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   \   00000F   E5..         MOV     A,?V10
   \   000011   85..82       MOV     DPL,?V0
   \   000014   85..83       MOV     DPH,?V1
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005                REQUIRE ??Subroutine207_0
   \   000005                ; // Fall through to label ??Subroutine207_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine207_0:
   \   000000   FC           MOV     R4,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   EC           MOV     A,R4
   \   000005   85..82       MOV     DPL,?V0
   \   000008   85..83       MOV     DPH,?V1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   E9           MOV     A,R1
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   0E           INC     R6
   \   00000D   0E           INC     R6
   \   00000E   ED           MOV     A,R5
   \   00000F   FF           MOV     R7,A
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function zclGetDataTypeLength
   \   000001                ; Setup parameters for call to function zclGetDataTypeLength
   \   000001   85..82       MOV     DPL,?V8
   \   000004   85..83       MOV     DPH,?V9
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   22           RET
   3816          
   3817          /*********************************************************************
   3818           * @fn      zclParseInConfigReportRspCmd
   3819           *
   3820           * @brief   Parse the "Profile" Configure Reporting Response Command
   3821           *
   3822           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3823           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3824           *
   3825           * @param   pCmd - pointer to incoming data to parse
   3826           *
   3827           * @return  pointer to the parsed command structure
   3828           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3829          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportRspCmd:
   3830          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3831            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3832            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine89 & 0xFFFF
   3833            uint8 numAttr;
   3834          
   3835            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   \                     ??CrossCallReturnLabel_151:
   \   000008   F5..         MOV     ?V0,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F5..         MOV     ?V1,A
   \   00000E   7402         MOV     A,#0x2
   \   000010   78..         MOV     R0,#?V0
   \   000012   12....       LCALL   ?US_SHR
   \   000015   E5..         MOV     A,?V0
   \   000017   F5..         MOV     ?V0,A
   3836          
   3837            cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3838                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   \   000019                ; Setup parameters for call to function osal_mem_alloc
   \   000019   F5..         MOV     ?V2,A
   \   00001B   75..00       MOV     ?V3,#0x0
   \   00001E   7402         MOV     A,#0x2
   \   000020   78..         MOV     R0,#?V2
   \   000022   12....       LCALL   ?S_SHL
   \   000025   E5..         MOV     A,?V2
   \   000027   2401         ADD     A,#0x1
   \   000029   FA           MOV     R2,A
   \   00002A   E4           CLR     A
   \   00002B   35..         ADDC    A,?V3
   \   00002D   FB           MOV     R3,A
   \   00002E   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3839            if ( cfgReportRspCmd != NULL )
   \   000031   EA           MOV     A,R2
   \   000032   4B           ORL     A,R3
   \   000033   6051         JZ      ??zclParseInConfigReportRspCmd_0
   3840            {
   3841              uint8 i;
   3842              cfgReportRspCmd->numAttr = numAttr;
   \   000035   8A82         MOV     DPL,R2
   \   000037   8B83         MOV     DPH,R3
   \   000039   E5..         MOV     A,?V0
   \   00003B   F0           MOVX    @DPTR,A
   3843              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   00003C   75..00       MOV     ?V2,#0x0
   \   00003F   803C         SJMP    ??zclParseInConfigReportRspCmd_1
   3844              {
   3845                cfgReportRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInConfigReportRspCmd_2:
   \   000041   85....       MOV     ?V0,?V2
   \   000044   75..00       MOV     ?V1,#0x0
   \   000047   7402         MOV     A,#0x2
   \   000049   78..         MOV     R0,#?V0
   \   00004B   12....       LCALL   ?S_SHL
   \   00004E   EA           MOV     A,R2
   \   00004F   25..         ADD     A,?V0
   \   000051   F8           MOV     R0,A
   \   000052   EB           MOV     A,R3
   \   000053   35..         ADDC    A,?V1
   \   000055   F9           MOV     R1,A
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   00005D   A3           INC     DPTR
   \   00005E   12....       LCALL   ??Subroutine208_0 & 0xFFFF
   3846                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   \                     ??CrossCallReturnLabel_456:
   \   000061   8882         MOV     DPL,R0
   \   000063   8983         MOV     DPH,R1
   \   000065   A3           INC     DPTR
   \   000066   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_440:
   \   000069   5001         JNC     ??zclParseInConfigReportRspCmd_3
   \   00006B   0F           INC     R7
   3847                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInConfigReportRspCmd_3:
   \   00006C   8E82         MOV     DPL,R6
   \   00006E   8F83         MOV     DPH,R7
   \   000070   E0           MOVX    A,@DPTR
   \   000071   12....       LCALL   ?Subroutine113 & 0xFFFF
   3848                pBuf += 2;
   3849              }
   \                     ??CrossCallReturnLabel_198:
   \   000074   A3           INC     DPTR
   \   000075   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_435:
   \   000078   5001         JNC     ??zclParseInConfigReportRspCmd_4
   \   00007A   0F           INC     R7
   \                     ??zclParseInConfigReportRspCmd_4:
   \   00007B   05..         INC     ?V2
   \                     ??zclParseInConfigReportRspCmd_1:
   \   00007D   8A82         MOV     DPL,R2
   \   00007F   8B83         MOV     DPH,R3
   \   000081   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   3850            }
   \                     ??CrossCallReturnLabel_444:
   \   000084   40BB         JC      ??zclParseInConfigReportRspCmd_2
   3851          
   3852            return ( (void *)cfgReportRspCmd );
   \                     ??zclParseInConfigReportRspCmd_0:
   \   000086   02....       LJMP    ?Subroutine1 & 0xFFFF
   3853          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine136:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine204_0
   \   000001                ; // Fall through to label ??Subroutine204_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine205_0
   \   000002                ; // Fall through to label ??Subroutine205_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine113:
   \   000000   F5..         MOV     ?V0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   E5..         MOV     A,?V0
   \   000007   8882         MOV     DPL,R0
   \   000009   8983         MOV     DPH,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ??Subroutine220_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_527:
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   22           RET
   3854          
   3855          /*********************************************************************
   3856           * @fn      zclParseInReadReportCfgCmd
   3857           *
   3858           * @brief   Parse the "Profile" Read Reporting Configuration Command
   3859           *
   3860           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3861           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3862           *
   3863           * @param   pCmd - pointer to incoming data to parse
   3864           *
   3865           * @return  pointer to the parsed command structure
   3866           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3867          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgCmd:
   3868          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3869            zclReadReportCfgCmd_t *readReportCfgCmd;
   3870            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine89 & 0xFFFF
   3871            uint8 numAttr;
   3872          
   3873            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   \                     ??CrossCallReturnLabel_152:
   \   000008   F8           MOV     R0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   7A03         MOV     R2,#0x3
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   12....       LCALL   ?US_DIV_MOD
   \   000013   E8           MOV     A,R0
   \   000014   F5..         MOV     ?V0,A
   3874          
   3875            readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   3876                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   \   000016                ; Setup parameters for call to function osal_mem_alloc
   \   000016   12....       LCALL   ?Subroutine168 & 0xFFFF
   \                     ??CrossCallReturnLabel_518:
   \   000019   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3877            if ( readReportCfgCmd != NULL )
   \   00001C   EA           MOV     A,R2
   \   00001D   4B           ORL     A,R3
   \   00001E   6025         JZ      ??zclParseInReadReportCfgCmd_0
   3878            {
   3879              uint8 i;
   3880              readReportCfgCmd->numAttr = numAttr;
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   E5..         MOV     A,?V0
   \   000026   F0           MOVX    @DPTR,A
   3881              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   \   000027   75..00       MOV     ?V2,#0x0
   \   00002A   8010         SJMP    ??zclParseInReadReportCfgCmd_1
   3882              {
   3883                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   \                     ??zclParseInReadReportCfgCmd_2:
   \   00002C   E5..         MOV     A,?V2
   \   00002E   12....       LCALL   ?Subroutine18 & 0xFFFF
   3884                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3885                pBuf += 2;
   3886              }
   \                     ??CrossCallReturnLabel_417:
   \   000031   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   000034   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_436:
   \   000037   5001         JNC     ??zclParseInReadReportCfgCmd_3
   \   000039   0F           INC     R7
   \                     ??zclParseInReadReportCfgCmd_3:
   \   00003A   05..         INC     ?V2
   \                     ??zclParseInReadReportCfgCmd_1:
   \   00003C   8A82         MOV     DPL,R2
   \   00003E   8B83         MOV     DPH,R3
   \   000040   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   3887            }
   \                     ??CrossCallReturnLabel_445:
   \   000043   40E7         JC      ??zclParseInReadReportCfgCmd_2
   3888          
   3889            return ( (void *)readReportCfgCmd );
   \                     ??zclParseInReadReportCfgCmd_0:
   \   000045   02....       LJMP    ?Subroutine1 & 0xFFFF
   3890          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine168:
   \   000000   75F003       MOV     B,#0x3
   \   000003                REQUIRE ??Subroutine217_0
   \   000003                ; // Fall through to label ??Subroutine217_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine217_0:
   \   000000   A4           MUL     AB
   \   000001   A9F0         MOV     R1,B
   \   000003   2401         ADD     A,#0x1
   \   000005   FA           MOV     R2,A
   \   000006   E4           CLR     A
   \   000007   39           ADDC    A,R1
   \   000008   FB           MOV     R3,A
   \   000009   22           RET
   3891          
   3892          /*********************************************************************
   3893           * @fn      zclParseInReadReportCfgRspCmd
   3894           *
   3895           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   3896           *
   3897           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3898           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3899           *
   3900           * @param   pCmd - pointer to incoming data to parse
   3901           *
   3902           * @return  pointer to the parsed command structure
   3903           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3904          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgRspCmd:
   3905          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V2,R2
   \   000007   8B..         MOV     ?V3,R3
   3906            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   3907            uint8 reportChangeLen;
   3908            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V0,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V3
   \   000011   F5..         MOV     ?V1,A
   \   000013   85..82       MOV     DPL,?V0
   \   000016   12....       LCALL   ?Subroutine111 & 0xFFFF
   3909            uint8 *dataPtr;
   3910            uint8 numAttr = 0;
   3911            uint8 hdrLen;
   3912            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_197:
   \   000019   75..00       MOV     ?V6,#0x0
   \   00001C   75..00       MOV     ?V7,#0x0
   \   00001F   8007         SJMP    ??zclParseInReadReportCfgRspCmd_0
   3913          
   3914            // Calculate the length of the response command
   3915            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3916            {
   3917              uint8 status;
   3918              uint8 direction;
   3919          
   3920              numAttr++;
   3921              status = *pBuf++;
   3922              direction = *pBuf++;
   3923              pBuf += 2; // move pass the attribute ID
   3924          
   3925              if ( status == ZCL_STATUS_SUCCESS )
   3926              {
   3927                if ( direction == ZCL_SEND_ATTR_REPORTS )
   3928                {
   3929                  uint8 dataType = *pBuf++;
   3930                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   3931          
   3932                  // For attributes of 'discrete' data types this field is omitted
   3933                  if ( zclAnalogDataType( dataType ) )
   3934                  {
   3935                    reportChangeLen = zclGetDataTypeLength( dataType );
   3936                    pBuf += reportChangeLen;
   3937          
   3938                    // add padding if needed
   3939                    if ( PADDING_NEEDED( reportChangeLen ) )
   3940                    {
   3941                      reportChangeLen++;
   3942                    }
   3943          
   3944                    dataLen += reportChangeLen;
   3945                  }
   3946                }
   3947                else
   3948                {
   3949                  pBuf += 2; // move pass the Timeout field
   \                     ??zclParseInReadReportCfgRspCmd_1:
   \   000021   EE           MOV     A,R6
   \   000022   2402         ADD     A,#0x2
   \   000024   FE           MOV     R6,A
   \   000025   5001         JNC     ??zclParseInReadReportCfgRspCmd_0
   \   000027   0F           INC     R7
   3950                }
   \                     ??zclParseInReadReportCfgRspCmd_0:
   \   000028   85..82       MOV     DPL,?V2
   \   00002B   85..83       MOV     DPH,?V3
   \   00002E   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_432:
   \   000031   503E         JNC     ??zclParseInReadReportCfgRspCmd_2
   \   000033   05..         INC     ?V4
   \   000035   8E82         MOV     DPL,R6
   \   000037   8F83         MOV     DPH,R7
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F9           MOV     R1,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F8           MOV     R0,A
   \   00003E   EE           MOV     A,R6
   \   00003F   2404         ADD     A,#0x4
   \   000041   FE           MOV     R6,A
   \   000042   5001         JNC     ??zclParseInReadReportCfgRspCmd_3
   \   000044   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_3:
   \   000045   E9           MOV     A,R1
   \   000046   70E0         JNZ     ??zclParseInReadReportCfgRspCmd_0
   \   000048   E8           MOV     A,R0
   \   000049   70D6         JNZ     ??zclParseInReadReportCfgRspCmd_1
   \   00004B   8E82         MOV     DPL,R6
   \   00004D   8F83         MOV     DPH,R7
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   F5..         MOV     ?V5,A
   \   000052   EE           MOV     A,R6
   \   000053   2405         ADD     A,#0x5
   \   000055   FE           MOV     R6,A
   \   000056   5001         JNC     ??zclParseInReadReportCfgRspCmd_4
   \   000058   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_4:
   \   000059                ; Setup parameters for call to function zclAnalogDataType
   \   000059   A9..         MOV     R1,?V5
   \   00005B   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   00005E   E9           MOV     A,R1
   \   00005F   60C7         JZ      ??zclParseInReadReportCfgRspCmd_0
   \   000061                ; Setup parameters for call to function zclGetDataTypeLength
   \   000061   A9..         MOV     R1,?V5
   \   000063   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000066   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   000069   5001         JNC     ??zclParseInReadReportCfgRspCmd_5
   \   00006B   0A           INC     R2
   \                     ??zclParseInReadReportCfgRspCmd_5:
   \   00006C   12....       LCALL   ?Subroutine125 & 0xFFFF
   3951              }
   3952            } // while loop
   \                     ??CrossCallReturnLabel_227:
   \   00006F   80B7         SJMP    ??zclParseInReadReportCfgRspCmd_0
   3953          
   3954            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   \                     ??zclParseInReadReportCfgRspCmd_2:
   \   000071   75F00D       MOV     B,#0xd
   \   000074   E5..         MOV     A,?V4
   \   000076   A4           MUL     AB
   \   000077   04           INC     A
   \   000078   F5..         MOV     ?V2,A
   3955          
   3956            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   00007A                ; Setup parameters for call to function osal_mem_alloc
   \   00007A   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   00007D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000080   8A..         MOV     ?V6,R2
   \   000082   8B..         MOV     ?V7,R3
   3957            if ( readReportCfgRspCmd != NULL )
   \   000084   EA           MOV     A,R2
   \   000085   45..         ORL     A,?V7
   \   000087   7003         JNZ     $+5
   \   000089   02....       LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
   3958            {
   3959              uint8 i;
   3960              pBuf = pCmd->pData;
   \   00008C   12....       LCALL   ?Subroutine112 & 0xFFFF
   3961              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_425:
   \   00008F   A8..         MOV     R0,?V2
   \   000091   EA           MOV     A,R2
   \   000092   28           ADD     A,R0
   \   000093   F5..         MOV     ?V2,A
   \   000095   E4           CLR     A
   \   000096   3B           ADDC    A,R3
   \   000097   F5..         MOV     ?V3,A
   3962          
   3963              readReportCfgRspCmd->numAttr = numAttr;
   \   000099   8A82         MOV     DPL,R2
   \   00009B   8B83         MOV     DPH,R3
   \   00009D   E5..         MOV     A,?V4
   \   00009F   F0           MOVX    @DPTR,A
   3964              for ( i = 0; i < numAttr; i++ )
   \   0000A0   75..00       MOV     ?V5,#0x0
   \   0000A3   8009         SJMP    ??zclParseInReadReportCfgRspCmd_7
   3965              {
   3966                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   3967          
   3968                reportRspRec->status = *pBuf++;
   3969                reportRspRec->direction = *pBuf++;
   3970                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3971                pBuf += 2;
   3972          
   3973                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   3974                {
   3975                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   3976                  {
   3977                    reportRspRec->dataType = *pBuf++;
   3978                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3979                    pBuf += 2;
   3980                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3981                    pBuf += 2;
   3982          
   3983                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   3984                    {
   3985                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   3986                      reportRspRec->reportableChange = dataPtr;
   3987          
   3988                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   3989                      pBuf += reportChangeLen;
   3990          
   3991                      // advance attribute data pointer
   3992                      if ( PADDING_NEEDED( reportChangeLen ) )
   3993                      {
   3994                        reportChangeLen++;
   3995                      }
   3996          
   3997                      dataPtr += reportChangeLen;
   3998                    }
   3999                  }
   4000                  else
   4001                  {
   4002                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadReportCfgRspCmd_8:
   \   0000A5   12....       LCALL   ?Subroutine74 & 0xFFFF
   4003                    pBuf += 2;
   4004                  }
   \                     ??CrossCallReturnLabel_428:
   \   0000A8   A3           INC     DPTR
   \   0000A9   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   0000AC   05..         INC     ?V5
   \                     ??zclParseInReadReportCfgRspCmd_7:
   \   0000AE   E5..         MOV     A,?V5
   \   0000B0   C3           CLR     C
   \   0000B1   95..         SUBB    A,?V4
   \   0000B3   4003         JC      $+5
   \   0000B5   02....       LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
   \   0000B8   E5..         MOV     A,?V5
   \   0000BA   75F00D       MOV     B,#0xd
   \   0000BD   12....       LCALL   ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   0000C0   8E82         MOV     DPL,R6
   \   0000C2   8F83         MOV     DPH,R7
   \   0000C4   E0           MOVX    A,@DPTR
   \   0000C5   FA           MOV     R2,A
   \   0000C6   85..82       MOV     DPL,?V0
   \   0000C9   85..83       MOV     DPH,?V1
   \   0000CC   12....       LCALL   ??Subroutine208_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_457:
   \   0000CF   FB           MOV     R3,A
   \   0000D0   85..82       MOV     DPL,?V0
   \   0000D3   85..83       MOV     DPH,?V1
   \   0000D6   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_441:
   \   0000D9   5001         JNC     ??zclParseInReadReportCfgRspCmd_9
   \   0000DB   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_9:
   \   0000DC   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_451:
   \   0000DF   12....       LCALL   ??Subroutine188_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_356:
   \   0000E2   5001         JNC     ??zclParseInReadReportCfgRspCmd_10
   \   0000E4   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_10:
   \   0000E5   EA           MOV     A,R2
   \   0000E6   70C4         JNZ     ??CrossCallReturnLabel_58
   \   0000E8   EE           MOV     A,R6
   \   0000E9   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   0000EC   70B7         JNZ     ??zclParseInReadReportCfgRspCmd_8
   \   0000EE   E5..         MOV     A,?V0
   \   0000F0   2404         ADD     A,#0x4
   \   0000F2   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   0000F5   E8           MOV     A,R0
   \   0000F6   FE           MOV     R6,A
   \   0000F7   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   0000FA   12....       LCALL   ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_353:
   \   0000FD   5001         JNC     ??zclParseInReadReportCfgRspCmd_11
   \   0000FF   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_11:
   \   000100   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_452:
   \   000103   A3           INC     DPTR
   \   000104   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_352:
   \   000107   5001         JNC     ??zclParseInReadReportCfgRspCmd_12
   \   000109   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_12:
   \   00010A                ; Setup parameters for call to function zclAnalogDataType
   \   00010A   EA           MOV     A,R2
   \   00010B   F9           MOV     R1,A
   \   00010C   12....       LCALL   `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   00010F   E9           MOV     A,R1
   \   000110   609A         JZ      ??CrossCallReturnLabel_58
   \   000112                ; Setup parameters for call to function zcl_BuildAnalogData
   \   000112   EE           MOV     A,R6
   \   000113   FC           MOV     R4,A
   \   000114   EF           MOV     A,R7
   \   000115   FD           MOV     R5,A
   \   000116   AA..         MOV     R2,?V2
   \   000118   AB..         MOV     R3,?V3
   \   00011A   85..82       MOV     DPL,?V8
   \   00011D   85..83       MOV     DPH,?V9
   \   000120   E0           MOVX    A,@DPTR
   \   000121   F9           MOV     R1,A
   \   000122   12....       LCALL   `??zcl_BuildAnalogData::?relay`; Banked call to: zcl_BuildAnalogData
   \   000125   E5..         MOV     A,?V0
   \   000127   240B         ADD     A,#0xb
   \   000129   F582         MOV     DPL,A
   \   00012B   E4           CLR     A
   \   00012C   35..         ADDC    A,?V1
   \   00012E   F583         MOV     DPH,A
   \   000130   E5..         MOV     A,?V2
   \   000132   F0           MOVX    @DPTR,A
   \   000133   A3           INC     DPTR
   \   000134   E5..         MOV     A,?V3
   \   000136   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000139   12....       LCALL   `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   00013C   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   00013F   5001         JNC     ??zclParseInReadReportCfgRspCmd_13
   \   000141   0A           INC     R2
   \                     ??zclParseInReadReportCfgRspCmd_13:
   \   000142   E5..         MOV     A,?V2
   \   000144   2A           ADD     A,R2
   \   000145   F5..         MOV     ?V2,A
   \   000147   E4           CLR     A
   \   000148   35..         ADDC    A,?V3
   \   00014A   F5..         MOV     ?V3,A
   \   00014C   02....       LJMP    ??CrossCallReturnLabel_58 & 0xFFFF
   4005                }
   4006              }
   4007            }
   4008          
   4009            return ( (void *)readReportCfgRspCmd );
   \                     ??zclParseInReadReportCfgRspCmd_6:
   \   00014F   02....       LJMP    ?Subroutine6 & 0xFFFF
   4010          }
   4011          
   4012          /*********************************************************************
   4013           * @fn      zclParseInReportCmd
   4014           *
   4015           * @brief   Parse the "Profile" Report Command
   4016           *
   4017           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4018           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4019           *
   4020           * @param   pCmd - pointer to incoming data to parse
   4021           *
   4022           * @return  pointer to the parsed command structure
   4023           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4024          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReportCmd:
   4025          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine73 & 0xFFFF
   4026            zclReportCmd_t *reportCmd;
   4027            uint8 *pBuf = pCmd->pData;
   4028            uint16 attrDataLen;
   4029            uint8 *dataPtr;
   4030            uint8 numAttr = 0;
   4031            uint8 hdrLen;
   4032            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_124:
   \   000008   801A         SJMP    ??CrossCallReturnLabel_240
   4033          
   4034            // find out the number of attributes and the length of attribute data
   4035            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   4036            {
   4037              uint8 dataType;
   4038          
   4039              numAttr++;
   \                     ??zclParseInReportCmd_0:
   \   00000A   12....       LCALL   ?Subroutine109 & 0xFFFF
   4040              pBuf += 2; // move pass attribute id
   4041          
   4042              dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_193:
   \   00000D   5002         JNC     ??zclParseInReportCmd_1
   \   00000F   05..         INC     ?V1
   4043          
   4044              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \                     ??zclParseInReportCmd_1:
   \   000011                ; Setup parameters for call to function zclGetAttrDataLength
   \   000011   FA           MOV     R2,A
   \   000012   AB..         MOV     R3,?V1
   \   000014   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000017   12....       LCALL   ?Subroutine124 & 0xFFFF
   4045              pBuf += attrDataLen; // move pass attribute data
   4046          
   4047              // add padding if needed
   4048              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_225:
   \   00001A   5005         JNC     ??zclParseInReportCmd_2
   4049              {
   4050                attrDataLen++;
   \   00001C   0E           INC     R6
   \   00001D   04           INC     A
   \   00001E   7001         JNZ     ??zclParseInReportCmd_2
   \   000020   0F           INC     R7
   4051              }
   4052          
   4053              dataLen += attrDataLen;
   \                     ??zclParseInReportCmd_2:
   \   000021   12....       LCALL   ?Subroutine131 & 0xFFFF
   4054            }
   \                     ??CrossCallReturnLabel_240:
   \   000024   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000027   40E1         JC      ??zclParseInReportCmd_0
   4055          
   4056            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   \   000029   75F005       MOV     B,#0x5
   \   00002C   E5..         MOV     A,?V7
   \   00002E   A4           MUL     AB
   \   00002F   04           INC     A
   \   000030   FE           MOV     R6,A
   4057          
   4058            reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000031                ; Setup parameters for call to function osal_mem_alloc
   \   000031   25..         ADD     A,?V4
   \   000033   FA           MOV     R2,A
   \   000034   E4           CLR     A
   \   000035   35..         ADDC    A,?V5
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003B   8A..         MOV     ?V10,R2
   \   00003D   8B..         MOV     ?V11,R3
   4059            if (reportCmd != NULL )
   \   00003F   EA           MOV     A,R2
   \   000040   45..         ORL     A,?V11
   \   000042   604C         JZ      ??zclParseInReportCmd_3
   4060            {
   4061              uint8 i;
   4062              pBuf = pCmd->pData;
   \   000044   12....       LCALL   ?Subroutine56 & 0xFFFF
   4063              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   4064          
   4065              reportCmd->numAttr = numAttr;
   4066              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_93:
   \   000047   8040         SJMP    ??CrossCallReturnLabel_236
   4067              {
   4068                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zclParseInReportCmd_4:
   \   000049   12....       LCALL   ?Subroutine15 & 0xFFFF
   4069          
   4070                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4071                pBuf += 2;
   4072                reportRec->dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_3:
   \   00004C   5002         JNC     ??zclParseInReportCmd_5
   \   00004E   05..         INC     ?V1
   4073          
   4074                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   \                     ??zclParseInReportCmd_5:
   \   000050                ; Setup parameters for call to function zclGetAttrDataLength
   \   000050   FA           MOV     R2,A
   \   000051   AB..         MOV     R3,?V1
   \   000053   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000056   8A..         MOV     ?V4,R2
   \   000058   8B..         MOV     ?V5,R3
   \   00005A   AE..         MOV     R6,?V4
   \   00005C   AF..         MOV     R7,?V5
   4075                zcl_memcpy( dataPtr, pBuf, attrDataLen );
   \   00005E                ; Setup parameters for call to function osal_memcpy
   \   00005E   85....       MOV     ?V4,?V0
   \   000061   85....       MOV     ?V5,?V1
   \   000064   75..00       MOV     ?V6,#0x0
   \   000067   78..         MOV     R0,#?V4
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00006C   EE           MOV     A,R6
   \   00006D   FC           MOV     R4,A
   \   00006E   EF           MOV     A,R7
   \   00006F   FD           MOV     R5,A
   \   000070   AA..         MOV     R2,?V2
   \   000072   AB..         MOV     R3,?V3
   \   000074   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000077   7403         MOV     A,#0x3
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   4076                reportRec->attrData = dataPtr;
   \   00007C   12....       LCALL   ?Subroutine21 & 0xFFFF
   4077          
   4078                pBuf += attrDataLen; // move pass attribute data
   4079          
   4080                // advance attribute data pointer
   4081                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_11:
   \   00007F   5005         JNC     ??zclParseInReportCmd_6
   4082                {
   4083                  attrDataLen++;
   \   000081   0E           INC     R6
   \   000082   04           INC     A
   \   000083   7001         JNZ     ??zclParseInReportCmd_6
   \   000085   0F           INC     R7
   4084                }
   4085          
   4086                dataPtr += attrDataLen;
   \                     ??zclParseInReportCmd_6:
   \   000086   12....       LCALL   ?Subroutine129 & 0xFFFF
   4087              }
   \                     ??CrossCallReturnLabel_236:
   \   000089   E5..         MOV     A,?V8
   \   00008B   C3           CLR     C
   \   00008C   95..         SUBB    A,?V7
   \   00008E   40B9         JC      ??zclParseInReportCmd_4
   4088            }
   4089          
   4090            return ( (void *)reportCmd );
   \                     ??zclParseInReportCmd_3:
   \   000090   02....       LJMP    ?Subroutine7 & 0xFFFF
   4091          }
   4092          #endif // ZCL_REPORT
   4093          
   4094          /*********************************************************************
   4095           * @fn      zclParseInDefaultRspCmd
   4096           *
   4097           * @brief   Parse the "Profile" Default Response Command
   4098           *
   4099           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4100           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4101           *
   4102           * @param   pCmd - pointer to incoming data to parse
   4103           *
   4104           * @return  pointer to the parsed command structure
   4105           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4106          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   4107          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   4108            zclDefaultRspCmd_t *defaultRspCmd;
   4109            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine99 & 0xFFFF
   4110          
   4111            defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_170:
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   7A02         MOV     R2,#0x2
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   4112            if ( defaultRspCmd != NULL )
   \   00000F   EA           MOV     A,R2
   \   000010   4B           ORL     A,R3
   \   000011   6009         JZ      ??zclParseInDefaultRspCmd_0
   4113            {
   4114              defaultRspCmd->commandID = *pBuf++;
   \   000013   12....       LCALL   ?Subroutine19 & 0xFFFF
   4115              defaultRspCmd->statusCode = *pBuf;
   4116            }
   \                     ??CrossCallReturnLabel_454:
   \   000016   8A82         MOV     DPL,R2
   \   000018   8B83         MOV     DPH,R3
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
   4117          
   4118            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_0:
   \   00001C   02....       LJMP    ?Subroutine3 & 0xFFFF
   4119          }
   4120          
   4121          #ifdef ZCL_DISCOVER
   4122          /*********************************************************************
   4123           * @fn      zclParseInDiscAttrsCmd
   4124           *
   4125           * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
   4126           *
   4127           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4128           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4129           *
   4130           * @param   pCmd - pointer to incoming data to parse
   4131           *
   4132           * @return  pointer to the parsed command structure
   4133           */
   4134          void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
   4135          {
   4136            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4137            uint8 *pBuf = pCmd->pData;
   4138          
   4139            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
   4140            if ( pDiscoverCmd != NULL )
   4141            {
   4142              pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   4143              pBuf += 2;
   4144              pDiscoverCmd->maxAttrIDs = *pBuf;
   4145            }
   4146          
   4147            return ( (void *)pDiscoverCmd );
   4148          }
   4149          
   4150          /*********************************************************************
   4151           * @fn      zclParseInDiscAttrsRspCmd
   4152           *
   4153           * @brief   Parse the "Profile" Discovery Response Commands
   4154           *
   4155           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4156           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4157           *
   4158           * @param   pCmd - pointer to incoming data to parse
   4159           *
   4160           * @return  pointer to the parsed command structure
   4161           */
   4162          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4163          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
   4164          {
   4165            zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
   4166            uint8 *pBuf = pCmd->pData;
   4167            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   4168          
   4169            pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
   4170                              ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
   4171          
   4172            if ( pDiscoverRspCmd != NULL )
   4173            {
   4174              uint8 i;
   4175          
   4176              pDiscoverRspCmd->discComplete = *pBuf++;
   4177              pDiscoverRspCmd->numAttr = numAttr;
   4178          
   4179              for ( i = 0; i < numAttr; i++ )
   4180              {
   4181                pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4182                pBuf += 2;
   4183                pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
   4184              }
   4185            }
   4186          
   4187            return ( (void *)pDiscoverRspCmd );
   4188          }
   4189          
   4190          /*********************************************************************
   4191           * @fn      zclParseInDiscCmdsCmd
   4192           *
   4193           * @brief   Parse the "Profile" Discovery Commands
   4194           *
   4195           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4196           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4197           *
   4198           * @param   pCmd - pointer to incoming data to parse
   4199           *
   4200           * @return  pointer to the parsed command structure
   4201           */
   4202          void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
   4203          {
   4204            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4205            uint8 *pBuf = pCmd->pData;
   4206          
   4207            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
   4208            if ( pDiscoverCmd != NULL )
   4209            {
   4210              pDiscoverCmd->startCmdID = *pBuf++;
   4211              pDiscoverCmd->maxCmdID = *pBuf++;
   4212            }
   4213          
   4214            return ( (void *)pDiscoverCmd );
   4215          }
   4216          
   4217          /*********************************************************************
   4218           * @fn      zclParseInDiscCmdsRspCmd
   4219           *
   4220           * @brief   Parse the Discover Commands Response Command
   4221           *
   4222           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4223           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4224           *
   4225           * @param   pCmd - pointer to incoming data to parse
   4226           *
   4227           * @return  pointer to the parsed command structure
   4228           */
   4229          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4230          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
   4231          {
   4232            zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
   4233            uint8 *pBuf = pCmd->pData;
   4234            uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // length of command ID variable array
   4235          
   4236              // allocate memory for size of structure plus variable array
   4237            pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmdRsp_t ) +
   4238                              ( numCmds * sizeof(uint8) ) );
   4239            if ( pDiscoverRspCmd != NULL )
   4240            {
   4241              uint8 i;
   4242              pDiscoverRspCmd->discComplete = *pBuf++;
   4243              pDiscoverRspCmd->numCmd = numCmds;
   4244          
   4245              for ( i = 0; i < numCmds; i++ )
   4246              {
   4247                pDiscoverRspCmd->pCmdID[i] = *pBuf++;
   4248              }
   4249            }
   4250          
   4251            return ( (void *)pDiscoverRspCmd );
   4252          }
   4253          
   4254          /*********************************************************************
   4255           * @fn      zclParseInDiscAttrsExtRspCmd
   4256           *
   4257           * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
   4258           *
   4259           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4260           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4261           *
   4262           * @param   pCmd - pointer to incoming data to parse
   4263           *
   4264           * @return  pointer to the parsed command structure
   4265           */
   4266          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4267          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
   4268          {
   4269            zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
   4270            uint8 i;
   4271            uint8 *pBuf = pCmd->pData;
   4272            uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
   4273          
   4274            pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
   4275                              ( numAttrs * sizeof(zclExtAttrInfo_t) ) );
   4276          
   4277            if ( pDiscoverRspCmd != NULL )
   4278            {
   4279              pDiscoverRspCmd->discComplete = *pBuf++;
   4280              pDiscoverRspCmd->numAttr = numAttrs;
   4281          
   4282              for ( i = 0; i < numAttrs; i++ )
   4283              {
   4284                pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4285                pBuf += 2;
   4286                pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
   4287                pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
   4288              }
   4289            }
   4290          
   4291            return ( (void *)pDiscoverRspCmd );
   4292          }
   4293          #endif // ZCL_DISCOVER
   4294          
   4295          #ifdef ZCL_READ
   4296          /*********************************************************************
   4297           * @fn      zclProcessInReadCmd
   4298           *
   4299           * @brief   Process the "Profile" Read Command
   4300           *
   4301           * @param   pInMsg - incoming message to process
   4302           *
   4303           * @return  TRUE if command processed. FALSE, otherwise.
   4304           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine183_0
   \   000004                ; // Fall through to label ??Subroutine183_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4305          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   4306          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   4307            zclReadCmd_t *readCmd;
   4308            zclReadRspCmd_t *readRspCmd;
   4309            zclAttrRec_t attrRec;
   4310            uint16 len;
   4311            uint8 i;
   4312          
   4313            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   E4           CLR     A
   \   000014   3F           ADDC    A,R7
   \   000015   F583         MOV     DPH,A
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V10,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V11,A
   4314          
   4315            // calculate the length of the response status record
   4316            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   4317          
   4318            readRspCmd = zcl_mem_alloc( len );
   \   00001E                ; Setup parameters for call to function osal_mem_alloc
   \   00001E   85..82       MOV     DPL,?V10
   \   000021   F583         MOV     DPH,A
   \   000023   E0           MOVX    A,@DPTR
   \   000024   75F006       MOV     B,#0x6
   \   000027   12....       LCALL   ??Subroutine217_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_517:
   \   00002A   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00002D   8A..         MOV     ?V0,R2
   \   00002F   8B..         MOV     ?V1,R3
   4319            if ( readRspCmd == NULL )
   \   000031   EA           MOV     A,R2
   \   000032   45..         ORL     A,?V1
   \   000034   7005         JNZ     ??zclProcessInReadCmd_0
   4320            {
   4321              return FALSE; // EMBEDDED RETURN
   \   000036   7900         MOV     R1,#0x0
   \   000038   02....       LJMP    ??zclProcessInReadCmd_1 & 0xFFFF
   4322            }
   4323          
   4324            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_0:
   \   00003B   85..82       MOV     DPL,?V10
   \   00003E   85..83       MOV     DPH,?V11
   \   000041   12....       LCALL   ?Subroutine102 & 0xFFFF
   4325            for ( i = 0; i < readCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_176:
   \   000044   75..00       MOV     ?V2,#0x0
   \   000047   800B         SJMP    ??zclProcessInReadCmd_2
   4326            {
   4327              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   4328          
   4329              statusRec->attrID = readCmd->attrID[i];
   4330          
   4331              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4332                                   readCmd->attrID[i], &attrRec ) )
   4333              {
   4334                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   4335                {
   4336                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
   4337                                                        &(pInMsg->msg->srcAddr), &attrRec );
   4338                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   4339                  {
   4340                    statusRec->data = attrRec.attr.dataPtr;
   4341                    statusRec->dataType = attrRec.attr.dataType;
   4342                  }
   4343                }
   4344                else
   4345                {
   4346                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   4347                }
   4348              }
   4349              else
   4350              {
   4351                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_3:
   \   000049   85..82       MOV     DPL,?V6
   \   00004C   85..83       MOV     DPH,?V7
   \   00004F   7486         MOV     A,#-0x7a
   \                     ??zclProcessInReadCmd_4:
   \   000051   F0           MOVX    @DPTR,A
   4352              }
   \                     ??zclProcessInReadCmd_5:
   \   000052   05..         INC     ?V2
   \                     ??zclProcessInReadCmd_2:
   \   000054   85..82       MOV     DPL,?V10
   \   000057   85..83       MOV     DPH,?V11
   \   00005A   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_446:
   \   00005D   4003         JC      $+5
   \   00005F   02....       LJMP    ??zclProcessInReadCmd_6 & 0xFFFF
   \   000062   A8..         MOV     R0,?V2
   \   000064   E8           MOV     A,R0
   \   000065   75F006       MOV     B,#0x6
   \   000068   A4           MUL     AB
   \   000069   FA           MOV     R2,A
   \   00006A   ABF0         MOV     R3,B
   \   00006C   E5..         MOV     A,?V0
   \   00006E   2A           ADD     A,R2
   \   00006F   F582         MOV     DPL,A
   \   000071   E5..         MOV     A,?V1
   \   000073   3B           ADDC    A,R3
   \   000074   F583         MOV     DPH,A
   \   000076   A3           INC     DPTR
   \   000077   8582..       MOV     ?V4,DPL
   \   00007A   8583..       MOV     ?V5,DPH
   \   00007D   E8           MOV     A,R0
   \   00007E   28           ADD     A,R0
   \   00007F   F8           MOV     R0,A
   \   000080   E4           CLR     A
   \   000081   33           RLC     A
   \   000082   F9           MOV     R1,A
   \   000083   E5..         MOV     A,?V10
   \   000085   28           ADD     A,R0
   \   000086   F582         MOV     DPL,A
   \   000088   E5..         MOV     A,?V11
   \   00008A   12....       LCALL   ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   00008D   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000090   12....       LCALL   ??Subroutine209_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_466:
   \   000093   E5..         MOV     A,?V4
   \   000095   2402         ADD     A,#0x2
   \   000097   F5..         MOV     ?V6,A
   \   000099   E4           CLR     A
   \   00009A   35..         ADDC    A,?V5
   \   00009C   F5..         MOV     ?V7,A
   \   00009E   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_341:
   \   0000A1                ; Setup parameters for call to function zclFindAttrRec
   \   0000A1   A8..         MOV     R0,?XSP + 0
   \   0000A3   A9..         MOV     R1,?XSP + 1
   \   0000A5   88..         MOV     ?V12,R0
   \   0000A7   89..         MOV     ?V13,R1
   \   0000A9   78..         MOV     R0,#?V12
   \   0000AB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AE   8A82         MOV     DPL,R2
   \   0000B0   8B83         MOV     DPH,R3
   \   0000B2   12....       LCALL   ??Subroutine213_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_485:
   \   0000B5   85..82       MOV     DPL,?V8
   \   0000B8   85..83       MOV     DPH,?V9
   \   0000BB   12....       LCALL   ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_399:
   \   0000BE   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   0000C1   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000C4   7402         MOV     A,#0x2
   \   0000C6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C9   E9           MOV     A,R1
   \   0000CA   7003         JNZ     $+5
   \   0000CC   02....       LJMP    ??zclProcessInReadCmd_3 & 0xFFFF
   \   0000CF   7405         MOV     A,#0x5
   \   0000D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000D7   5066         JNC     ??zclProcessInReadCmd_7
   \   0000D9   8E82         MOV     DPL,R6
   \   0000DB   8F83         MOV     DPH,R7
   \   0000DD   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   0000E0   2406         ADD     A,#0x6
   \   0000E2   F5..         MOV     ?V8,A
   \   0000E4   E4           CLR     A
   \   0000E5   39           ADDC    A,R1
   \   0000E6   F5..         MOV     ?V9,A
   \   0000E8   7405         MOV     A,#0x5
   \   0000EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000ED   E0           MOVX    A,@DPTR
   \   0000EE   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000F0   5020         JNC     ??zclProcessInReadCmd_8
   \   0000F2                ; Setup parameters for call to function zclGetAuthorizeCB
   \   0000F2   12....       LCALL   ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   0000F5   12....       LCALL   `??zclGetAuthorizeCB::?relay`; Banked call to: zclGetAuthorizeCB
   \   0000F8   8A82         MOV     DPL,R2
   \   0000FA   8B83         MOV     DPH,R3
   \   0000FC   E582         MOV     A,DPL
   \   0000FE   4583         ORL     A,DPH
   \   000100   6010         JZ      ??zclProcessInReadCmd_8
   \   000102                ; Setup parameters for indirect call
   \   000102   7901         MOV     R1,#0x1
   \   000104   AC..         MOV     R4,?XSP + 0
   \   000106   AD..         MOV     R5,?XSP + 1
   \   000108   AA..         MOV     R2,?V8
   \   00010A   AB..         MOV     R3,?V9
   \   00010C   12....       LCALL   ?CALL_IND
   \   00010F   E9           MOV     A,R1
   \   000110   8002         SJMP    ??zclProcessInReadCmd_9
   \                     ??zclProcessInReadCmd_8:
   \   000112   7400         MOV     A,#0x0
   \                     ??zclProcessInReadCmd_9:
   \   000114   85..82       MOV     DPL,?V6
   \   000117   85..83       MOV     DPH,?V7
   \   00011A   F0           MOVX    @DPTR,A
   \   00011B   6003         JZ      $+5
   \   00011D   02....       LJMP    ??zclProcessInReadCmd_5 & 0xFFFF
   \   000120   7406         MOV     A,#0x6
   \   000122   12....       LCALL   ?XSTACK_DISP0_8
   \   000125   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000128   A3           INC     DPTR
   \   000129   A3           INC     DPTR
   \   00012A   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_469:
   \   00012D   7404         MOV     A,#0x4
   \   00012F   12....       LCALL   ?XSTACK_DISP0_8
   \   000132   E0           MOVX    A,@DPTR
   \   000133   85..82       MOV     DPL,?V4
   \   000136   85..83       MOV     DPH,?V5
   \   000139   A3           INC     DPTR
   \   00013A   A3           INC     DPTR
   \   00013B   A3           INC     DPTR
   \   00013C   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   \                     ??zclProcessInReadCmd_7:
   \   00013F   85..82       MOV     DPL,?V6
   \   000142   85..83       MOV     DPH,?V7
   \   000145   748F         MOV     A,#-0x71
   \   000147   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   4353            }
   4354          
   4355            // Build and send Read Response command
   4356            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   4357                             readRspCmd, !pInMsg->hdr.fc.direction,
   4358                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_6:
   \   00014A   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_342:
   \   00014D                ; Setup parameters for call to function zcl_SendReadRsp
   \   00014D   8E82         MOV     DPL,R6
   \   00014F   8F83         MOV     DPH,R7
   \   000151   A3           INC     DPTR
   \   000152   A3           INC     DPTR
   \   000153   A3           INC     DPTR
   \   000154   A3           INC     DPTR
   \   000155   A3           INC     DPTR
   \   000156   A3           INC     DPTR
   \   000157   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   00015A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00015D   75..01       MOV     ?V2,#0x1
   \   000160   78..         MOV     R0,#?V2
   \   000162   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000165   8E82         MOV     DPL,R6
   \   000167   8F83         MOV     DPH,R7
   \   000169   12....       LCALL   ??Subroutine211_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_477:
   \   00016C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00016F   78..         MOV     R0,#?V0
   \   000171   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000174   85..82       MOV     DPL,?V8
   \   000177   85..83       MOV     DPH,?V9
   \   00017A   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_491:
   \   00017D   E5..         MOV     A,?V8
   \   00017F   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_492:
   \   000182   35..         ADDC    A,?V9
   \   000184   FB           MOV     R3,A
   \   000185   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000188   12....       LCALL   `??zcl_SendReadRsp::?relay`; Banked call to: zcl_SendReadRsp
   \   00018B   7405         MOV     A,#0x5
   \   00018D   12....       LCALL   ?DEALLOC_XSTACK8
   4359            zcl_mem_free( readRspCmd );
   \   000190                ; Setup parameters for call to function osal_mem_free
   \   000190   AA..         MOV     R2,?V0
   \   000192   AB..         MOV     R3,?V1
   \   000194   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4360          
   4361            return TRUE;
   \   000197   7901         MOV     R1,#0x1
   \                     ??zclProcessInReadCmd_1:
   \   000199   7408         MOV     A,#0x8
   \   00019B   02....       LJMP    ?Subroutine11 & 0xFFFF
   4362          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine115:
   \   000000   E5..         MOV     A,?V8
   \   000002   12....       LCALL   ?Subroutine166 & 0xFFFF
   \                     ??CrossCallReturnLabel_289:
   \   000005   35..         ADDC    A,?V9
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine209_0
   \   000002                ; // Fall through to label ??Subroutine209_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine211_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   12....       LCALL   ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_481:
   \   000005   F5..         MOV     ?V2,A
   \   000007   78..         MOV     R0,#?V2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine214_0:
   \   000000   2406         ADD     A,#0x6
   \   000002   FA           MOV     R2,A
   \   000003   E4           CLR     A
   \   000004   22           RET
   4363          #endif // ZCL_READ
   4364          
   4365          #ifdef ZCL_WRITE
   4366          /*********************************************************************
   4367           * @fn      processInWriteCmd
   4368           *
   4369           * @brief   Process the "Profile" Write and Write No Response Commands
   4370           *
   4371           * @param   pInMsg - incoming message to process
   4372           *
   4373           * @return  TRUE if command processed. FALSE, otherwise.
   4374           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4375          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   4376          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   4377            zclWriteCmd_t *writeCmd;
   4378            zclWriteRspCmd_t *writeRspCmd;
   4379            uint8 sendRsp = FALSE;
   \   00000E   C2..         CLR     ?VB.0
   4380            uint8 j = 0;
   \   000010   12....       LCALL   ?Subroutine119 & 0xFFFF
   4381            uint8 i;
   4382          
   4383            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_212:
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F5..         MOV     ?V14,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V15,A
   4384            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \   00001A   8A82         MOV     DPL,R2
   \   00001C   8B83         MOV     DPH,R3
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   6402         XRL     A,#0x2
   \   000028   701C         JNZ     ??zclProcessInWriteCmd_0
   4385            {
   4386              // We need to send a response back - allocate space for it
   4387              writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4388                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   00002A                ; Setup parameters for call to function osal_mem_alloc
   \   00002A   85..82       MOV     DPL,?V14
   \   00002D   85..83       MOV     DPH,?V15
   \   000030   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   000033   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000036   8A..         MOV     ?V0,R2
   \   000038   8B..         MOV     ?V1,R3
   4389              if ( writeRspCmd == NULL )
   \   00003A   EA           MOV     A,R2
   \   00003B   45..         ORL     A,?V1
   \   00003D   7005         JNZ     ??zclProcessInWriteCmd_1
   4390              {
   4391                return FALSE; // EMBEDDED RETURN
   \   00003F   7900         MOV     R1,#0x0
   \   000041   02....       LJMP    ??zclProcessInWriteCmd_2 & 0xFFFF
   4392              }
   4393          
   4394              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_1:
   \   000044   D2..         SETB    ?VB.0
   4395            }
   4396          
   4397            for ( i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteCmd_0:
   \   000046   7F00         MOV     R7,#0x0
   \   000048   801A         SJMP    ??zclProcessInWriteCmd_3
   4398            {
   4399              zclAttrRec_t attrRec;
   4400              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4401          
   4402              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4403                                   statusRec->attrID, &attrRec ) )
   4404              {
   4405                if ( statusRec->dataType == attrRec.attr.dataType )
   4406                {
   4407                  uint8 status;
   4408          
   4409                  // Write the new attribute value
   4410                  if ( attrRec.attr.dataPtr != NULL )
   4411                  {
   4412                    status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4413                                               &attrRec, statusRec );
   4414                  }
   4415                  else // Use CB
   4416                  {
   4417                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4418                                                      &attrRec, statusRec->attrData );
   4419                  }
   4420          
   4421                  // If successful, a write attribute status record shall NOT be generated
   4422                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   4423                  {
   4424                    // Attribute is read only - move on to the next write attribute record
   4425                    writeRspCmd->attrList[j].status = status;
   4426                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4427                  }
   4428                }
   4429                else
   4430                {
   4431                  // Attribute data type is incorrect - move on to the next write attribute record
   4432                  if ( sendRsp )
   4433                  {
   4434                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4435                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4436                  }
   4437                }
   4438              }
   4439              else
   4440              {
   4441                // Attribute is not supported - move on to the next write attribute record
   4442                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_4:
   \   00004A   A2..         MOV     C,?VB.0
   \   00004C   5015         JNC     ??zclProcessInWriteCmd_5
   4443                {
   4444                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   00004E   85..82       MOV     DPL,?V12
   \   000051   85..83       MOV     DPH,?V13
   \   000054   7486         MOV     A,#-0x7a
   4445                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4446                }
   4447              }
   \                     ??zclProcessInWriteCmd_6:
   \   000056   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000059   85..82       MOV     DPL,?V8
   \   00005C   85..83       MOV     DPH,?V9
   \   00005F   12....       LCALL   ??Subroutine209_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_467:
   \   000062   0E           INC     R6
   \                     ??zclProcessInWriteCmd_5:
   \   000063   0F           INC     R7
   \                     ??zclProcessInWriteCmd_3:
   \   000064   85..82       MOV     DPL,?V14
   \   000067   85..83       MOV     DPH,?V15
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   F8           MOV     R0,A
   \   00006C   EF           MOV     A,R7
   \   00006D   C3           CLR     C
   \   00006E   98           SUBB    A,R0
   \   00006F   4003         JC      $+5
   \   000071   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   \   000074   EF           MOV     A,R7
   \   000075   75F005       MOV     B,#0x5
   \   000078   A4           MUL     AB
   \   000079   F8           MOV     R0,A
   \   00007A   A9F0         MOV     R1,B
   \   00007C   E5..         MOV     A,?V14
   \   00007E   28           ADD     A,R0
   \   00007F   F582         MOV     DPL,A
   \   000081   E5..         MOV     A,?V15
   \   000083   12....       LCALL   ??Subroutine210_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_472:
   \   000086   8582..       MOV     ?V2,DPL
   \   000089   8583..       MOV     ?V3,DPH
   \   00008C   EE           MOV     A,R6
   \   00008D   75F003       MOV     B,#0x3
   \   000090   A4           MUL     AB
   \   000091   F8           MOV     R0,A
   \   000092   A9F0         MOV     R1,B
   \   000094   E5..         MOV     A,?V0
   \   000096   28           ADD     A,R0
   \   000097   F582         MOV     DPL,A
   \   000099   E5..         MOV     A,?V1
   \   00009B   39           ADDC    A,R1
   \   00009C   F583         MOV     DPH,A
   \   00009E   E582         MOV     A,DPL
   \   0000A0   2402         ADD     A,#0x2
   \   0000A2   F5..         MOV     ?V8,A
   \   0000A4   E4           CLR     A
   \   0000A5   3583         ADDC    A,DPH
   \   0000A7   F5..         MOV     ?V9,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   8582..       MOV     ?V12,DPL
   \   0000AD   8583..       MOV     ?V13,DPH
   \   0000B0   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   0000B3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B6   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   0000B9   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000BC   7402         MOV     A,#0x2
   \   0000BE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C1   E9           MOV     A,R1
   \   0000C2   6086         JZ      ??zclProcessInWriteCmd_4
   \   0000C4   85..82       MOV     DPL,?V2
   \   0000C7   85..83       MOV     DPH,?V3
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   E0           MOVX    A,@DPTR
   \   0000CD   F8           MOV     R0,A
   \   0000CE   7404         MOV     A,#0x4
   \   0000D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   68           XRL     A,R0
   \   0000D5   706E         JNZ     ??zclProcessInWriteCmd_8
   \   0000D7   85..82       MOV     DPL,?V4
   \   0000DA   85..83       MOV     DPH,?V5
   \   0000DD   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   0000E0   2414         ADD     A,#0x14
   \   0000E2   F5..         MOV     ?V6,A
   \   0000E4   E4           CLR     A
   \   0000E5   39           ADDC    A,R1
   \   0000E6   F5..         MOV     ?V7,A
   \   0000E8   12....       LCALL   ?Subroutine167 & 0xFFFF
   \                     ??CrossCallReturnLabel_496:
   \   0000EB   39           ADDC    A,R1
   \   0000EC   FB           MOV     R3,A
   \   0000ED   7406         MOV     A,#0x6
   \   0000EF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F2   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_377:
   \   0000F5   6017         JZ      ??zclProcessInWriteCmd_9
   \   0000F7                ; Setup parameters for call to function zclWriteAttrData
   \   0000F7   78..         MOV     R0,#?V2
   \   0000F9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FC   7402         MOV     A,#0x2
   \   0000FE   12....       LCALL   ?XSTACK_DISP102_8
   \   000101   85..82       MOV     DPL,?V6
   \   000104   85..83       MOV     DPH,?V7
   \   000107   E0           MOVX    A,@DPTR
   \   000108   F9           MOV     R1,A
   \   000109   12....       LCALL   `??zclWriteAttrData::?relay`; Banked call to: zclWriteAttrData
   \   00010C   801C         SJMP    ??zclProcessInWriteCmd_10
   \                     ??zclProcessInWriteCmd_9:
   \   00010E                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   00010E   85..82       MOV     DPL,?V2
   \   000111   85..83       MOV     DPH,?V3
   \   000114   A3           INC     DPTR
   \   000115   A3           INC     DPTR
   \   000116   A3           INC     DPTR
   \   000117   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00011A   7402         MOV     A,#0x2
   \   00011C   12....       LCALL   ?XSTACK_DISP102_8
   \   00011F   85..82       MOV     DPL,?V6
   \   000122   85..83       MOV     DPH,?V7
   \   000125   E0           MOVX    A,@DPTR
   \   000126   F9           MOV     R1,A
   \   000127   12....       LCALL   `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \                     ??zclProcessInWriteCmd_10:
   \   00012A   7402         MOV     A,#0x2
   \   00012C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012F   E9           MOV     A,R1
   \   000130   A2..         MOV     C,?VB.0
   \   000132   4003         JC      $+5
   \   000134   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   000137   7003         JNZ     $+5
   \   000139   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   00013C   85..82       MOV     DPL,?V12
   \   00013F   85..83       MOV     DPH,?V13
   \   000142   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \                     ??zclProcessInWriteCmd_8:
   \   000145   A2..         MOV     C,?VB.0
   \   000147   4003         JC      $+5
   \   000149   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   00014C   85..82       MOV     DPL,?V12
   \   00014F   85..83       MOV     DPH,?V13
   \   000152   748D         MOV     A,#-0x73
   \   000154   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   4448            } // for loop
   4449          
   4450            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_7:
   \   000157   A2..         MOV     C,?VB.0
   \   000159   5038         JNC     ??zclProcessInWriteCmd_11
   4451            {
   4452              writeRspCmd->numAttr = j;
   \   00015B   EE           MOV     A,R6
   \   00015C   85..82       MOV     DPL,?V0
   \   00015F   85..83       MOV     DPH,?V1
   \   000162   F0           MOVX    @DPTR,A
   4453              if ( writeRspCmd->numAttr == 0 )
   \   000163   7003         JNZ     ??CrossCallReturnLabel_51
   4454              {
   4455                // Since all records were written successful, include a single status record
   4456                // in the resonse command with the status field set to SUCCESS and the
   4457                // attribute ID field omitted.
   4458                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000165   12....       LCALL   ?Subroutine40 & 0xFFFF
   4459                writeRspCmd->numAttr = 1;
   4460              }
   4461          
   4462              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4463                                pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4464                                true, pInMsg->hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_51:
   \   000168   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   00016B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00016E   75..01       MOV     ?V2,#0x1
   \   000171   78..         MOV     R0,#?V2
   \   000173   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000176   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_478:
   \   000179   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00017C   78..         MOV     R0,#?V0
   \   00017E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000181   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000184   12....       LCALL   `??zcl_SendWriteRsp::?relay`; Banked call to: zcl_SendWriteRsp
   \   000187   7405         MOV     A,#0x5
   \   000189   12....       LCALL   ?DEALLOC_XSTACK8
   4465              zcl_mem_free( writeRspCmd );
   \   00018C                ; Setup parameters for call to function osal_mem_free
   \   00018C   AA..         MOV     R2,?V0
   \   00018E   AB..         MOV     R3,?V1
   \   000190   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4466            }
   4467          
   4468            return TRUE;
   \                     ??zclProcessInWriteCmd_11:
   \   000193   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteCmd_2:
   \   000195   7408         MOV     A,#0x8
   \   000197   02....       LJMP    ??Subroutine174_0 & 0xFFFF
   4469          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine211_0
   \   000006                ; // Fall through to label ??Subroutine211_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine167:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine214_0
   \   000001                ; // Fall through to label ??Subroutine214_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine119:
   \   000000   7E00         MOV     R6,#0x0
   \   000002   EA           MOV     A,R2
   \   000003   240C         ADD     A,#0xc
   \   000005   F582         MOV     DPL,A
   \   000007   E4           CLR     A
   \   000008   35..         ADDC    A,?V5
   \   00000A   F583         MOV     DPH,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine151:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine215_0
   \   000006                ; // Fall through to label ??Subroutine215_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   12....       LCALL   ?Subroutine168 & 0xFFFF
   \                     ??CrossCallReturnLabel_519:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   12....       LCALL   ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_499:
   \   000003                ; Setup parameters for call to function zclFindAttrRec
   \   000003                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000003   A8..         MOV     R0,?XSP + 0
   \   000005   A9..         MOV     R1,?XSP + 1
   \   000007   88..         MOV     ?V10,R0
   \   000009   89..         MOV     ?V11,R1
   \   00000B   78..         MOV     R0,#?V10
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   12....       LCALL   ??Subroutine220_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_526:
   \   000009                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000009                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000009   85..82       MOV     DPL,?V4
   \   00000C   85..83       MOV     DPH,?V5
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F5..         MOV     ?V2,A
   \   000018   78..         MOV     R0,#?V2
   \   00001A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_533:
   \   000007   EE           MOV     A,R6
   \   000008   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_495:
   \   00000B   3F           ADDC    A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   EE           MOV     A,R6
   \   00000E   12....       LCALL   ?Subroutine166 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   000011   3F           ADDC    A,R7
   \   000012   F583         MOV     DPH,A
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006   12....       LCALL   ??Subroutine221_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_531:
   \   000009   85..82       MOV     DPL,?V6
   \   00000C   85..83       MOV     DPH,?V7
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_404:
   \   000016   E5..         MOV     A,?V6
   \   000018   12....       LCALL   ?Subroutine166 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   00001B   35..         ADDC    A,?V7
   \   00001D   F583         MOV     DPH,A
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   A3           INC     DPTR
   \   000001   E4           CLR     A
   \   000002   F0           MOVX    @DPTR,A
   \   000003   85..82       MOV     DPL,?V0
   \   000006   85..83       MOV     DPH,?V1
   \   000009   04           INC     A
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V2
   \   000004   85..83       MOV     DPH,?V3
   \   000007   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_506:
   \   00000A   22           RET
   4470          
   4471          /*********************************************************************
   4472           * @fn      zclRevertWriteUndividedCmd
   4473           *
   4474           * @brief   Revert the "Profile" Write Undevided Command
   4475           *
   4476           * @param   pInMsg - incoming message to process
   4477           * @param   curWriteRec - old data
   4478           * @param   numAttr - number of attributes to be reverted
   4479           *
   4480           * @return  none
   4481           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4482          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   \                     zclRevertWriteUndividedCmd:
   4483                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   4484          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   8C..         MOV     ?V10,R4
   \   000010   8D..         MOV     ?V11,R5
   4485            uint8 i;
   4486          
   4487            for ( i = 0; i < numAttr; i++ )
   \   000012   75..00       MOV     ?V0,#0x0
   \   000015   741C         MOV     A,#0x1c
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_340:
   \   00001D   8030         SJMP    ??zclRevertWriteUndividedCmd_0
   4488            {
   4489              zclAttrRec_t attrRec;
   4490              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   4491          
   4492              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4493                                    statusRec->attrID, &attrRec ) )
   4494              {
   4495                break; // should never happen
   4496              }
   4497          
   4498              if ( attrRec.attr.dataPtr != NULL )
   4499              {
   4500                // Just copy the old data back - no need to validate the data
   4501                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   4502                zcl_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   4503              }
   4504              else // Use CB
   4505              {
   4506                // Write the old data back
   4507                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4508                                         &attrRec, statusRec->attrData );
   \                     ??zclRevertWriteUndividedCmd_1:
   \   00001F   85..82       MOV     DPL,?V2
   \   000022   85..83       MOV     DPH,?V3
   \   000025   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   4509              }
   \                     ??CrossCallReturnLabel_422:
   \   000028                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000028   8A..         MOV     ?V4,R2
   \   00002A   8B..         MOV     ?V5,R3
   \   00002C   78..         MOV     R0,#?V4
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP102_8
   \   000036   EE           MOV     A,R6
   \   000037   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_493:
   \   00003A   3F           ADDC    A,R7
   \   00003B   FB           MOV     R3,A
   \   00003C   EE           MOV     A,R6
   \   00003D   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000040   3F           ADDC    A,R7
   \   000041   F583         MOV     DPH,A
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F9           MOV     R1,A
   \   000045   12....       LCALL   `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zclRevertWriteUndividedCmd_2:
   \   00004D   05..         INC     ?V0
   \                     ??zclRevertWriteUndividedCmd_0:
   \   00004F   C3           CLR     C
   \   000050   E5..         MOV     A,?V0
   \   000052   95..         SUBB    A,?V8
   \   000054   E4           CLR     A
   \   000055   95..         SUBB    A,?V9
   \   000057   4003         JC      $+5
   \   000059   02....       LJMP    ??zclRevertWriteUndividedCmd_3 & 0xFFFF
   \   00005C   E5..         MOV     A,?V0
   \   00005E   75F005       MOV     B,#0x5
   \   000061   A4           MUL     AB
   \   000062   F8           MOV     R0,A
   \   000063   A9F0         MOV     R1,B
   \   000065   E5..         MOV     A,?V10
   \   000067   28           ADD     A,R0
   \   000068   FE           MOV     R6,A
   \   000069   E5..         MOV     A,?V11
   \   00006B   39           ADDC    A,R1
   \   00006C   FF           MOV     R7,A
   \   00006D   85..82       MOV     DPL,?V2
   \   000070   85..83       MOV     DPH,?V3
   \   000073   12....       LCALL   ??Subroutine216_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_501:
   \   000076   88..         MOV     ?V4,R0
   \   000078   89..         MOV     ?V5,R1
   \   00007A                ; Setup parameters for call to function zclFindAttrRec
   \   00007A   A8..         MOV     R0,?XSP + 0
   \   00007C   A9..         MOV     R1,?XSP + 1
   \   00007E   88..         MOV     ?V6,R0
   \   000080   89..         MOV     ?V7,R1
   \   000082   78..         MOV     R0,#?V6
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000087   8E82         MOV     DPL,R6
   \   000089   8F83         MOV     DPH,R7
   \   00008B   12....       LCALL   ??Subroutine213_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_486:
   \   00008E   85..82       MOV     DPL,?V4
   \   000091   85..83       MOV     DPH,?V5
   \   000094   12....       LCALL   ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_400:
   \   000097   E5..         MOV     A,?V4
   \   000099   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   00009C   35..         ADDC    A,?V5
   \   00009E   F583         MOV     DPH,A
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   F9           MOV     R1,A
   \   0000A2   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000A5   7402         MOV     A,#0x2
   \   0000A7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AA   E9           MOV     A,R1
   \   0000AB   604D         JZ      ??zclRevertWriteUndividedCmd_3
   \   0000AD   EE           MOV     A,R6
   \   0000AE   2403         ADD     A,#0x3
   \   0000B0   F5..         MOV     ?V4,A
   \   0000B2   E4           CLR     A
   \   0000B3   3F           ADDC    A,R7
   \   0000B4   F5..         MOV     ?V5,A
   \   0000B6   85..82       MOV     DPL,?V4
   \   0000B9   F583         MOV     DPH,A
   \   0000BB   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_397:
   \   0000BE   7406         MOV     A,#0x6
   \   0000C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C3   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_423:
   \   0000C6   EE           MOV     A,R6
   \   0000C7   4F           ORL     A,R7
   \   0000C8   7003         JNZ     $+5
   \   0000CA   02....       LJMP    ??zclRevertWriteUndividedCmd_1 & 0xFFFF
   \   0000CD                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000CD   7404         MOV     A,#0x4
   \   0000CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   F9           MOV     R1,A
   \   0000D4   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000D7   8A..         MOV     ?V6,R2
   \   0000D9   8B..         MOV     ?V7,R3
   \   0000DB   AC..         MOV     R4,?V6
   \   0000DD   AD..         MOV     R5,?V7
   \   0000DF                ; Setup parameters for call to function osal_memcpy
   \   0000DF   85..82       MOV     DPL,?V4
   \   0000E2   85..83       MOV     DPH,?V5
   \   0000E5   12....       LCALL   ?Subroutine64 & 0xFFFF
   4510            } // for loop
   \                     ??CrossCallReturnLabel_103:
   \   0000E8   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000EB   EE           MOV     A,R6
   \   0000EC   FA           MOV     R2,A
   \   0000ED   EF           MOV     A,R7
   \   0000EE   FB           MOV     R3,A
   \   0000EF   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000F2   7403         MOV     A,#0x3
   \   0000F4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F7   02....       LJMP    ??zclRevertWriteUndividedCmd_2 & 0xFFFF
   4511          }
   \                     ??zclRevertWriteUndividedCmd_3:
   \   0000FA   7408         MOV     A,#0x8
   \   0000FC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000FF   02....       LJMP    ??Subroutine179_0 & 0xFFFF
   4512          
   4513          /*********************************************************************
   4514           * @fn      zclProcessInWriteUndividedCmd
   4515           *
   4516           * @brief   Process the "Profile" Write Undivided Command
   4517           *
   4518           * @param   pInMsg - incoming message to process
   4519           *
   4520           * @return  TRUE if command processed. FALSE, otherwise.
   4521           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4522          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   4523          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   4524            zclWriteCmd_t *writeCmd;
   4525            zclWriteRspCmd_t *writeRspCmd;
   4526            zclAttrRec_t attrRec;
   4527            uint16 dataLen;
   4528            uint16 curLen = 0;
   \   00000E   75..00       MOV     ?V8,#0x0
   \   000011   75..00       MOV     ?V9,#0x0
   4529            uint8 j = 0;
   \   000014   12....       LCALL   ?Subroutine119 & 0xFFFF
   4530            uint8 i;
   4531          
   4532            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_213:
   \   000017   12....       LCALL   ??Subroutine216_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_502:
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ??Subroutine209_0 & 0xFFFF
   4533          
   4534            // Allocate space for Write Response Command
   4535            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4536                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \                     ??CrossCallReturnLabel_468:
   \   000022                ; Setup parameters for call to function osal_mem_alloc
   \   000022   7402         MOV     A,#0x2
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   12....       LCALL   ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   00002A   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   00002D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000030   8A..         MOV     ?V0,R2
   \   000032   8B..         MOV     ?V1,R3
   4537            if ( writeRspCmd == NULL )
   \   000034   EA           MOV     A,R2
   \   000035   45..         ORL     A,?V1
   \   000037   7003         JNZ     $+5
   \   000039   02....       LJMP    ??zclProcessInWriteUndividedCmd_0 & 0xFFFF
   4538            {
   4539              return FALSE; // EMBEDDED RETURN
   4540            }
   4541          
   4542            // If any attribute cannot be written, no attribute values are changed. Hence,
   4543            // make sure all the attributes are supported and writable
   4544            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   00003C   7F00         MOV     R7,#0x0
   \   00003E   803C         SJMP    ??zclProcessInWriteUndividedCmd_1
   4545            {
   4546              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4547          
   4548              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4549                                    statusRec->attrID, &attrRec ) )
   4550              {
   4551                // Attribute is not supported - stop here
   4552                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4553                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4554                break;
   4555              }
   4556          
   4557              if ( statusRec->dataType != attrRec.attr.dataType )
   4558              {
   4559                // Attribute data type is incorrect - stope here
   4560                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4561                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4562                break;
   4563              }
   4564          
   4565              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   4566              {
   4567                // Attribute is not writable - stop here
   4568                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   4569                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4570                break;
   4571              }
   4572          
   4573              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   4574              {
   4575                // Not authorized to write - stop here
   4576                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   4577                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4578                break;
   4579              }
   4580          
   4581              // Attribute Data length
   4582              if ( attrRec.attr.dataPtr != NULL )
   4583              {
   4584                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   4585              }
   4586              else // Use CB
   4587              {
   4588                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4589                                                       statusRec->attrID );
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   000040   12....       LCALL   ?Subroutine66 & 0xFFFF
   4590              }
   \                     ??CrossCallReturnLabel_521:
   \   000043   12....       LCALL   ??Subroutine213_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_487:
   \   000046   8882         MOV     DPL,R0
   \   000048   8983         MOV     DPH,R1
   \   00004A   12....       LCALL   ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_401:
   \   00004D   12....       LCALL   ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   000050   12....       LCALL   `??zclGetAttrDataLengthUsingCB::?relay`; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   000053   85..82       MOV     DPL,?XSP + 0
   \   000056   85..83       MOV     DPH,?XSP + 1
   \   000059   12....       LCALL   ??Subroutine222_0 & 0xFFFF
   4591          
   4592              // add padding if needed
   4593              if ( PADDING_NEEDED( dataLen ) )
   \                     ??CrossCallReturnLabel_539:
   \   00005C   85..82       MOV     DPL,?XSP + 0
   \   00005F   85..83       MOV     DPH,?XSP + 1
   \   000062   E0           MOVX    A,@DPTR
   \   000063   A2E0         MOV     C,0xE0 /* A   */.0
   \   000065   5003         JNC     ??CrossCallReturnLabel_237
   4594              {
   4595                dataLen++;
   \   000067   12....       LCALL   ?Subroutine130 & 0xFFFF
   4596              }
   4597          
   4598              curLen += dataLen;
   \                     ??CrossCallReturnLabel_237:
   \   00006A   85..82       MOV     DPL,?XSP + 0
   \   00006D   85..83       MOV     DPH,?XSP + 1
   \   000070   E0           MOVX    A,@DPTR
   \   000071   25..         ADD     A,?V8
   \   000073   F5..         MOV     ?V8,A
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   35..         ADDC    A,?V9
   \   000079   F5..         MOV     ?V9,A
   \   00007B   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   00007C   7402         MOV     A,#0x2
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000084   5044         JNC     ??zclProcessInWriteUndividedCmd_4
   \   000086   EF           MOV     A,R7
   \   000087   75F005       MOV     B,#0x5
   \   00008A   A4           MUL     AB
   \   00008B   F8           MOV     R0,A
   \   00008C   A9F0         MOV     R1,B
   \   00008E   7402         MOV     A,#0x2
   \   000090   12....       LCALL   ?XSTACK_DISP0_8
   \   000093   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000096   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   000099   12....       LCALL   ?XSTACK_DISP100_8
   \   00009C   88..         MOV     ?V10,R0
   \   00009E   89..         MOV     ?V11,R1
   \   0000A0   78..         MOV     R0,#?V10
   \   0000A2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A5   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0000A8   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000AB   7402         MOV     A,#0x2
   \   0000AD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B0   E9           MOV     A,R1
   \   0000B1   7048         JNZ     ??zclProcessInWriteUndividedCmd_5
   \   0000B3   85..82       MOV     DPL,?V0
   \   0000B6   85..83       MOV     DPH,?V1
   \   0000B9   A3           INC     DPTR
   \   0000BA   7486         MOV     A,#-0x7a
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   0000BC   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0000BF   85..82       MOV     DPL,?V0
   \   0000C2   85..83       MOV     DPH,?V1
   \   0000C5   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_470:
   \   0000C8   7E01         MOV     R6,#0x1
   4599            } // for loop
   4600          
   4601            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   0000CA   EE           MOV     A,R6
   \   0000CB   85..82       MOV     DPL,?V0
   \   0000CE   85..83       MOV     DPH,?V1
   \   0000D1   F0           MOVX    @DPTR,A
   4602            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   0000D2   6003         JZ      $+5
   \   0000D4   02....       LJMP    ??zclProcessInWriteUndividedCmd_7 & 0xFFFF
   4603            {
   4604              uint8 *curDataPtr;
   4605              zclWriteRec_t *curWriteRec;
   4606          
   4607              // calculate the length of the current data header
   4608              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   \   0000D7   75F005       MOV     B,#0x5
   \   0000DA   A4           MUL     AB
   \   0000DB   FF           MOV     R7,A
   4609          
   4610              // Allocate space to keep a copy of the current data
   4611              curWriteRec = (zclWriteRec_t *) zcl_mem_alloc( hdrLen + curLen );
   \   0000DC                ; Setup parameters for call to function osal_mem_alloc
   \   0000DC   25..         ADD     A,?V8
   \   0000DE   FA           MOV     R2,A
   \   0000DF   E4           CLR     A
   \   0000E0   35..         ADDC    A,?V9
   \   0000E2   FB           MOV     R3,A
   \   0000E3   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000E6   8A..         MOV     ?V14,R2
   \   0000E8   8B..         MOV     ?V15,R3
   4612              if ( curWriteRec == NULL )
   \   0000EA   EA           MOV     A,R2
   \   0000EB   45..         ORL     A,?V15
   \   0000ED   705C         JNZ     ??zclProcessInWriteUndividedCmd_8
   4613              {
   4614                zcl_mem_free(writeRspCmd );
   \   0000EF                ; Setup parameters for call to function osal_mem_free
   \   0000EF   AA..         MOV     R2,?V0
   \   0000F1   AB..         MOV     R3,?V1
   \   0000F3   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4615                return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   0000F6   7900         MOV     R1,#0x0
   \   0000F8   02....       LJMP    ??zclProcessInWriteUndividedCmd_9 & 0xFFFF
   4616              }
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   0000FB   7408         MOV     A,#0x8
   \   0000FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000100   12....       LCALL   ??Subroutine219_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_523:
   \   000103   A3           INC     DPTR
   \   000104   A3           INC     DPTR
   \   000105   E0           MOVX    A,@DPTR
   \   000106   69           XRL     A,R1
   \   000107   600B         JZ      ??zclProcessInWriteUndividedCmd_10
   \   000109   85..82       MOV     DPL,?V0
   \   00010C   85..83       MOV     DPH,?V1
   \   00010F   A3           INC     DPTR
   \   000110   748D         MOV     A,#-0x73
   \   000112   80A8         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   000114   7409         MOV     A,#0x9
   \   000116   12....       LCALL   ?XSTACK_DISP0_8
   \   000119   E0           MOVX    A,@DPTR
   \   00011A   A2E1         MOV     C,0xE0 /* A   */.1
   \   00011C   400B         JC      ??zclProcessInWriteUndividedCmd_11
   \   00011E   85..82       MOV     DPL,?V0
   \   000121   85..83       MOV     DPH,?V1
   \   000124   A3           INC     DPTR
   \   000125   7488         MOV     A,#-0x78
   \   000127   8093         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   000129   A2E5         MOV     C,0xE0 /* A   */.5
   \   00012B   500B         JNC     ??zclProcessInWriteUndividedCmd_12
   \   00012D   85..82       MOV     DPL,?V0
   \   000130   85..83       MOV     DPH,?V1
   \   000133   A3           INC     DPTR
   \   000134   747E         MOV     A,#0x7e
   \   000136   8084         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   000138   740A         MOV     A,#0xa
   \   00013A   12....       LCALL   ?XSTACK_DISP0_8
   \   00013D   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_313:
   \   000140   7003         JNZ     $+5
   \   000142   02....       LJMP    ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   \   000145                ; Setup parameters for call to function zclGetAttrDataLength
   \   000145   12....       LCALL   `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000148   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   4617          
   4618              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   00014B   EA           MOV     A,R2
   \   00014C   2F           ADD     A,R7
   \   00014D   F5..         MOV     ?V8,A
   \   00014F   E4           CLR     A
   \   000150   3B           ADDC    A,R3
   \   000151   F5..         MOV     ?V9,A
   4619          
   4620              // Write the new data over
   4621              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000153   7F00         MOV     R7,#0x0
   \   000155   801C         SJMP    ??zclProcessInWriteUndividedCmd_13
   4622              {
   4623                uint8 status;
   4624                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4625                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   4626          
   4627                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4628                                      statusRec->attrID, &attrRec ) )
   4629                {
   4630                  break; // should never happen
   4631                }
   4632          
   4633                // Keep a copy of the current data before before writing the new data over
   4634                curStatusRec->attrID = statusRec->attrID;
   4635                curStatusRec->attrData = curDataPtr;
   4636          
   4637                if ( attrRec.attr.dataPtr != NULL )
   4638                {
   4639                  // Read the current value
   4640                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   4641          
   4642                  // Write the new attribute value
   4643                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4644                                             &attrRec, statusRec );
   4645                }
   4646                else // Use CBs
   4647                {
   4648                  // Read the current value
   4649                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4650                                          statusRec->attrID, curDataPtr, &dataLen );
   4651                  // Write the new attribute value
   4652                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4653                                                    &attrRec, statusRec->attrData );
   4654                }
   4655          
   4656                // If successful, a write attribute status record shall NOT be generated
   4657                if ( status != ZCL_STATUS_SUCCESS )
   4658                {
   4659                  writeRspCmd->attrList[j].status = status;
   4660                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4661          
   4662                  // Since this write failed, we need to revert all the pervious writes
   4663                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   4664                  break;
   4665                }
   4666          
   4667                // add padding if needed
   4668                if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   000157   85..82       MOV     DPL,?XSP + 0
   \   00015A   85..83       MOV     DPH,?XSP + 1
   \   00015D   E0           MOVX    A,@DPTR
   \   00015E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000160   5003         JNC     ??CrossCallReturnLabel_238
   4669                {
   4670                  dataLen++;
   \   000162   12....       LCALL   ?Subroutine130 & 0xFFFF
   4671                }
   4672          
   4673                curDataPtr += dataLen;
   \                     ??CrossCallReturnLabel_238:
   \   000165   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_505:
   \   000168   E5..         MOV     A,?V8
   \   00016A   28           ADD     A,R0
   \   00016B   F5..         MOV     ?V8,A
   \   00016D   E5..         MOV     A,?V9
   \   00016F   39           ADDC    A,R1
   \   000170   F5..         MOV     ?V9,A
   \   000172   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   000173   7402         MOV     A,#0x2
   \   000175   12....       LCALL   ?XSTACK_DISP0_8
   \   000178   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   00017B   4003         JC      $+5
   \   00017D   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   000180   EF           MOV     A,R7
   \   000181   75F005       MOV     B,#0x5
   \   000184   A4           MUL     AB
   \   000185   F8           MOV     R0,A
   \   000186   A9F0         MOV     R1,B
   \   000188   7402         MOV     A,#0x2
   \   00018A   12....       LCALL   ?XSTACK_DISP0_8
   \   00018D   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000190   E5..         MOV     A,?V14
   \   000192   28           ADD     A,R0
   \   000193   F5..         MOV     ?V12,A
   \   000195   E5..         MOV     A,?V15
   \   000197   39           ADDC    A,R1
   \   000198   F5..         MOV     ?V13,A
   \   00019A   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   00019D   12....       LCALL   ?XSTACK_DISP100_8
   \   0001A0   88..         MOV     ?V10,R0
   \   0001A2   89..         MOV     ?V11,R1
   \   0001A4   78..         MOV     R0,#?V10
   \   0001A6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001A9   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   0001AC   12....       LCALL   `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0001AF   7402         MOV     A,#0x2
   \   0001B1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001B4   E9           MOV     A,R1
   \   0001B5   7003         JNZ     $+5
   \   0001B7   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   0001BA   85..82       MOV     DPL,?V2
   \   0001BD   85..83       MOV     DPH,?V3
   \   0001C0   12....       LCALL   ??Subroutine216_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_503:
   \   0001C3   85..82       MOV     DPL,?V12
   \   0001C6   85..83       MOV     DPH,?V13
   \   0001C9   E8           MOV     A,R0
   \   0001CA   F0           MOVX    @DPTR,A
   \   0001CB   A3           INC     DPTR
   \   0001CC   E9           MOV     A,R1
   \   0001CD   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0001D0   E5..         MOV     A,?V8
   \   0001D2   F0           MOVX    @DPTR,A
   \   0001D3   A3           INC     DPTR
   \   0001D4   E5..         MOV     A,?V9
   \   0001D6   F0           MOVX    @DPTR,A
   \   0001D7   740A         MOV     A,#0xa
   \   0001D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DC   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_378:
   \   0001DF   6049         JZ      ??zclProcessInWriteUndividedCmd_16
   \   0001E1                ; Setup parameters for call to function zclReadAttrData
   \   0001E1   A8..         MOV     R0,?XSP + 0
   \   0001E3   A9..         MOV     R1,?XSP + 1
   \   0001E5   88..         MOV     ?V6,R0
   \   0001E7   89..         MOV     ?V7,R1
   \   0001E9   78..         MOV     R0,#?V6
   \   0001EB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001EE   7406         MOV     A,#0x6
   \   0001F0   12....       LCALL   ?XSTACK_DISP102_8
   \   0001F3   AA..         MOV     R2,?V8
   \   0001F5   AB..         MOV     R3,?V9
   \   0001F7   12....       LCALL   `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   0001FA   7402         MOV     A,#0x2
   \   0001FC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001FF   85..82       MOV     DPL,?V4
   \   000202   85..83       MOV     DPH,?V5
   \   000205   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   000208                ; Setup parameters for call to function zclWriteAttrData
   \   000208   78..         MOV     R0,#?V2
   \   00020A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00020D   7406         MOV     A,#0x6
   \   00020F   12....       LCALL   ?XSTACK_DISP102_8
   \   000212   E5..         MOV     A,?V6
   \   000214   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_494:
   \   000217   35..         ADDC    A,?V7
   \   000219   FB           MOV     R3,A
   \   00021A   E5..         MOV     A,?V6
   \   00021C   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   00021F   35..         ADDC    A,?V7
   \   000221   F583         MOV     DPH,A
   \   000223   E0           MOVX    A,@DPTR
   \   000224   F9           MOV     R1,A
   \   000225   12....       LCALL   `??zclWriteAttrData::?relay`; Banked call to: zclWriteAttrData
   \   000228   802F         SJMP    ??zclProcessInWriteUndividedCmd_17
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   00022A   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   00022D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000230   78..         MOV     R0,#?V8
   \   000232   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000235   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000238   12....       LCALL   `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   00023B   7404         MOV     A,#0x4
   \   00023D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000240   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_522:
   \   000243   A3           INC     DPTR
   \   000244   A3           INC     DPTR
   \   000245   A3           INC     DPTR
   \   000246   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000249   7406         MOV     A,#0x6
   \   00024B   12....       LCALL   ?XSTACK_DISP102_8
   \   00024E   12....       LCALL   ?Subroutine167 & 0xFFFF
   \                     ??CrossCallReturnLabel_497:
   \   000251   39           ADDC    A,R1
   \   000252   FB           MOV     R3,A
   \   000253   12....       LCALL   ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   000256   12....       LCALL   `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   000259   7402         MOV     A,#0x2
   \   00025B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00025E   E9           MOV     A,R1
   \   00025F   FA           MOV     R2,A
   \   000260   EA           MOV     A,R2
   \   000261   7003         JNZ     $+5
   \   000263   02....       LJMP    ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   \   000266   EE           MOV     A,R6
   \   000267   75F003       MOV     B,#0x3
   \   00026A   A4           MUL     AB
   \   00026B   F8           MOV     R0,A
   \   00026C   A9F0         MOV     R1,B
   \   00026E   E5..         MOV     A,?V0
   \   000270   28           ADD     A,R0
   \   000271   F8           MOV     R0,A
   \   000272   E5..         MOV     A,?V1
   \   000274   39           ADDC    A,R1
   \   000275   F9           MOV     R1,A
   \   000276   EA           MOV     A,R2
   \   000277   8882         MOV     DPL,R0
   \   000279   8983         MOV     DPH,R1
   \   00027B   A3           INC     DPTR
   \   00027C   F0           MOVX    @DPTR,A
   \   00027D   85..82       MOV     DPL,?V2
   \   000280   85..83       MOV     DPH,?V3
   \   000283   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   000286   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_541:
   \   000289   0E           INC     R6
   \   00028A                ; Setup parameters for call to function zclRevertWriteUndividedCmd
   \   00028A   8F..         MOV     ?V2,R7
   \   00028C   75..00       MOV     ?V3,#0x0
   \   00028F   78..         MOV     R0,#?V2
   \   000291   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000294   AC..         MOV     R4,?V14
   \   000296   AD..         MOV     R5,?V15
   \   000298   AA..         MOV     R2,?V4
   \   00029A   AB..         MOV     R3,?V5
   \   00029C   12....       LCALL   `??zclRevertWriteUndividedCmd::?relay`; Banked call to: zclRevertWriteUndividedCmd
   \   00029F   7402         MOV     A,#0x2
   \   0002A1   12....       LCALL   ?DEALLOC_XSTACK8
   4674              } // for loop
   4675          
   4676              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0002A4   EE           MOV     A,R6
   \   0002A5   85..82       MOV     DPL,?V0
   \   0002A8   85..83       MOV     DPH,?V1
   \   0002AB   F0           MOVX    @DPTR,A
   4677              if ( writeRspCmd->numAttr  == 0 )
   \   0002AC   7003         JNZ     ??CrossCallReturnLabel_52
   4678              {
   4679                // Since all records were written successful, include a single status record
   4680                // in the resonse command with the status field set to SUCCESS and the
   4681                // attribute ID field omitted.
   4682                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0002AE   12....       LCALL   ?Subroutine40 & 0xFFFF
   4683                writeRspCmd->numAttr = 1;
   4684              }
   4685          
   4686              zcl_mem_free( curWriteRec );
   \                     ??CrossCallReturnLabel_52:
   \   0002B1                ; Setup parameters for call to function osal_mem_free
   \   0002B1   AA..         MOV     R2,?V14
   \   0002B3   AB..         MOV     R3,?V15
   \   0002B5   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4687            }
   4688          
   4689            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4690                              pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4691                              true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0002B8   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   0002BB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002BE   75..01       MOV     ?V2,#0x1
   \   0002C1   78..         MOV     R0,#?V2
   \   0002C3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002C6   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_479:
   \   0002C9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002CC   78..         MOV     R0,#?V0
   \   0002CE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002D1   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   0002D4   12....       LCALL   `??zcl_SendWriteRsp::?relay`; Banked call to: zcl_SendWriteRsp
   \   0002D7   7405         MOV     A,#0x5
   \   0002D9   12....       LCALL   ?DEALLOC_XSTACK8
   4692            zcl_mem_free( writeRspCmd );
   \   0002DC                ; Setup parameters for call to function osal_mem_free
   \   0002DC   AA..         MOV     R2,?V0
   \   0002DE   AB..         MOV     R3,?V1
   \   0002E0   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4693          
   4694            return TRUE;
   \   0002E3   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   0002E5   740C         MOV     A,#0xc
   \   0002E7   02....       LJMP    ??Subroutine174_0 & 0xFFFF
   4695          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine130:
   \   000000   2401         ADD     A,#0x1
   \   000002   F0           MOVX    @DPTR,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3400         ADDC    A,#0x0
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine114:
   \   000000   E8           MOV     A,R0
   \   000001   12....       LCALL   ?Subroutine166 & 0xFFFF
   \                     ??CrossCallReturnLabel_288:
   \   000004   39           ADDC    A,R1
   \   000005   F583         MOV     DPH,A
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine107:
   \   000000   12....       LCALL   ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_500:
   \   000003                ; Setup parameters for call to function zclFindAttrRec
   \   000003                ; Setup parameters for call to function zclFindAttrRec
   \   000003   7404         MOV     A,#0x4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   12....       LCALL   ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   EF           MOV     A,R7
   \   000006   C3           CLR     C
   \   000007   98           SUBB    A,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   FA           MOV     R2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   8A82         MOV     DPL,R2
   \   000008   F583         MOV     DPH,A
   \   00000A   A3           INC     DPTR
   \   00000B   8582..       MOV     ?V2,DPL
   \   00000E   8583..       MOV     ?V3,DPH
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine218_0
   \   000006                ; // Fall through to label ??Subroutine218_0

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_event_loop::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerForMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerForMsgExt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsgExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_addExternalFoundationHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_addExternalFoundationHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getExternalFoundationHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getExternalFoundationHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_HandleExternal::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_HandleExternal

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getRawAFMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getRawAFMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getParsedTransSeqNum::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getParsedTransSeqNum

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerPlugin::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerAttrList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerClusterOptionList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerValidateAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerReadWriteCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_DeviceOperational::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendCommand::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendRead::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReadRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendWriteRequest::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendWriteRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendConfigReportCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendConfigReportRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReadReportCfgCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReadReportCfgRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReportCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendDefaultRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_ProcessMessageMSG::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseHdr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclBuildHdr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindAttrRecsList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRecsList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindAttrRec::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetReadWriteCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAuthorizeCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAuthorizeCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindClusterOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetClusterOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclSetSecurityOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclSerializeData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclAnalogDataType::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAnalogDataType

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_BuildAnalogData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_BuildAnalogData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetDataTypeLength::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAttrDataLength::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclReadAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_ReadAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAttrDataLengthUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLengthUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclReadAttrDataUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclWriteAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclWriteAttrDataUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclAuthorizeWrite::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAuthorizeWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInWriteCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInWriteRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInConfigReportCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInConfigReportRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadReportCfgCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadReportCfgRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReportCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInDefaultRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInReadCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInWriteCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclRevertWriteUndividedCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclRevertWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInWriteUndividedCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd
   4696          #endif // ZCL_WRITE
   4697          
   4698          #ifdef ZCL_DISCOVER
   4699          /*********************************************************************
   4700           * @fn      zclProcessInDiscAttrs
   4701           *
   4702           * @brief   Process the "Profile" Discover Attributes Commands
   4703           *
   4704           * @param   pInMsg - incoming message to process
   4705           *
   4706           * @return  TRUE if command processed. FALSE, otherwise.
   4707           */
   4708          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
   4709          {
   4710            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4711            zclAttrRec_t attrRec;
   4712            uint16 attrID;
   4713            uint8 numAttrs;
   4714            uint8 i;
   4715          
   4716            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
   4717          
   4718            // Find out the number of attributes supported within the specified range
   4719            for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
   4720            {
   4721              // finds the next attribute on this endpoint/cluster after the range.
   4722              // attributes must be in numerical order in the list.
   4723              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4724              {
   4725                break;
   4726              }
   4727            }
   4728          
   4729            numAttrs = i;  // store range of attributes in buffer
   4730          
   4731              // Process message for either attributes or extended attributes
   4732            if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
   4733            {
   4734              zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
   4735            }
   4736            else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
   4737            {
   4738              zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
   4739            }
   4740          
   4741            return TRUE;
   4742          }
   4743          
   4744          /*********************************************************************
   4745           * @fn      zclProcessInDiscAttrsCmd
   4746           *
   4747           * @brief   Process the Discover Attributes Command
   4748           *
   4749           * @param   pInMsg - incoming message to process
   4750           *
   4751           * @param   pDiscoverCmd - structure from requesting command
   4752           *
   4753           * @param   attrLenBuf - describes the amount of attributes to be processed
   4754           *
   4755           * @return  none
   4756           */
   4757          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4758          {
   4759            zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
   4760            uint8 discComplete = TRUE;
   4761            zclAttrRec_t attrRec;
   4762            uint16 attrID;
   4763            uint8 i;
   4764          
   4765            // Allocate space for the response command
   4766            pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
   4767                                                                    + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
   4768            if ( pDiscoverRsp == NULL )
   4769            {
   4770              return; // EMBEDDED RETURN
   4771            }
   4772          
   4773            if ( numAttrs != 0 )
   4774            {
   4775              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4776              {
   4777                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4778                {
   4779                  break; // should not happen, as numAttrs already calculated
   4780                }
   4781          
   4782                pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
   4783                pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
   4784              }
   4785          
   4786              // Are there more attributes to be discovered?
   4787              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4788              {
   4789                discComplete = FALSE;
   4790              }
   4791            }
   4792          
   4793            pDiscoverRsp->discComplete = discComplete;
   4794            pDiscoverRsp->numAttr = numAttrs;
   4795          
   4796            zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4797                                         pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
   4798                                         true, pInMsg->hdr.transSeqNum );
   4799            zcl_mem_free( pDiscoverRsp );
   4800          
   4801            return;
   4802          }
   4803          
   4804          /*********************************************************************
   4805           * @fn      zclProcessInDiscAttrsExtCmd
   4806           *
   4807           * @brief   Process the Discover Attributes Extended Command
   4808           *
   4809           * @param   pInMsg - incoming message to process
   4810           *
   4811           * @param   pDiscoverCmd - structure from requesting command
   4812           *
   4813           * @param   attrLenBuf - describes the amount of attributes to be processed
   4814           *
   4815           * @return  none
   4816           */
   4817          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4818          {
   4819            zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
   4820            uint8 discComplete = TRUE;
   4821            zclAttrRec_t attrRec;
   4822            uint16 attrID;
   4823            uint8 i;
   4824          
   4825              // Allocate space for the response command
   4826            pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
   4827                                                                   + sizeof ( zclExtAttrInfo_t ) * numAttrs );
   4828            if ( pDiscoverExtRsp == NULL )
   4829            {
   4830              return; // EMBEDDED RETURN
   4831            }
   4832          
   4833          
   4834            if ( numAttrs != 0 )
   4835            {
   4836              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4837              {
   4838                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4839                {
   4840                  break; // Should not happen, as numAttrs already calculated
   4841                }
   4842          
   4843                pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
   4844                pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
   4845                pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
   4846              }
   4847          
   4848              // Are there more attributes to be discovered?
   4849              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4850              {
   4851                discComplete = FALSE;
   4852              }
   4853            }
   4854          
   4855            pDiscoverExtRsp->discComplete = discComplete;
   4856            pDiscoverExtRsp->numAttr = numAttrs;
   4857          
   4858            zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4859                                         pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
   4860                                         true, pInMsg->hdr.transSeqNum );
   4861          
   4862            zcl_mem_free( pDiscoverExtRsp );
   4863          
   4864            return;
   4865          }
   4866          
   4867          /*********************************************************************
   4868           * @fn      zclProcessInDiscCmd
   4869           *
   4870           * @brief   Process the "Profile" Discover Command
   4871           *
   4872           * @param   pInMsg - incoming message to process
   4873           *
   4874           * @return  TRUE if command processed. FALSE, otherwise.
   4875           */
   4876          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   4877          {
   4878            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4879            zclDiscoverCmdsCmdRsp_t cmdRsp;
   4880            ZStatus_t status;
   4881            zclCommandRec_t cmdRec;
   4882            uint8 cmdID;
   4883            uint8 i;
   4884            uint8 j;
   4885          
   4886            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
   4887          
   4888            // Find out the number of commands supported within the specified range
   4889            for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
   4890            {
   4891              if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4892              {
   4893                break;  // Command not supported
   4894              }
   4895            }
   4896          
   4897            // Allocate space for the response command
   4898            cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
   4899          
   4900            if ( cmdRsp.pCmdID == NULL )
   4901            {
   4902              return FALSE; // EMBEDDED RETURN
   4903            }
   4904          
   4905            if ( i != 0 )
   4906            {
   4907              for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
   4908              {
   4909                if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4910                {
   4911                  break; // Attribute not supported
   4912                }
   4913          
   4914                cmdRsp.pCmdID[j] = cmdRec.cmdID;
   4915              }
   4916            }
   4917          
   4918            // Are there more commands to be discovered?
   4919            if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4920            {
   4921              cmdRsp.discComplete = FALSE;
   4922            }
   4923            else
   4924            {
   4925              cmdRsp.discComplete = TRUE;
   4926            }
   4927          
   4928            // pass the command requested
   4929            cmdRsp.cmdType = pInMsg->hdr.commandID;
   4930          
   4931            // store number of commands returned
   4932            cmdRsp.numCmd = j;
   4933          
   4934            status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4935                                                pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
   4936                                                true, pInMsg->hdr.transSeqNum );
   4937          
   4938            zcl_mem_free( cmdRsp.pCmdID );
   4939          
   4940            if ( status == ZSuccess )
   4941            {
   4942              return TRUE;
   4943            }
   4944            else
   4945            {
   4946              return FALSE;
   4947            }
   4948          }
   4949          
   4950          #endif // ZCL_DISCOVER
   4951          
   4952          
   4953          /*********************************************************************
   4954          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     26   zclAnalogDataType
      0     29   zclAuthorizeWrite
        0     14   -> zclGetAuthorizeCB
      1     39   zclBuildHdr
      2     54   zclFindAttrRec
        0     16   -> zclFindAttrRecsList
      2     16   zclFindAttrRecsList
      0     20   zclFindClusterOption
      0     45   zclGetAttrDataLength
        0      9   -> zclGetDataTypeLength
      0     58   zclGetAttrDataLengthUsingCB
        0     18   -> zclGetReadWriteCB
      0     40   zclGetAuthorizeCB
        0     10   -> zclFindAttrRecsList
      0     46   zclGetClusterOption
        0     10   -> zclFindClusterOption
      0     26   zclGetDataTypeLength
      0     28   zclGetReadWriteCB
        0     10   -> zclFindAttrRecsList
      1     46   zclParseHdr
        0     10   -> osal_memset
      1     20   zclParseInConfigReportCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_memset
        0     20   -> zclAnalogDataType
        0     20   -> zclGetDataTypeLength
        0     20   -> zcl_BuildAnalogData
      1     12   zclParseInConfigReportRspCmd
        0     12   -> osal_mem_alloc
      1     10   zclParseInDefaultRspCmd
        0     10   -> osal_mem_alloc
      1     12   zclParseInReadCmd
        0     12   -> osal_mem_alloc
      1     12   zclParseInReadReportCfgCmd
        0     12   -> osal_mem_alloc
      1     20   zclParseInReadReportCfgRspCmd
        0     20   -> osal_mem_alloc
        0     20   -> zclAnalogDataType
        0     20   -> zclGetDataTypeLength
        0     20   -> zcl_BuildAnalogData
      1     25   zclParseInReadRspCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInReportCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInWriteCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     16   zclParseInWriteRspCmd
        0     16   -> osal_mem_alloc
      1     35   zclProcessInReadCmd
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     32   -> zclFindAttrRec
        0     30   -> zclGetAuthorizeCB
        0     35   -> zcl_SendReadRsp
      1     37   zclProcessInWriteCmd
        0     32   -> osal_mem_alloc
        0     32   -> osal_mem_free
        0     34   -> zclFindAttrRec
        0     34   -> zclWriteAttrData
        0     34   -> zclWriteAttrDataUsingCB
        0     37   -> zcl_SendWriteRsp
      1     41   zclProcessInWriteUndividedCmd
        0     36   -> osal_mem_alloc
        0     36   -> osal_mem_free
        0     38   -> zclFindAttrRec
        0     36   -> zclGetAttrDataLength
        0     36   -> zclGetAttrDataLengthUsingCB
        0     38   -> zclReadAttrData
        0     40   -> zclReadAttrDataUsingCB
        0     38   -> zclRevertWriteUndividedCmd
        0     38   -> zclWriteAttrData
        0     38   -> zclWriteAttrDataUsingCB
        0     41   -> zcl_SendWriteRsp
      0     56   zclReadAttrData
        0     18   -> osal_memcpy
        0     15   -> zclGetAttrDataLength
      0     60   zclReadAttrDataUsingCB
        0     16   -> zclGetReadWriteCB
      0     69   zclRevertWriteUndividedCmd
        0     31   -> osal_memcpy
        0     30   -> zclFindAttrRec
        0     28   -> zclGetAttrDataLength
        0     30   -> zclWriteAttrDataUsingCB
      1     45   zclSerializeData
        0     19   -> osal_buffer_uint32
        0     18   -> osal_memcpy
      0     46   zclSetSecurityOption
        0     10   -> zclFindClusterOption
      0     56   zclWriteAttrData
        0     18   -> osal_memcpy
        0     15   -> zclAuthorizeWrite
        0     15   -> zclGetAttrDataLength
      0     56   zclWriteAttrDataUsingCB
        0     14   -> zclAuthorizeWrite
        0     14   -> zclGetReadWriteCB
      1     36   zcl_BuildAnalogData
        0     16   -> zclGetAttrDataLength
      0     61   zcl_DeviceOperational
        0     23   -> zclFindAttrRec
        0     23   -> zclReadAttrData
      1     12   zcl_HandleExternal
        0     12   -> osal_msg_allocate
        0     12   -> osal_msg_send
        0     12   -> zcl_getExternalFoundationHandler
      2      0   zcl_Init
      1     55   zcl_ProcessMessageMSG
        0     36   -> afFindEndPointDesc
        0     36   -> osal_mem_free
        0     36   -> zclGetClusterOption
        0     36   -> zclParseHdr
        0     36   -> zclSetSecurityOption
        0     38   -> zcl_DeviceOperational
        0     43   -> zcl_SendDefaultRspCmd
      0     32   zcl_ReadAttrData
        0     26   -> zclFindAttrRec
        0     26   -> zclReadAttrData
        0     28   -> zclReadAttrDataUsingCB
      1     76   zcl_SendCommand
        0     39   -> AF_DataRequest
        0     30   -> afFindEndPointDesc
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     33   -> osal_memcpy
        0     30   -> osal_memset
        0     30   -> zclBuildHdr
        0     30   -> zclGetClusterOption
        0     32   -> zcl_DeviceOperational
      1     42   zcl_SendConfigReportCmd
        0     26   -> osal_mem_alloc
        0     26   -> osal_mem_free
        0     26   -> zclAnalogDataType
        0     26   -> zclGetDataTypeLength
        0     26   -> zclSerializeData
        0     37   -> zcl_SendCommand
      1     36   zcl_SendConfigReportRspCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     66   zcl_SendDefaultRspCmd
        0     23   -> zcl_SendCommand
      1     36   zcl_SendRead
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     36   zcl_SendReadReportCfgCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     42   zcl_SendReadReportCfgRspCmd
        0     26   -> osal_mem_alloc
        0     26   -> osal_mem_free
        0     26   -> zclAnalogDataType
        0     26   -> zclGetDataTypeLength
        0     26   -> zclSerializeData
        0     37   -> zcl_SendCommand
      1     70   zcl_SendReadRsp
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclGetAttrDataLength
        0     24   -> zclGetAttrDataLengthUsingCB
        0     28   -> zclReadAttrDataUsingCB
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     38   zcl_SendReportCmd
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     22   -> zclGetAttrDataLength
        0     22   -> zclSerializeData
        0     33   -> zcl_SendCommand
      1     39   zcl_SendWriteRequest
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     22   -> zclGetAttrDataLength
        0     22   -> zclSerializeData
        0     33   -> zcl_SendCommand
      1     72   zcl_SendWriteRsp
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     19   zcl_addExternalFoundationHandler
        0     10   -> osal_mem_alloc
      0     12   zcl_event_loop
        0     12   -> osal_msg_deallocate
        0     12   -> osal_msg_receive
        0     12   -> osal_msg_send
        0     12   -> zcl_ProcessMessageMSG
        0     12   -> zcl_getExternalFoundationHandler
      2     12   zcl_getExternalFoundationHandler
      2      0   zcl_getParsedTransSeqNum
      2      0   zcl_getRawAFMsg
      1     12   zcl_registerAttrList
        0     12   -> osal_mem_alloc
      1     12   zcl_registerClusterOptionList
        0     12   -> osal_mem_alloc
      0      9   zcl_registerForMsg
        0      9   -> zcl_addExternalFoundationHandler
      0      9   zcl_registerForMsgExt
        0      9   -> zcl_addExternalFoundationHandler
      0     14   zcl_registerPlugin
        0     12   -> osal_mem_alloc
      0     14   zcl_registerReadWriteCB
        0     14   -> zclFindAttrRecsList
      2      0   zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??Subroutine174_0
       9  ??Subroutine175_0
       6  ??Subroutine176_0
       5  ??Subroutine177_0
       6  ??Subroutine178_0
       5  ??Subroutine179_0
       5  ??Subroutine180_0
       7  ??Subroutine181_0
       6  ??Subroutine182_0
       8  ??Subroutine183_0
       9  ??Subroutine184_0
       8  ??Subroutine185_0
       1  ??Subroutine186_0
       2  ??Subroutine187_0
       1  ??Subroutine188_0
       8  ??Subroutine189_0
       8  ??Subroutine190_0
       6  ??Subroutine191_0
       7  ??Subroutine192_0
       5  ??Subroutine193_0
       5  ??Subroutine194_0
       5  ??Subroutine195_0
       1  ??Subroutine196_0
       3  ??Subroutine197_0
       4  ??Subroutine198_0
       6  ??Subroutine199_0
       5  ??Subroutine200_0
       4  ??Subroutine201_0
      10  ??Subroutine202_0
       8  ??Subroutine203_0
       6  ??Subroutine204_0
       7  ??Subroutine205_0
       7  ??Subroutine206_0
      12  ??Subroutine207_0
       6  ??Subroutine208_0
       6  ??Subroutine209_0
       5  ??Subroutine210_0
      10  ??Subroutine211_0
       2  ??Subroutine212_0
       4  ??Subroutine213_0
       5  ??Subroutine214_0
       8  ??Subroutine215_0
       4  ??Subroutine216_0
      10  ??Subroutine217_0
       4  ??Subroutine218_0
       9  ??Subroutine219_0
       6  ??Subroutine220_0
       6  ??Subroutine221_0
       6  ??Subroutine222_0
       7  ?Subroutine0
       5  ?Subroutine1
       5  ?Subroutine10
       4  ?Subroutine100
       6  ?Subroutine101
       5  ?Subroutine102
       5  ?Subroutine103
      10  ?Subroutine104
       8  ?Subroutine105
      21  ?Subroutine106
       6  ?Subroutine107
       4  ?Subroutine108
      19  ?Subroutine109
       5  ?Subroutine11
       8  ?Subroutine110
       7  ?Subroutine111
       6  ?Subroutine112
      12  ?Subroutine113
      10  ?Subroutine114
      12  ?Subroutine115
       4  ?Subroutine116
       4  ?Subroutine117
      23  ?Subroutine118
      13  ?Subroutine119
       5  ?Subroutine12
      12  ?Subroutine120
      21  ?Subroutine121
      16  ?Subroutine122
       8  ?Subroutine123
      22  ?Subroutine124
      11  ?Subroutine125
      19  ?Subroutine126
      16  ?Subroutine127
       8  ?Subroutine128
      13  ?Subroutine129
      80  ?Subroutine13
       9  ?Subroutine130
      11  ?Subroutine131
      14  ?Subroutine132
      10  ?Subroutine133
       6  ?Subroutine134
       9  ?Subroutine135
       1  ?Subroutine136
       4  ?Subroutine137
       6  ?Subroutine138
       9  ?Subroutine139
       1  ?Subroutine14
       9  ?Subroutine140
       6  ?Subroutine141
      16  ?Subroutine142
       3  ?Subroutine143
      14  ?Subroutine144
      10  ?Subroutine145
       4  ?Subroutine146
       8  ?Subroutine147
       2  ?Subroutine148
       8  ?Subroutine149
      32  ?Subroutine15
       8  ?Subroutine150
       6  ?Subroutine151
      11  ?Subroutine152
      11  ?Subroutine153
      10  ?Subroutine154
       6  ?Subroutine155
       9  ?Subroutine156
       6  ?Subroutine157
       5  ?Subroutine158
       7  ?Subroutine159
      18  ?Subroutine16
       1  ?Subroutine160
       5  ?Subroutine161
       9  ?Subroutine162
       7  ?Subroutine163
      22  ?Subroutine164
      11  ?Subroutine165
       6  ?Subroutine166
       1  ?Subroutine167
       3  ?Subroutine168
       6  ?Subroutine169
      27  ?Subroutine17
       6  ?Subroutine170
       8  ?Subroutine171
       5  ?Subroutine172
       7  ?Subroutine173
      20  ?Subroutine18
       7  ?Subroutine19
       3  ?Subroutine2
      18  ?Subroutine20
      30  ?Subroutine21
       8  ?Subroutine22
      14  ?Subroutine23
       4  ?Subroutine24
      12  ?Subroutine25
       2  ?Subroutine26
      12  ?Subroutine27
       6  ?Subroutine28
       4  ?Subroutine29
       5  ?Subroutine3
      11  ?Subroutine30
       4  ?Subroutine31
       5  ?Subroutine32
       4  ?Subroutine33
       6  ?Subroutine34
       8  ?Subroutine35
       8  ?Subroutine36
       5  ?Subroutine37
       4  ?Subroutine38
       7  ?Subroutine39
       5  ?Subroutine4
      12  ?Subroutine40
       7  ?Subroutine41
      10  ?Subroutine42
       8  ?Subroutine43
      17  ?Subroutine44
       2  ?Subroutine45
       2  ?Subroutine46
      34  ?Subroutine47
       5  ?Subroutine48
       5  ?Subroutine49
       4  ?Subroutine5
      10  ?Subroutine50
       4  ?Subroutine51
       6  ?Subroutine52
      17  ?Subroutine53
      20  ?Subroutine54
       6  ?Subroutine55
      28  ?Subroutine56
       6  ?Subroutine57
      18  ?Subroutine58
       3  ?Subroutine59
       4  ?Subroutine6
      23  ?Subroutine60
      27  ?Subroutine61
       5  ?Subroutine62
       6  ?Subroutine63
       9  ?Subroutine64
      10  ?Subroutine65
       6  ?Subroutine66
       9  ?Subroutine67
       6  ?Subroutine68
       6  ?Subroutine69
       4  ?Subroutine7
      18  ?Subroutine70
      14  ?Subroutine71
      24  ?Subroutine72
      32  ?Subroutine73
       4  ?Subroutine74
      14  ?Subroutine75
      13  ?Subroutine76
      23  ?Subroutine77
       4  ?Subroutine78
       9  ?Subroutine79
       5  ?Subroutine8
       4  ?Subroutine80
       4  ?Subroutine81
       9  ?Subroutine82
       4  ?Subroutine83
       5  ?Subroutine84
      12  ?Subroutine85
       6  ?Subroutine86
      10  ?Subroutine87
       2  ?Subroutine88
      17  ?Subroutine89
       3  ?Subroutine9
       2  ?Subroutine90
      12  ?Subroutine91
      11  ?Subroutine92
       8  ?Subroutine93
      24  ?Subroutine94
       9  ?Subroutine95
       4  ?Subroutine96
       1  ?Subroutine97
       4  ?Subroutine98
      14  ?Subroutine99
       2  attrList
       2  clusterOptionList
       2  externalEndPointHandlerList
       2  plugins
       2  rawAFMsg
       1  savedZCLTransSeqNum
      33  zclAnalogDataType
       6  zclAnalogDataType::?relay
      59  zclAuthorizeWrite
       6  zclAuthorizeWrite::?relay
      95  zclBuildHdr
       6  zclBuildHdr::?relay
      92  zclCmdTable
     146  zclFindAttrRec
       6  zclFindAttrRec::?relay
      37  zclFindAttrRecsList
       6  zclFindAttrRecsList::?relay
     108  zclFindClusterOption
       6  zclFindClusterOption::?relay
      63  zclGetAttrDataLength
       6  zclGetAttrDataLength::?relay
     101  zclGetAttrDataLengthUsingCB
       6  zclGetAttrDataLengthUsingCB::?relay
      27  zclGetAuthorizeCB
       6  zclGetAuthorizeCB::?relay
      29  zclGetClusterOption
       6  zclGetClusterOption::?relay
     166  zclGetDataTypeLength
       6  zclGetDataTypeLength::?relay
      29  zclGetReadWriteCB
       6  zclGetReadWriteCB::?relay
     192  zclParseHdr
       6  zclParseHdr::?relay
     325  zclParseInConfigReportCmd
       6  zclParseInConfigReportCmd::?relay
     137  zclParseInConfigReportRspCmd
       6  zclParseInConfigReportRspCmd::?relay
      31  zclParseInDefaultRspCmd
       6  zclParseInDefaultRspCmd::?relay
      94  zclParseInReadCmd
       6  zclParseInReadCmd::?relay
      72  zclParseInReadReportCfgCmd
       6  zclParseInReadReportCfgCmd::?relay
     338  zclParseInReadReportCfgRspCmd
       6  zclParseInReadReportCfgRspCmd::?relay
     330  zclParseInReadRspCmd
       6  zclParseInReadRspCmd::?relay
     147  zclParseInReportCmd
       6  zclParseInReportCmd::?relay
     147  zclParseInWriteCmd
       6  zclParseInWriteCmd::?relay
     113  zclParseInWriteRspCmd
       6  zclParseInWriteRspCmd::?relay
     414  zclProcessInReadCmd
       6  zclProcessInReadCmd::?relay
     410  zclProcessInWriteCmd
       6  zclProcessInWriteCmd::?relay
     746  zclProcessInWriteUndividedCmd
       6  zclProcessInWriteUndividedCmd::?relay
     109  zclReadAttrData
       6  zclReadAttrData::?relay
      93  zclReadAttrDataUsingCB
       6  zclReadAttrDataUsingCB::?relay
     258  zclRevertWriteUndividedCmd
       6  zclRevertWriteUndividedCmd::?relay
     368  zclSerializeData
       6  zclSerializeData::?relay
      46  zclSetSecurityOption
       6  zclSetSecurityOption::?relay
     150  zclWriteAttrData
       6  zclWriteAttrData::?relay
     104  zclWriteAttrDataUsingCB
       6  zclWriteAttrDataUsingCB::?relay
     129  zcl_BuildAnalogData
       6  zcl_BuildAnalogData::?relay
     126  zcl_DeviceOperational
       6  zcl_DeviceOperational::?relay
     179  zcl_HandleExternal
       6  zcl_HandleExternal::?relay
      12  zcl_Init
       6  zcl_Init::?relay
    1101  zcl_ProcessMessageMSG
       6  zcl_ProcessMessageMSG::?relay
     131  zcl_ReadAttrData
       6  zcl_ReadAttrData::?relay
     417  zcl_SendCommand
       6  zcl_SendCommand::?relay
     445  zcl_SendConfigReportCmd
       6  zcl_SendConfigReportCmd::?relay
     245  zcl_SendConfigReportRspCmd
       6  zcl_SendConfigReportRspCmd::?relay
     136  zcl_SendDefaultRspCmd
       6  zcl_SendDefaultRspCmd::?relay
     186  zcl_SendRead
       6  zcl_SendRead::?relay
     160  zcl_SendReadReportCfgCmd
       6  zcl_SendReadReportCfgCmd::?relay
     463  zcl_SendReadReportCfgRspCmd
       6  zcl_SendReadReportCfgRspCmd::?relay
     414  zcl_SendReadRsp
       6  zcl_SendReadRsp::?relay
     217  zcl_SendReportCmd
       6  zcl_SendReportCmd::?relay
     217  zcl_SendWriteRequest
       6  zcl_SendWriteRequest::?relay
     178  zcl_SendWriteRsp
       6  zcl_SendWriteRsp::?relay
       1  zcl_SeqNum
       1  zcl_TaskID
       1  zcl_TransID
       2  zcl_ValidateAttrDataCB
     133  zcl_addExternalFoundationHandler
       6  zcl_addExternalFoundationHandler::?relay
      98  zcl_event_loop
       6  zcl_event_loop::?relay
      60  zcl_getExternalFoundationHandler
       6  zcl_getExternalFoundationHandler::?relay
       9  zcl_getParsedTransSeqNum
       6  zcl_getParsedTransSeqNum::?relay
      12  zcl_getRawAFMsg
       6  zcl_getRawAFMsg::?relay
      89  zcl_registerAttrList
       6  zcl_registerAttrList::?relay
      73  zcl_registerClusterOptionList
       6  zcl_registerClusterOptionList::?relay
      10  zcl_registerForMsg
       6  zcl_registerForMsg::?relay
       8  zcl_registerForMsgExt
       6  zcl_registerForMsgExt::?relay
     103  zcl_registerPlugin
       6  zcl_registerPlugin::?relay
      58  zcl_registerReadWriteCB
       6  zcl_registerReadWriteCB::?relay
      15  zcl_registerValidateAttrData
       6  zcl_registerValidateAttrData::?relay

 
 12 964 bytes in segment BANKED_CODE
    372 bytes in segment BANK_RELAYS
     92 bytes in segment CODE_C
     16 bytes in segment XDATA_Z
 
 13 428 bytes of CODE  memory
     16 bytes of XDATA memory

Errors: none
Warnings: none
